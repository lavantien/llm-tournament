[{"text":"Create a pathfinding algorithm that finds the shortest path in a grid with obstacles, using dynamic programming.     Input: Grid: [[0, 0, 0, 0], [0, 1, 0, 0], [0, 0, 0, 1], [0, 0, 0, 0]], Start: (0,0), End: (3,3)      Output: Path: [(0,0), (1,0), (2,0), (3,0), (3,1), (3,2), (3,3)]      Passing Criteria: Correct shortest path, handles obstacles, efficiency."},{"text":"Implement a grid-based game like Pac-Man using Pygame, with ghosts following a simple AI.     Input: User controls for Pac-Man      Output: Game window with Pac-Man and ghosts      Passing Criteria: Correct Pac-Man movement, ghosts follow AI, eating pellets, collisions detected."},{"text":"Develop a version of the game Gomoku, focusing on the board logic and win condition system.     Input: Board state, moves made      Output: Updated board state      Passing Criteria: Correct Gomoku rules, proper win condition."},{"text":"Implement a dynamic programming solution for the longest common subsequence problem for two strings.     Input: Sequences: \"ABCBDAB\", \"BDCAB\"      Output: LCS length: 4      Passing Criteria: Correct LCS, handles different sequence lengths."},{"text":"Develop a game of Connect Four with an AI opponent using game theory.     Input: User moves, AI responds      Output: Game board, winner declaration      Passing Criteria: Correct game logic, AI plays optimally, handles winning conditions."},{"text":"Implement a dynamic programming solution for the maximum sum path in a grid, moving only right or down.     Input: Grid: [[3, 7, 9], [2, 5, 1], [8, 3, 4]]      Output: Maximum sum: 20      Passing Criteria: Correct sum calculation, handles grid boundaries."},{"text":"Implement a version of the game Othello/Reversi with basic AI using minimax.     Input: User moves, AI responds      Output: Game board, winner declaration      Passing Criteria: Correct game logic, AI uses minimax, handles captures correctly."},{"text":"Develop a dynamic programming solution for the coin change problem, finding the minimum number of coins for a given amount.     Input: Denominations: [1, 5, 10, 25], Amount: 30      Output: Minimum coins: 2      Passing Criteria: Correct minimum coins, handles various denominations."},{"text":"Create a game of Checkers using Pygame, including jump moves and game end conditions.     Input: User moves      Output: Game window with pieces, jumps, captures      Passing Criteria: Correct piece movement, jumping mechanics, game end conditions."},{"text":"Implement a dynamic programming solution for the edit distance problem between two strings.     Input: Strings: \"kitten\", \"sitting\"      Output: Edit distance: 3      Passing Criteria: Correct edit distance, handles different string lengths."},{"text":"### **Ant Colony Simulation**   Simulate an ant colony searching for food using an **Ant Colony Optimization (ACO)** algorithm. The simulation should include:   1. A grid-based environment with obstacles, a nest (starting point), and food sources.   2. Ants that move randomly but are influenced by pheromone trails left by other ants.   3. Pheromone evaporation over time to ensure dynamic pathfinding.   4. Visualization of the ants' movement, pheromone trails, and the discovery of the shortest path to the food source.    **Input:**   - Grid size: `10x10`   - Nest location: `(0, 0)`   - Food source location: `(9, 9)`   - Obstacles: `[(2, 2), (3, 3), (4, 4), (5, 5)]`   - Number of ants: `10`   - Pheromone evaporation rate: `0.1`    **Output:**   - Visualization of the grid showing:     - Ants moving from the nest to the food source.     - Pheromone trails being laid and evaporating.     - The shortest path discovered by the ants.   - Console output:     - Number of steps taken to find the food source.     - Final path coordinates (e.g., `[(0, 0), (1, 1), (2, 1), ..., (9, 9)]`).    **Passing Criteria:**   1. Ants successfully find the food source and return to the nest.   2. Pheromone trails are updated dynamically based on ant movement and evaporation.   3. The simulation converges to the shortest path over time.   4. Visualization is clear and updates in real-time.   5. The algorithm handles obstacles and avoids infinite loops.    **Example Implementation:**   ```python import numpy as np import matplotlib.pyplot as plt  class AntColonySimulation:     def __init__(self, grid_size, nest, food, obstacles, num_ants, evaporation_rate):         self.grid_size = grid_size         self.nest = nest         self.food = food         self.obstacles = obstacles         self.num_ants = num_ants         self.evaporation_rate = evaporation_rate         self.pheromones = np.zeros(grid_size)         self.grid = np.zeros(grid_size)         for obs in obstacles:             self.grid[obs] = -1  # Mark obstacles      def move_ant(self, ant_position):         # Implement ant movement logic here         pass      def update_pheromones(self):         # Implement pheromone update and evaporation logic here         pass      def simulate(self, steps):         for _ in range(steps):             for ant in range(self.num_ants):                 self.move_ant(self.nest)             self.update_pheromones()             self.visualize()      def visualize(self):         plt.imshow(self.pheromones, cmap='hot', interpolation='nearest')         plt.show()  # Example usage grid_size = (10, 10) nest = (0, 0) food = (9, 9) obstacles = [(2, 2), (3, 3), (4, 4), (5, 5)] num_ants = 10 evaporation_rate = 0.1  simulation = AntColonySimulation(grid_size, nest, food, obstacles, num_ants, evaporation_rate) simulation.simulate(100) ```  **Explanation:**   - The simulation uses a grid to represent the environment, with obstacles, a nest, and a food source.   - Ants move randomly but are influenced by pheromone trails.   - Pheromones evaporate over time to prevent stale paths.   - The visualization shows the ants' movement and the evolving pheromone trails.    **Expected Outcome:**   Over time, the ants discover the shortest path to the food source, and the pheromone trails converge to highlight this path. The visualization should clearly show this process."}]