<!doctype html>
<html>

<head>
    <title>Results</title>
    <link rel="stylesheet" href="/templates/style.css" />
    <link rel="icon" type="image/x-icon" href="/assets/favicon.ico" />
    <script src="/templates/constants.js"></script>
    <script src="/templates/utils.js"></script>
    <script>
        let socket;
        let connectionRetries = 0;
        let initialLoad = true; // Flag to track initial load
        let currentSearchQuery = "";

        // Storage for previous state
        let previousState = {
            Results: {},
            Models: [],
            TotalScores: {},
            PassPercentages: {}
        };

        /**
         * Connects to the WebSocket server and sets up event handlers
         */
        function connectWebSocket() {
            // Create WebSocket connection
            socket = new WebSocket("ws://" + window.location.host + "/ws");

            // Handle connection open
            socket.onopen = function (e) {
                console.log("[open] Connection established");
                connectionRetries = 0; // Reset retries on successful connection
                updateConnectionStatus("Connected", "connected");
            };

            // First load initial data
            fetchInitialData();

            // Handle incoming messages
            socket.onmessage = function (event) {
                try {
                    const payload = JSON.parse(event.data);
                    console.log('Received WebSocket update:', payload);
        
                    if (payload.type === 'results') {
                        // Create a safe data object with defaults
                        const safeData = {
                            Results: payload.data.results || {},
                            Models: payload.data.models || [],
                            PassPercentages: payload.data.passPercentages || {},
                            TotalScores: payload.data.totalScores || {}
                        };
            
                        // Update the hidden data elements with new values
                        updateHiddenData(safeData);

                        // Update the table with new data
                        updateResults(safeData);
                    }
                } catch (error) {
                    console.error('Error parsing WebSocket message:', error, event.data);
                }
            };

            // Handle connection close
            socket.onclose = function (event) {
                if (event.wasClean) {
                    console.log(`[close] Connection closed cleanly, code=${event.code} reason=${event.reason}`);
                } else {
                    console.log("[close] Connection died");
                }
                
                updateConnectionStatus("Disconnected", "disconnected");
                
                // Handle reconnection attempts
                if (connectionRetries < MAX_WS_RETRIES) {
                    connectionRetries++;
                    console.log(`Attempting to reconnect (${connectionRetries}/${MAX_WS_RETRIES})...`);
                    setTimeout(connectWebSocket, WS_RETRY_DELAY_MS * connectionRetries); // Exponential backoff
                } else {
                    updateConnectionStatus("Connection failed", "failed");
                    console.log("Max retries reached. Connection failed.");
                }
            };

            // Handle connection errors
            socket.onerror = function (error) {
                console.log(`[error] ${error.message}`);
                updateConnectionStatus("Error", "error");
            };
        }
        
        /**
         * Updates the connection status display
         * @param {string} text - Status text to display
         * @param {string} state - Status state (connected, disconnected, error, failed)
         */
        function updateConnectionStatus(text, state) {
            const statusElement = document.getElementById("connection-status");
            statusElement.textContent = text;
            statusElement.className = `connection-status connection-status-${state}`;
        }
        
        /**
         * Updates the hidden data elements with new values
         * @param {Object} data - Data object containing Results, Models, etc.
         */
        function updateHiddenData(data) {
            document.getElementById('results-data').textContent = JSON.stringify(data.Results || {});
            document.getElementById('models-data').textContent = JSON.stringify(data.Models || []);
            document.getElementById('pass-percentages-data').textContent = JSON.stringify(data.PassPercentages || {});
            document.getElementById('total-scores-data').textContent = JSON.stringify(data.TotalScores || {});
        }

        /**
         * Fetches initial data from the DOM hidden elements
         * @returns {Promise<Object>} Promise resolving to the data payload
         */
        function fetchInitialData() {
            console.log("Fetching initial data...");
            try {
                // Get DOM elements
                const elements = {
                    results: document.getElementById('results-data'),
                    models: document.getElementById('models-data'),
                    passPercentages: document.getElementById('pass-percentages-data'),
                    totalScores: document.getElementById('total-scores-data'),
                    profileGroups: document.getElementById('profile-groups-data'),
                    orderedPrompts: document.getElementById('ordered-prompts-data')
                };
                
                // Parse data with fallbacks using the utility function
                const payload = {
                    Results: safeJsonParse(elements.results?.textContent, {}),
                    Models: safeJsonParse(elements.models?.textContent, []),
                    PassPercentages: safeJsonParse(elements.passPercentages?.textContent, {}),
                    TotalScores: safeJsonParse(elements.totalScores?.textContent, {}),
                    ProfileGroups: safeJsonParse(elements.profileGroups?.textContent, []),
                    OrderedPrompts: safeJsonParse(elements.orderedPrompts?.textContent, [])
                };
                
                console.log('Data loaded from DOM elements:', { 
                    models_length: payload.Models.length,
                    firstModelData: payload.Models.length > 0 ? payload.Results[payload.Models[0]] : null,
                    profileGroups: payload.ProfileGroups
                });
                
                // Update the UI with the loaded data
                updateResults(payload);
                return Promise.resolve(payload);
            } catch (error) {
                console.error('Error parsing initial data:', error);
                // Return empty data rather than throwing
                const emptyPayload = {
                    Results: {},
                    Models: [],
                    PassPercentages: {},
                    TotalScores: {}
                };
                updateResults(emptyPayload);
                return Promise.resolve(emptyPayload);
            }
        }

        /**
         * Handles search input and filters results accordingly
         */
        function handleSearch() {
            currentSearchQuery = document.getElementById("modelSearch").value.toLowerCase();
            
            // Get current data from hidden elements
            const currentData = {
                Results: safeJsonParse(document.getElementById('results-data').textContent, {}),
                Models: safeJsonParse(document.getElementById('models-data').textContent, []),
                PassPercentages: safeJsonParse(document.getElementById('pass-percentages-data').textContent, {}),
                TotalScores: safeJsonParse(document.getElementById('total-scores-data').textContent, {})
            };
            
            // Update the results with the filtered data
            updateResults(currentData);
        }

        /**
         * Backs up the current state for potential restoration
         */
        function backupCurrentState() {
            previousState = {
                Results: safeJsonParse(document.getElementById('results-data').textContent, {}),
                Models: safeJsonParse(document.getElementById('models-data').textContent, []),
                TotalScores: safeJsonParse(document.getElementById('total-scores-data').textContent, {}),
                PassPercentages: safeJsonParse(document.getElementById('pass-percentages-data').textContent, {})
            };
            
            console.log('Current state backed up');
            
            // Enable the Previous button
            document.getElementById('restore-previous-btn').disabled = false;
        }

        /**
         * Restores the previous state
         */
        function restorePrevious() {
            if (!previousState.Models || previousState.Models.length === 0) {
                console.log('No previous state to restore');
                return;
            }
            
            console.log('Restoring previous state');
            
            // Update hidden elements with previous state data
            updateHiddenData(previousState);
            
            // Send the previous data to the server
            sendDataToServer(previousState)
                .then(data => {
                    console.log('Previous state restored successfully');
                    // Update the UI with previous data
                    updateResults(previousState);
                })
                .catch(error => {
                    console.error('Error restoring previous state:', error);
                    // Still update the UI even if the server request fails
                    updateResults(previousState);
                });
        }
        
        /**
         * Sends data to the server
         * @param {Object} data - Data to send to the server
         * @returns {Promise} Promise that resolves with the server response
         */
        function sendDataToServer(data) {
            return fetch('/update_mock_results', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify({
                    results: data.Results,
                    models: data.Models,
                    passPercentages: data.PassPercentages,
                    totalScores: data.TotalScores
                })
            })
            .then(response => response.json());
        }

        /**
         * Generates mock scores for all models
         */
        function generateMockScores() {
            console.log("Generating mock scores...");
            // Backup current state before generating new random scores
            backupCurrentState();
    
            // Retrieve the current models list from the hidden element
            const models = safeJsonParse(document.getElementById('models-data').textContent, []);
            if (models.length === 0) {
                console.error('Models data is empty');
                return;
            }
            
            // Get the number of prompts (using Go template injection)
            const promptsCount = {{len .Prompts}} || 0;
            
            // Prepare new data containers
            let newData = generateTieredScores(models, promptsCount);
            
            // Update hidden elements with the new data
            updateHiddenData(newData);
            
            // Send the mock data to the server
            sendDataToServer(newData)
                .then(data => {
                    console.log('Mock data saved successfully');
                    
                    // Use the server-generated data if available
                    if (data.results && data.models && data.totalScores && data.passPercentages) {
                        const serverData = {
                            Results: data.results,
                            Models: data.models,
                            TotalScores: data.totalScores,
                            PassPercentages: data.passPercentages
                        };
                        
                        // Update hidden elements with server data
                        updateHiddenData(serverData);
                        
                        // Update the UI with the server's data
                        updateResults(serverData);
                        console.log('UI updated with server-generated data');
                    } else {
                        // Fall back to local data if server didn't return the expected format
                        console.log('Server returned invalid data format, using local calculations');
                        updateResults(newData);
                    }
                })
                .catch(error => {
                    console.error('Error saving mock data:', error);
                    // Still update the UI even if the server request fails
                    updateResults(newData);
                });
        }
        
        /**
         * Generates tiered scores for models
         * @param {Array<string>} models - Array of model names
         * @param {number} promptsCount - Number of prompts
         * @returns {Object} Object containing results, models, scores and percentages
         */
        function generateTieredScores(models, promptsCount) {
            // Divide models into 11 tiers
            const groupSize = Math.ceil(models.length / 11);
            
            // Prepare data containers
            let newResults = {};
            let newTotalScores = {};
            let newPassPercentages = {};
            
            // Process each model by its tier
            models.forEach((model, index) => {
                const tierIndex = Math.min(10, Math.floor(index / groupSize));
                let scores = [];
                let total = 0;
                
                for (let i = 0; i < promptsCount; i++) {
                    let score = getRandomScoreForTier(tierIndex);
                    scores.push(score);
                    total += score;
                }
                
                newResults[model] = { Scores: scores };
                newTotalScores[model] = total;
                newPassPercentages[model] = (total / (promptsCount * 100)) * 100;
            });
            
            // Sort models in descending order based on their total scores
            models.sort((a, b) => newTotalScores[b] - newTotalScores[a]);
            
            return {
                Results: newResults,
                Models: models,
                TotalScores: newTotalScores,
                PassPercentages: newPassPercentages
            };
        }
        
        /**
         * Gets a random score based on tier weighting
         * @param {number} tierIndex - Index of the tier (0-10)
         * @returns {number} A score value (0, 20, 40, 60, 80, 100)
         */
        function getRandomScoreForTier(tierIndex) {
            // Define tier weights mapping
            const tierWeights = [
                [1, 1, 8, 15, 25, 50],    // cosmic (highest tier)
                [1, 2, 10, 20, 40, 27],   // divine
                [2, 5, 15, 30, 35, 13],   // celestial
                [5, 10, 25, 30, 20, 10],  // ascendant
                [7, 15, 33, 25, 15, 5],   // ethereal
                [10, 20, 35, 20, 10, 5],  // mystic
                [15, 30, 30, 15, 8, 2],   // astral
                [20, 35, 25, 15, 4, 1],   // spiritual
                [30, 35, 20, 12, 2, 1],   // primal
                [40, 35, 15, 8, 2, 0],    // mortal
                [55, 30, 10, 5, 0, 0],    // primordial (lowest tier)
                [17, 16, 16, 16, 16, 16]  // fallback to even distribution
            ];
            
            let weights = tierWeights[tierIndex] || tierWeights[11];
            
            // Apply some randomness to the weights
            const jitterFactor = 0.2; // 20% random variation
            weights = weights.map(w => {
                const jitter = 1 + (Math.random() * jitterFactor * 2 - jitterFactor);
                return Math.max(0, Math.round(w * jitter));
            });
            
            // Use weighted random selection
            const totalWeight = weights.reduce((a, b) => a + b, 0);
            let random = Math.random() * totalWeight;
            
            for (let i = 0; i < weights.length; i++) {
                random -= weights[i];
                if (random <= 0) {
                    return SCORE_VALUES[i];
                }
            }
            
            return 0; // Fallback
        }

        /**
         * Updates the results table with the provided data
         * @param {Object} payload - Data payload containing Results, Models, etc.
         */
        function updateResults(payload) {
            // Apply defensive programming to handle potential undefined values
            const results = payload.Results || {};
            const models = payload.Models || [];
            const passPercentages = payload.PassPercentages || {};
            const totalScores = payload.TotalScores || {};
            const profileGroups = payload.ProfileGroups || [];
            const orderedPrompts = payload.OrderedPrompts || [];
            const modelFilter = document.getElementById("model_filter").value;

            // Initialize profile headers if needed
            initializeProfileHeaders(profileGroups);
            
            // Get the table body
            const tbody = getTableBody();
            if (!tbody) {
                console.error('Could not find or create table body');
                return;
            }
            
            // Ensure we have models to display
            const displayModels = ensureModelsExist(models, results);
            
            if (displayModels.length === 0) {
                console.error('No models available to display');
                tbody.innerHTML = '<tr><td colspan="100" class="no-models-message">No models available</td></tr>';
                return;
            }
            
            // Render the models
            renderModelRows(tbody, displayModels, results, totalScores, passPercentages, modelFilter);
            
            // Apply styling to data cells after they've been created
            setTimeout(applyDataCellStyling, 50);
        }
        
        /**
         * Initializes profile headers if they don't exist
         * @param {Array} profileGroups - Array of profile group data
         */
        function initializeProfileHeaders(profileGroups) {
            if (document.querySelector('.profile-row') === null && profileGroups.length > 0) {
                createProfileHeaderRow(profileGroups);
            }
            
            // Apply styling to header columns
            applyHeaderStyling(profileGroups);
        }
        
        /**
         * Gets or creates the table body element
         * @returns {HTMLElement|null} The table body element or null if it couldn't be created
         */
        function getTableBody() {
            // Try different selectors
            let tbody = document.querySelector("table.results-table tbody") || 
                         document.querySelector("table tbody");
            
            if (!tbody) {
                console.log('Table body not found, creating one');
                const table = document.querySelector("table.results-table") || document.querySelector("table");
                if (table) {
                    const newTbody = document.createElement("tbody");
                    table.appendChild(newTbody);
                    tbody = newTbody;
                }
            }
            
            return tbody;
        }
        
        /**
         * Ensures we have models to display, rebuilding from results if needed
         * @param {Array} models - Array of model names
         * @param {Object} results - Results object
         * @returns {Array} Array of model names
         */
        function ensureModelsExist(models, results) {
            if (models.length === 0 && Object.keys(results).length > 0) {
                console.log('Models array is empty, rebuilding from results keys');
                return Object.keys(results);
            }
            return models;
        }
        
        /**
         * Renders model rows in the table body
         * @param {HTMLElement} tbody - Table body element
         * @param {Array} models - Array of model names
         * @param {Object} results - Results object
         * @param {Object} totalScores - Total scores by model
         * @param {Object} passPercentages - Pass percentages by model
         * @param {string} modelFilter - Model filter string
         */
        function renderModelRows(tbody, models, results, totalScores, passPercentages, modelFilter) {
            console.log(`Rendering ${models.length} models to table`);
            
            // Clear the table first
            tbody.innerHTML = '';
            
            // Create document fragment for batch DOM updates
            const fragment = document.createDocumentFragment();
            let rowCount = 0;
            
            models.forEach((model) => {
                // Apply both filters
                if ((modelFilter === "" || model === modelFilter) &&
                    (currentSearchQuery === "" || model.toLowerCase().includes(currentSearchQuery))) {
                    rowCount++;
                    
                    // Create and append the row
                    const row = createModelRow(
                        model, 
                        rowCount, 
                        results[model], 
                        totalScores[model] || 0,
                        passPercentages[model] || 0
                    );
                    
                    fragment.appendChild(row);
                }
            });
            
            // Batch update the DOM
            tbody.appendChild(fragment);
            
            console.log(`Table updated with ${rowCount} rows`);
            
            // Force a redraw if needed
            if (rowCount > 0 && tbody.children.length === 0) {
                console.error("Rows not appearing in table despite being created. Forcing redraw...");
                const temp = tbody.innerHTML;
                tbody.innerHTML = '';
                setTimeout(() => {
                    tbody.innerHTML = temp;
                }, 10);
            }
        }
        
        /**
         * Creates a row for a model
         * @param {string} model - Model name
         * @param {number} rank - Rank number
         * @param {Object} modelData - Model data object
         * @param {number} totalScore - Total score
         * @param {number} passPercentage - Pass percentage
         * @returns {HTMLElement} The created row element
         */
        function createModelRow(model, rank, modelData, totalScore, passPercentage) {
            const row = document.createElement("tr");
            const promptsCount = {{len .Prompts}} || 0;
            
            // Create standard cells
            const rankCell = document.createElement("td");
            rankCell.textContent = rank;
            
            const actionsCell = document.createElement("td");
            actionsCell.className = "model-actions";
            actionsCell.innerHTML = `
                <div class="prompt-actions">
                    <a class="action-button edit-button" href="/edit_model?model=${model}">✏️</a>
                    <a class="action-button delete-button" href="/delete_model?model=${model}">🗑️</a>
                </div>
            `;
            
            const modelCell = document.createElement("td");
            modelCell.textContent = model;
            
            // Create score cells
            const scores = modelData?.Scores || modelData?.scores || [];
            while (scores.length < promptsCount) {
                scores.push(0);
            }
            
            const scoreCells = createScoreCells(model, scores, promptsCount);
            
            // Create total score cell with progress bar
            const totalCell = createTotalScoreCell(totalScore, passPercentage);
            
            // Append all cells to row
            row.appendChild(rankCell);
            row.appendChild(actionsCell);
            row.appendChild(modelCell);
            scoreCells.forEach(cell => row.appendChild(cell));
            row.appendChild(totalCell);
            
            return row;
        }
        
        /**
         * Creates score cells for a model
         * @param {string} model - Model name
         * @param {Array} scores - Array of scores
         * @param {number} promptsCount - Total number of prompts
         * @returns {Array} Array of score cell elements
         */
        function createScoreCells(model, scores, promptsCount) {
            const cells = [];
            
            for (let index = 0; index < promptsCount; index++) {
                const score = scores[index] || 0;
                const scoreCell = document.createElement("td");
                
                // Set cell class based on score
                const scoreClass = getScoreClass(score);
                scoreCell.className = `score-cell ${scoreClass}`;
                
                // Set data attributes for styling and interactivity
                scoreCell.setAttribute('data-prompt-index', index.toString());
                scoreCell.setAttribute('data-score', `Score: ${score}`);
                scoreCell.setAttribute('tabindex', '0'); // Make cell focusable
                
                // Attach event listeners
                scoreCell.addEventListener('click', () => {
                    window.location.href = `/evaluate?model=${model}&prompt=${index}`;
                });
                
                // Add keyboard navigation
                scoreCell.addEventListener('keydown', (e) => {
                    if (e.key === 'Enter' || e.key === ' ') {
                        window.location.href = `/evaluate?model=${model}&prompt=${index}`;
                    }
                });
                
                cells.push(scoreCell);
            }
            
            return cells;
        }
        
        /**
         * Creates a total score cell with progress bar
         * @param {number} totalScore - Total score
         * @param {number} passPercentage - Pass percentage
         * @returns {HTMLElement} The total score cell element
         */
        function createTotalScoreCell(totalScore, passPercentage) {
            const totalCell = document.createElement("td");
            totalCell.textContent = totalScore;
            totalCell.className = "progress-bar-wrapper";
            
            const progressDiv = document.createElement("div");
            progressDiv.className = "progress-bar-container progress-bar-standard-width";
            
            const progressBar = document.createElement("div");
            progressBar.className = "progress-bar";
            progressBar.style.setProperty('--progress-width', `${passPercentage}%`);
            
            progressDiv.appendChild(progressBar);
            totalCell.appendChild(progressDiv);
            
            return totalCell;
        }
          
      // Helper function to log the colors being used for debugging
      function logScoreColors() {
          const rootStyles = getComputedStyle(document.documentElement);
          console.log("Score colors used in chart:");
          [0, 20, 40, 60, 80, 100].forEach(score => {
              const varName = `--score-color-${score}`;
              console.log(`${score}: ${rootStyles.getPropertyValue(varName).trim() || 'Not set'}`);
          });
      }



        document.addEventListener('DOMContentLoaded', () => {
            // Skip the initial data loading attempt which is failing
            // and rely solely on the connectWebSocket function which will
            // call fetchInitialData() inside it
            console.log("DOM loaded, connecting to WebSocket...");
            connectWebSocket(); // Actually call the function
        });
        /**
         * Creates the profile header row
         * @param {Array} profileGroups - Array of profile group data
         */
        function createProfileHeaderRow(profileGroups) {
            const thead = document.querySelector('.results-table thead');
            if (!thead) return;
            
            const profileRow = document.createElement('tr');
            profileRow.className = 'profile-row';
            
            // Add empty cells for non-prompt columns
            const emptyHeader = document.createElement('th');
            emptyHeader.setAttribute('colspan', '3');
            profileRow.appendChild(emptyHeader);
            
            // Add profile group headers
            profileGroups.forEach((group, index) => {
                // Only include groups with prompts
                if (group.StartCol !== -1) {
                    const span = group.EndCol - group.StartCol + 1;
                    const header = createProfileHeader(group, index, profileRow);
                    header.setAttribute('colspan', span);
                    profileRow.appendChild(header);
                }
            });
            
            // Add total header with rowspan
            const totalHeader = document.createElement('th');
            totalHeader.setAttribute('rowspan', '2');
            totalHeader.textContent = 'Total';
            profileRow.appendChild(totalHeader);
            
            // Insert at the beginning of thead
            thead.insertBefore(profileRow, thead.firstChild);
        }
        
        /**
         * Creates a profile header element
         * @param {Object} group - Profile group data
         * @param {number} index - Index of the group
         * @param {HTMLElement} parentRow - Parent row element
         * @returns {HTMLElement} The created header element
         */
        function createProfileHeader(group, index, parentRow) {
            const header = document.createElement('th');
            header.className = 'profile-header profile-header-cell';
            header.setAttribute('data-profile-id', group.ID);
            
            // Create inner text element
            const textDiv = document.createElement('div');
            textDiv.className = 'profile-header-text';
            textDiv.textContent = group.Name;
            header.appendChild(textDiv);
            
            // Apply profile-specific styling
            header.classList.add('profile-header-styled');
            header.style.setProperty('--profile-color', '#333');
            
            // Add divider classes between profile groups
            if (index > 0) {
                header.classList.add('profile-divider-left');
            }
            
            // Add divider to the previous header if this isn't the first
            if (index > 0 && parentRow.lastChild && parentRow.lastChild.classList) {
                parentRow.lastChild.classList.add('profile-divider-right');
            }
            
            return header;
        }

        /**
         * Applies styling to header cells for profile groups
         * @param {Array} profileGroups - Array of profile group data
         */
        function applyHeaderStyling(profileGroups) {
            // Create a mapping from column index to profile boundary information
            const columnMap = {};
            
            // Store column map in global variable so it can be used later
            window.profileColumnMap = {};
            
            // Process groups to identify start and end columns
            profileGroups.forEach(group => {
                const startCol = group.startCol !== undefined ? group.startCol : (group.StartCol !== undefined ? group.StartCol : -1);
                const endCol = group.endCol !== undefined ? group.endCol : (group.EndCol !== undefined ? group.EndCol : -1);
                const color = '#333'; // Always use standard color
                
                if (startCol !== -1) {
                    // Store boundary information
                    columnMap[startCol] = { isStart: true, isEnd: false, color: color };
                    columnMap[endCol] = { isStart: false, isEnd: true, color: color };
                    
                    // Store in global map
                    window.profileColumnMap[startCol] = { isStart: true, color: color };
                    window.profileColumnMap[endCol] = { isEnd: true, color: color };
                }
            });
            
            // Apply to header columns
            const headerCells = document.querySelectorAll('.prompt-col');
            
            headerCells.forEach(cell => {
                const promptIndex = parseInt(cell.getAttribute('data-prompt-index'));
                const boundary = columnMap[promptIndex];
                
                if (boundary) {
                    // Clear existing classes
                    cell.classList.remove('profile-start', 'profile-end', 'profile-group-start', 'profile-group-end');
                    
                    if (boundary.isStart) {
                        cell.classList.add('profile-group-start');
                        cell.style.borderLeft = `var(--profile-border-width) solid ${boundary.color}`;
                    }
                    
                    if (boundary.isEnd) {
                        cell.classList.add('profile-group-end');
                        cell.style.borderRight = `var(--profile-border-width) solid ${boundary.color}`;
                    }
                }
            });
        }

        /**
         * Applies styling to data cells for profile groups
         */
        function applyDataCellStyling() {
            if (!window.profileColumnMap) {
                console.error("Profile column map not initialized");
                return;
            }
            
            const columnMap = window.profileColumnMap;
            
            // Get the table
            const table = document.querySelector('.results-table');
            if (!table) {
                console.error("Table not found");
                return;
            }
            
            // Get all table rows
            const tableRows = table.querySelectorAll('tbody tr');
            
            // Process each row
            tableRows.forEach(row => {
                const cells = Array.from(row.querySelectorAll('td'));
                if (cells.length <= 3) return; // Skip rows with insufficient cells
                
                // Process each content cell (skip first 3 cells: rank, actions, model)
                for (let i = 3; i < cells.length - 1; i++) { // Exclude the last total column
                    const columnIndex = i - 3; // Adjust index to match prompt indices
                    const boundary = columnMap[columnIndex];
                    
                    if (boundary) {
                        // Remove existing classes
                        cells[i].classList.remove('profile-start', 'profile-end', 'profile-group-start', 'profile-group-end');
                        
                        if (boundary.isStart) {
                            cells[i].classList.add('profile-group-start');
                            // Apply border using CSS variables
                            cells[i].style.setProperty('--profile-color', '#333');
                            cells[i].style.borderLeft = 
                                `var(--profile-border-width) var(--profile-border-style) var(--profile-color)`;
                        }
                        
                        if (boundary.isEnd) {
                            cells[i].classList.add('profile-group-end');
                            // Apply border using CSS variables
                            cells[i].style.setProperty('--profile-color', '#333');
                            cells[i].style.borderRight = 
                                `var(--profile-border-width) var(--profile-border-style) var(--profile-color)`;
                        }
                    }
                }
            });
        }
    </script>
</head>

<body>
    {{template "nav" .}}
    <div class="sticky-header">
        <h2>Add Model</h2>
        <form action="/add_model" method="post" class="flex-form">
            <input type="text" name="model" placeholder="Enter new model name" class="margin-right-5" />
            <input type="submit" value="Add" />
        </form>
        <span id="connection-status" class="connection-status"></span>
    </div>
    <div class="title-row">
        <div class="filter-container">
            <form action="/results" method="get" id="filter-form" class="filter-form">
                <select name="model_filter" id="model_filter" aria-label="Filter by model">
                    <option value="">All Models</option>
                    {{range $model := .Models}}
                    <option value="{{$model}}" {{if and ($.ModelFilter) (eq $.ModelFilter $model)}}selected{{end}}>
                        {{$model}}
                    </option>
                    {{end}}
                </select>
                <input type="submit" value="Filter" class="filter-submit" />
            </form>
        </div>
        <div class="title-container">
            <button class="action-button" id="generate-mock-btn" onclick="generateMockScores()">Generate Random Mock Scores</button>
            <button class="action-button" id="restore-previous-btn" onclick="restorePrevious()" disabled>Previous</button>
        </div>
        <div class="search-container">
            <form id="search-form" class="search-form" onsubmit="handleSearch(); return false;">
                <input type="text" id="modelSearch" placeholder="Search models..." class="search-input"
                    aria-label="Search models" />
                <button type="submit" class="search-submit">Search</button>
            </form>
        </div>
    </div>
    <table class="results-table">
        <thead>
            <!-- Profile grouping row -->
            <tr class="profile-row">
                <th colspan="3"></th> <!-- For rank, actions, model columns -->
                {{$first := true}}
                {{range $index, $group := .ProfileGroups}}
                    {{if ne .StartCol -1}} <!-- Only include groups that have prompts -->
                    <th colspan="{{add (sub .EndCol .StartCol) 1}}" 
                        class="profile-header profile-header-cell profile-header-styled {{if not $first}}profile-divider-left{{end}}" 
                        data-profile-id="{{.ID}}"
                        style="--profile-color: #333;">
                        <div class="profile-header-text">{{.Name}}</div>
                    </th>
                    {{$first = false}}
                    {{end}}
                {{end}}
                <th rowspan="2">Total</th>
            </tr>
            
            <!-- Regular header row with numbers -->
            <tr>
                <th>#</th>
                <th>Actions</th>
                <th>Model</th>
                {{range $prompt := .OrderedPrompts}}
                    <th class="prompt-col" 
                        data-profile-id="{{$prompt.ProfileID}}"
                        data-prompt-index="{{$prompt.Index}}">
                        {{inc $prompt.Index}}
                    </th>
                {{end}}
            </tr>
        </thead>
        <tbody>
            <!-- Table content will be populated by JavaScript -->
        </tbody>
    </table>
    <div class="sticky-footer">
        <div class="results-management">
            <h2>Manage Results</h2>
            &nbsp;&nbsp;&nbsp;
            <form action="/reset_results" method="get" class="margin-right-5">
                <input type="submit" value="Reset Results" />
            </form>
            <form action="/confirm_refresh_results" method="get" class="margin-right-5">
                <input type="submit" value="Refresh Results" />
            </form>
            <form action="/export_results" method="post" class="margin-right-5">
                <input type="submit" value="Export Results" />
            </form>
            <form action="/import_results" method="post" enctype="multipart/form-data"
                class="file-import-form">
                <input type="file" name="results_file" class="margin-right-5" />
                <input type="submit" value="Import Results" />
            </form>
        </div>
    </div>
    <div class="scroll-buttons">
        <button class="scroll-button" onclick="scrollToTop()">↑</button>
        <button class="scroll-button" onclick="scrollToBottom()">↓</button>
    </div>
    <script>
        function scrollToTop() {
            window.scrollTo({top: 0, behavior: "smooth"});
        }

        function scrollToBottom() {
            window.scrollTo({
                top: document.body.scrollHeight,
                behavior: "smooth",
            });
        }
        
        // Add keyboard navigation for the table
        document.addEventListener('keydown', function(e) {
            if (document.activeElement && document.activeElement.classList.contains('score-cell')) {
                const currentCell = document.activeElement;
                const currentRow = currentCell.parentElement;
                const currentIndex = Array.from(currentRow.children).indexOf(currentCell);
                
                let nextCell;
                
                switch(e.key) {
                    case 'ArrowRight':
                        nextCell = currentRow.children[currentIndex + 1];
                        break;
                    case 'ArrowLeft':
                        nextCell = currentRow.children[currentIndex - 1];
                        break;
                    case 'ArrowUp':
                        const prevRow = currentRow.previousElementSibling;
                        if (prevRow) nextCell = prevRow.children[currentIndex];
                        break;
                    case 'ArrowDown':
                        const nextRow = currentRow.nextElementSibling;
                        if (nextRow) nextCell = nextRow.children[currentIndex];
                        break;
                }
                
                if (nextCell && nextCell.classList.contains('score-cell')) {
                    e.preventDefault();
                    nextCell.focus();
                }
            }
        });
    </script>
    <div id="hidden-data" class="hidden-data">
        <span id="results-data">{{.Results | json}}</span>
        <span id="models-data">{{.Models | json}}</span>
        <span id="pass-percentages-data">{{.PassPercentages | json}}</span>
        <span id="total-scores-data">{{.TotalScores | json}}</span>
        <span id="profile-groups-data">{{.ProfileGroups | json}}</span>
        <span id="ordered-prompts-data">{{.OrderedPrompts | json}}</span>
        <span id="debug-data" class="debug-data">
            Results: {{.Results | json}}<br />
            Models: {{.Models | json}}<br />
            PassPercentages: {{.PassPercentages | json}}<br />
            TotalScores: {{.TotalScores | json}}<br />
            ProfileGroups: {{.ProfileGroups | json}}<br />
            OrderedPrompts: {{.OrderedPrompts | json}}
        </span>
    </div>
    <!-- Fallback data for debugging -->
    <script>
        // This ensures we have at least some data even if the template rendering fails
        window.fallbackData = {
            Results: {},
            Models: [],
            PassPercentages: {},
            TotalScores: {}
        };
    </script>
</body>

</html>
