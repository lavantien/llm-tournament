<!doctype html>
<html>

<head>
    <title>Results</title>
    <link rel="stylesheet" href="/templates/style.css" />
    <link rel="icon" type="image/x-icon" href="/assets/favicon.ico" />
    <script>
        let socket;
        let connectionRetries = 0;
        const maxRetries = 3;
        let initialLoad = true; // Flag to track initial load

        // Add storage for previous state
        let previousState = {
            Results: {},
            Models: [],
            TotalScores: {},
            PassPercentages: {}
        };

        function connectWebSocket() {
            // Then connect WebSocket
            socket = new WebSocket("ws://" + window.location.host + "/ws");

            socket.onopen = function (e) {
                console.log("[open] Connection established");
                connectionRetries = 0; // Reset retries on successful connection
                document.getElementById("connection-status").textContent =
                    "Connected";
                document.getElementById("connection-status").className = "connection-status connection-status-connected";
            };

            // First load initial data
            fetchInitialData();

            socket.onmessage = function (event) {
                try {
                    const payload = JSON.parse(event.data);
                    console.log('Received WebSocket update:', payload);
        
                    if (payload.type === 'results') {
                        // Create a safe data object with defaults
                        const safeData = {
                            Results: payload.data.results || {},
                            Models: payload.data.models || [],
                            PassPercentages: payload.data.passPercentages || {},
                            TotalScores: payload.data.totalScores || {}
                        };
            
                        console.log('Processed WebSocket data:', safeData);

                        // Update the hidden data elements with new values
                        document.getElementById('results-data').textContent = JSON.stringify(safeData.Results);
                        document.getElementById('models-data').textContent = JSON.stringify(safeData.Models);
                        document.getElementById('pass-percentages-data').textContent = JSON.stringify(safeData.PassPercentages);
                        document.getElementById('total-scores-data').textContent = JSON.stringify(safeData.TotalScores);

                        // Update the table with new data
                        updateResults(safeData);
                    }
                } catch (error) {
                    console.error('Error parsing WebSocket message:', error, event.data);
                }
            };

            socket.onclose = function (event) {
                if (event.wasClean) {
                    console.log(
                        `[close] Connection closed cleanly, code=${event.code} reason=${event.reason}`,
                    );
                } else {
                    console.log("[close] Connection died");
                }
                document.getElementById("connection-status").textContent =
                    "Disconnected";
                document.getElementById("connection-status").className = "connection-status connection-status-disconnected";
                if (connectionRetries < maxRetries) {
                    connectionRetries++;
                    console.log(
                        `Attempting to reconnect (${connectionRetries}/${maxRetries})...`,
                    );
                    setTimeout(connectWebSocket, 1000 * connectionRetries); // Exponential backoff
                } else {
                    document.getElementById("connection-status").textContent =
                        "Connection failed";
                    document.getElementById("connection-status").className = "connection-status connection-status-failed";
                    console.log("Max retries reached. Connection failed.");
                }
            };

            socket.onerror = function (error) {
                console.log(`[error] ${error.message}`);
                document.getElementById("connection-status").textContent = "Error";
                document.getElementById("connection-status").className = "connection-status connection-status-error";
            };
        }

        function fetchInitialData() {
            console.log("Fetching initial data...");
            // Instead of using AJAX, use the data already present in the DOM
            try {
                const resultsEl = document.getElementById('results-data');
                const modelsEl = document.getElementById('models-data');
                const passPercentagesEl = document.getElementById('pass-percentages-data');
                const totalScoresEl = document.getElementById('total-scores-data');
                const profileGroupsEl = document.getElementById('profile-groups-data');
                const orderedPromptsEl = document.getElementById('ordered-prompts-data');
                
                // Safely parse JSON with fallbacks
                const results = resultsEl && resultsEl.textContent ? 
                    JSON.parse(resultsEl.textContent) : {};
                const models = modelsEl && modelsEl.textContent ? 
                    JSON.parse(modelsEl.textContent) : [];
                const passPercentages = passPercentagesEl && passPercentagesEl.textContent ? 
                    JSON.parse(passPercentagesEl.textContent) : {};
                const totalScores = totalScoresEl && totalScoresEl.textContent ? 
                    JSON.parse(totalScoresEl.textContent) : {};
                const profileGroups = profileGroupsEl && profileGroupsEl.textContent ? 
                    JSON.parse(profileGroupsEl.textContent) : [];
                const orderedPrompts = orderedPromptsEl && orderedPromptsEl.textContent ? 
                    JSON.parse(orderedPromptsEl.textContent) : [];
                
                console.log('Data loaded from DOM elements:', { 
                    results, 
                    models_length: models ? models.length : 0,
                    firstModelData: models && models.length > 0 ? results[models[0]] : null,
                    profileGroups: profileGroups
                });
                
                const payload = {
                    Results: results,
                    Models: models,
                    PassPercentages: passPercentages,
                    TotalScores: totalScores,
                    ProfileGroups: profileGroups,
                    OrderedPrompts: orderedPrompts
                };
                
                updateResults(payload);
                return Promise.resolve(payload);
            } catch (error) {
                console.error('Error parsing initial data:', error);
                // Return empty data rather than throwing
                const emptyPayload = {
                    Results: {},
                    Models: [],
                    PassPercentages: {},
                    TotalScores: {}
                };
                updateResults(emptyPayload);
                return Promise.resolve(emptyPayload);
            }
        }

        let currentSearchQuery = "";

        function handleSearch() {
            currentSearchQuery = document.getElementById("modelSearch").value.toLowerCase();
            updateResults({
                Results: JSON.parse(document.getElementById('results-data').textContent),
                Models: JSON.parse(document.getElementById('models-data').textContent),
                PassPercentages: JSON.parse(document.getElementById('pass-percentages-data').textContent),
                TotalScores: JSON.parse(document.getElementById('total-scores-data').textContent),
            });
        }

        function backupCurrentState() {
            previousState = {
                Results: JSON.parse(document.getElementById('results-data').textContent || '{}'),
                Models: JSON.parse(document.getElementById('models-data').textContent || '[]'),
                TotalScores: JSON.parse(document.getElementById('total-scores-data').textContent || '{}'),
                PassPercentages: JSON.parse(document.getElementById('pass-percentages-data').textContent || '{}')
            };
            console.log('Current state backed up:', previousState);
            // Enable the Previous button
            document.getElementById('restore-previous-btn').disabled = false;
        }

        function restorePrevious() {
            if (!previousState.Models || previousState.Models.length === 0) {
                console.log('No previous state to restore');
                return;
            }
            
            console.log('Restoring previous state:', previousState);
            
            // Update hidden elements with previous state data
            document.getElementById('results-data').textContent = JSON.stringify(previousState.Results);
            document.getElementById('models-data').textContent = JSON.stringify(previousState.Models);
            document.getElementById('total-scores-data').textContent = JSON.stringify(previousState.TotalScores);
            document.getElementById('pass-percentages-data').textContent = JSON.stringify(previousState.PassPercentages);
            
            // Send the previous data to the server
            fetch('/update_mock_results', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify({
                    results: previousState.Results,
                    models: previousState.Models,
                    passPercentages: previousState.PassPercentages,
                    totalScores: previousState.TotalScores
                })
            })
            .then(response => response.json())
            .then(data => {
                console.log('Previous state restored successfully:', data);
                // Update the UI with previous data
                updateResults(previousState);
            })
            .catch(error => {
                console.error('Error restoring previous state:', error);
                // Still update the UI even if the server request fails
                updateResults(previousState);
            });
        }

        function generateMockScores() {
            console.log("Generating mock scores...");
            // Backup current state before generating new random scores
            backupCurrentState();
    
            // Retrieve the current models list from the hidden element
            const modelsText = document.getElementById('models-data').textContent;
            if (!modelsText || modelsText.trim() === '') {
                console.error('Models data is empty');
                return;
            }
            const models = JSON.parse(modelsText);
            // Get the number of prompts (using Go template injection)
            const promptsCount = {{len .Prompts}} || 0;
            // Prepare new data containers
            let newResults = {};
            let newTotalScores = {};
            let newPassPercentages = {};
    
            // Divide models into 11 tiers
            const groupSize = Math.ceil(models.length / 11);
            
            // Function to get weighted scores based on tier
            function getRandomScoreForTier(tierIndex) {
              const validScores = [0, 20, 40, 60, 80, 100];
              let weights;
              
              // Different weights for each tier
              // Higher tiers have higher probability of high scores
              switch(tierIndex) {
                case 0: // cosmic (highest tier)
                  weights = [1, 1, 8, 15, 25, 50]; // heavily weighted toward 100s
                  break;
                case 1: // divine
                  weights = [1, 2, 10, 20, 40, 27];
                  break;
                case 2: // celestial
                  weights = [2, 5, 15, 30, 35, 13];
                  break;
                case 3: // ascendant
                  weights = [5, 10, 25, 30, 20, 10];
                  break;
                case 4: // ethereal
                  weights = [7, 15, 33, 25, 15, 5];
                  break;
                case 5: // mystic
                  weights = [10, 20, 35, 20, 10, 5];
                  break;
                case 6: // astral
                  weights = [15, 30, 30, 15, 8, 2];
                  break;
                case 7: // spiritual
                  weights = [20, 35, 25, 15, 4, 1];
                  break;
                case 8: // primal
                  weights = [30, 35, 20, 12, 2, 1];
                  break;
                case 9: // mortal
                  weights = [40, 35, 15, 8, 2, 0];
                  break;
                case 10: // primordial (lowest tier)
                  weights = [55, 30, 10, 5, 0, 0];
                  break;
                default:
                  weights = [17, 16, 16, 16, 16, 16]; // fallback to even distribution
              }
              
              // Apply some randomness to the weights
              const jitterFactor = 0.2; // 20% random variation
              weights = weights.map(w => {
                const jitter = 1 + (Math.random() * jitterFactor * 2 - jitterFactor);
                return Math.max(0, Math.round(w * jitter));
              });
              
              // Use weighted random selection
              const totalWeight = weights.reduce((a, b) => a + b, 0);
              let random = Math.random() * totalWeight;
      
              for (let i = 0; i < weights.length; i++) {
                random -= weights[i];
                if (random <= 0) {
                  return validScores[i];
                }
              }
              return 0; // Fallback
            }
            
            // Process each model by its tier
            models.forEach((model, index) => {
              const tierIndex = Math.min(10, Math.floor(index / groupSize));
              let scores = [];
              let total = 0;
              
              for (let i = 0; i < promptsCount; i++) {
                let score = getRandomScoreForTier(tierIndex);
                scores.push(score);
                total += score;
              }
              
              newResults[model] = { Scores: scores };
              newTotalScores[model] = total;
              newPassPercentages[model] = (total / (promptsCount * 100)) * 100;
            });
            
            // Sort models in descending order based on their total scores
            models.sort((a, b) => newTotalScores[b] - newTotalScores[a]);
            // Update hidden models-data with the new sorted order
            // Store updated data in hidden elements
            document.getElementById('models-data').textContent = JSON.stringify(models);
            document.getElementById('results-data').textContent = JSON.stringify(newResults);
            document.getElementById('total-scores-data').textContent = JSON.stringify(newTotalScores);
            document.getElementById('pass-percentages-data').textContent = JSON.stringify(newPassPercentages);
            
            // Send the mock data to the server
            fetch('/update_mock_results', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify({
                    results: newResults,
                    models: models,
                    passPercentages: newPassPercentages,
                    totalScores: newTotalScores
                })
            })
            .then(response => response.json())
            .then(data => {
                console.log('Mock data saved successfully:', data);
                
                // Use the server-generated data instead of our local calculations
                if (data.results && data.models && data.totalScores && data.passPercentages) {
                    console.log('Received sorted models from server:', data.models.slice(0, 5));
                    
                    // Update the hidden data elements with the server's generated data
                    document.getElementById('results-data').textContent = JSON.stringify(data.results);
                    document.getElementById('models-data').textContent = JSON.stringify(data.models);
                    document.getElementById('total-scores-data').textContent = JSON.stringify(data.totalScores);
                    document.getElementById('pass-percentages-data').textContent = JSON.stringify(data.passPercentages);
                    
                    // Update the UI with the server's data
                    updateResults({
                        Results: data.results,
                        Models: data.models, // These are already sorted by the server
                        TotalScores: data.totalScores,
                        PassPercentages: data.passPercentages
                    });
                    console.log('UI updated with server-generated data');
                } else {
                    // Fall back to local data if server didn't return the expected format
                    console.log('Server returned invalid data format, using local calculations');
                    
                    // Sort the models by total score
                    models.sort((a, b) => newTotalScores[b] - newTotalScores[a]);
                    
                    // Update hidden elements with sorted data
                    document.getElementById('models-data').textContent = JSON.stringify(models);
                    
                    updateResults({
                        Results: newResults,
                        Models: models, // Locally sorted as fallback
                        TotalScores: newTotalScores,
                        PassPercentages: newPassPercentages
                    });
                    console.log('UI updated with local mock data (fallback)');
                }
            })
            .catch(error => {
                console.error('Error saving mock data:', error);
                // Still update the UI even if the server request fails
                updateResults({
                    Results: newResults,
                    Models: models,
                    TotalScores: newTotalScores,
                    PassPercentages: newPassPercentages
                });
                console.log('UI updated with local data despite server error');
            });
        }

        function updateResults(payload) {
            // Apply defensive programming to handle potential undefined values
            const results = payload.Results || {};
            const models = payload.Models || [];
            const passPercentages = payload.PassPercentages || {};
            const totalScores = payload.TotalScores || {};
            const profileGroups = payload.ProfileGroups || [];
            const orderedPrompts = payload.OrderedPrompts || [];
            const modelFilter = document.getElementById("model_filter").value;

            console.log('Updating UI with models:', models, 'First model results:', models.length > 0 ? results[models[0]] : null);
            
            // Create header with profile spans if not already present
            if (document.querySelector('.profile-row') === null && profileGroups.length > 0) {
                createProfileHeaderRow(profileGroups);
            }
            
            // Apply profile-specific styling to columns
            applyProfileStyling(profileGroups, orderedPrompts);
            
            // Try different ways to get the tbody element
            let tbody = document.querySelector("table.results-table tbody");
            
            if (!tbody) {
                console.error('Table body not found with class selector, trying direct selector');
                tbody = document.querySelector("table tbody");
            }
            
            if (!tbody) {
                console.error('Table body still not found, creating one');
                // Create the table if it doesn't exist
                const table = document.querySelector("table.results-table") || document.querySelector("table");
                if (table) {
                    const newTbody = document.createElement("tbody");
                    table.appendChild(newTbody);
                    console.log('Created new tbody element');
                    tbody = newTbody;
                } else {
                    console.error('Could not find or create table body');
                    return;
                }
            }
            
            // Log that we found the table body
            console.log('Found table body:', tbody);
            
            // If models array is empty, try to rebuild it from results object
            if (models.length === 0 && Object.keys(results).length > 0) {
                console.log('Models array is empty, rebuilding from results keys');
                Object.keys(results).forEach(model => {
                    if (!models.includes(model)) {
                        models.push(model);
                    }
                });
            }
            
            if (models.length === 0) {
                console.error('No models available to display');
                tbody.innerHTML = '<tr><td colspan="100" class="no-models-message">No models available</td></tr>';
                return;
            }
            
            console.log(`About to render ${models.length} models to table`);

            // Clear the table first
            tbody.innerHTML = '';
            
            // Create document fragment for batch DOM updates
            const fragment = document.createDocumentFragment();
            let i = 0;
            
            console.log('Rendering table with models:', models);

            models.forEach((model) => {
                // Apply both filters
                if ((modelFilter === "" || model === modelFilter) &&
                    (currentSearchQuery === "" || model.toLowerCase().includes(currentSearchQuery))) {
                    i++;
                    const row = document.createElement("tr");

                    // Create cells
                    const rankCell = document.createElement("td");
                    rankCell.textContent = i;

                    const actionsCell = document.createElement("td");
                    actionsCell.className = "model-actions";
                    actionsCell.innerHTML = `
                      <div class="prompt-actions">
                          <a class="action-button edit-button" href="/edit_model?model=${model}">✏️</a>
                          <a class="action-button delete-button" href="/delete_model?model=${model}">🗑️</a>
                      </div>
                  `;

                    const modelCell = document.createElement("td");
                    modelCell.textContent = model;

                    // Create score cells
                    const scoreCells = [];
                    // Ensure we check both uppercase and lowercase field names for compatibility
                    const scores = results[model]?.Scores || results[model]?.scores || [];
                    if (i === 1) console.log(`First model scores for ${model}:`, scores);
                    const promptsCount = {{len .Prompts}} || 0;

                // Ensure we have enough scores for all prompts
                while (scores.length < promptsCount) {
                    scores.push(0);
                }

                for (let index = 0; index < promptsCount; index++) {
                    const score = scores[index] || 0;
                    const scoreCell = document.createElement("td");
                    
                    // Set cell class based on score using a more maintainable approach
                    const validScores = [0, 20, 40, 60, 80, 100];
                    const scoreClass = validScores.includes(score) ? `score-${score}` : 'score-0';
                    scoreCell.className = `score-cell ${scoreClass}`;

                    scoreCell.onclick = () => {
                        window.location.href = `/evaluate?model=${model}&prompt=${index}`;
                    };
                    scoreCells.push(scoreCell);
                }

                // Create total score cell
                const totalCell = document.createElement("td");
                totalCell.textContent = totalScores[model] || 0;
                totalCell.className = "progress-bar-wrapper";
                const progressDiv = document.createElement("div");
                progressDiv.className = "progress-bar-container progress-bar-standard-width";
                const progressBar = document.createElement("div");
                progressBar.className = "progress-bar";
                progressBar.style.setProperty('--progress-width', `${passPercentages[model] || 0}%`);
                progressDiv.appendChild(progressBar);
                totalCell.appendChild(progressDiv);

                // Append all cells to row
                row.appendChild(rankCell);
                row.appendChild(actionsCell);
                row.appendChild(modelCell);
                scoreCells.forEach(cell => row.appendChild(cell));
                row.appendChild(totalCell);

                fragment.appendChild(row);
            }
          });

        // Batch update the DOM
        tbody.innerHTML = '';
        tbody.appendChild(fragment);
        
        // Log the final number of rows created
        console.log(`Table updated with ${i} rows`);
        
        // Force a redraw if needed
        if (i > 0 && tbody.children.length === 0) {
            console.error("Rows not appearing in table despite being created. Forcing redraw...");
            const temp = tbody.innerHTML;
            tbody.innerHTML = '';
            setTimeout(() => {
                tbody.innerHTML = temp;
            }, 10);
        }
      }
          
      // Helper function to log the colors being used for debugging
      function logScoreColors() {
          const rootStyles = getComputedStyle(document.documentElement);
          console.log("Score colors used in chart:");
          [0, 20, 40, 60, 80, 100].forEach(score => {
              const varName = `--score-color-${score}`;
              console.log(`${score}: ${rootStyles.getPropertyValue(varName).trim() || 'Not set'}`);
          });
      }



        document.addEventListener('DOMContentLoaded', () => {
            // Skip the initial data loading attempt which is failing
            // and rely solely on the connectWebSocket function which will
            // call fetchInitialData() inside it
            console.log("DOM loaded, connecting to WebSocket...");
            connectWebSocket(); // Actually call the function
        });
        function createProfileHeaderRow(profileGroups) {
            // Create the profile header row
            const thead = document.querySelector('.results-table thead');
            if (!thead) return;
            
            const profileRow = document.createElement('tr');
            profileRow.className = 'profile-row';
            
            // Add empty cells for non-prompt columns
            const emptyHeader = document.createElement('th');
            emptyHeader.setAttribute('colspan', '3');
            profileRow.appendChild(emptyHeader);
            
            // Add profile group headers
            profileGroups.forEach((group, index) => {
                if (group.StartCol !== -1) { // Only include groups with prompts
                    const span = group.EndCol - group.StartCol + 1;
                    const header = document.createElement('th');
                    header.className = 'profile-header profile-header-cell';
                    header.setAttribute('colspan', span);
                    header.setAttribute('data-profile-id', group.ID);
                    
                    // Create inner text element
                    const textDiv = document.createElement('div');
                    textDiv.className = 'profile-header-text';
                    textDiv.textContent = group.Name;
                    header.appendChild(textDiv);
                    
                    // Apply profile-specific styling with CSS classes and variables
                    header.classList.add('profile-header-styled');
                    header.style.setProperty('--profile-color', group.Color);
                    
                    // Add divider classes between profile groups (except for the first one)
                    if (index > 0) {
                        header.classList.add('profile-divider-left');
                    }
                    
                    // Add divider to the previous header if this isn't the first
                    if (index > 0 && profileRow.lastChild && profileRow.lastChild.classList) {
                        profileRow.lastChild.classList.add('profile-divider-right');
                    }
                    
                    profileRow.appendChild(header);
                }
            });
            
            // Add total header with rowspan
            const totalHeader = document.createElement('th');
            totalHeader.setAttribute('rowspan', '2');
            totalHeader.textContent = 'Total';
            profileRow.appendChild(totalHeader);
            
            // Insert at the beginning of thead
            thead.insertBefore(profileRow, thead.firstChild);
        }

        function applyProfileStyling(profileGroups, orderedPrompts) {
            // First, apply styling to header columns and create a mapping of column styles
            const promptCols = document.querySelectorAll('.prompt-col');
            const columnStyles = {}; // Store styles for each column index
            
            console.log("Profile groups:", profileGroups);
            
            // First pass: create profile start/end maps by profile ID
            const profileStartColumns = {};
            const profileEndColumns = {};
            
            // Map profile boundaries by profile ID for easier lookup
            profileGroups.forEach(group => {
                // Handle both lowercase and uppercase property names
                const profileId = group.id || group.ID;
                const startCol = group.startCol !== undefined ? group.startCol : (group.StartCol !== undefined ? group.StartCol : -1);
                const endCol = group.endCol !== undefined ? group.endCol : (group.EndCol !== undefined ? group.EndCol : -1);
                
                console.log(`Processing group: id=${profileId}, startCol=${startCol}, endCol=${endCol}`);
                
                if (startCol !== -1 && profileId) {
                    profileStartColumns[profileId] = startCol;
                    profileEndColumns[profileId] = endCol;
                }
            });
            
            console.log("Profile start columns:", profileStartColumns);
            console.log("Profile end columns:", profileEndColumns);
            
            // Apply to header columns and build style mapping
            promptCols.forEach(col => {
                const profileId = col.getAttribute('data-profile-id');
                // Find profile group matching either lowercase or uppercase ID property
                const profileGroup = profileGroups.find(g => 
                    (g.id && g.id === profileId) || (g.ID && g.ID === profileId)
                );
                const promptIndex = parseInt(col.getAttribute('data-prompt-index'));
                
                if (profileGroup) {
                    // Apply base styling with CSS classes and variables
                    col.classList.add('profile-column');
                    col.style.setProperty('--profile-color', profileGroup.Color);
                    
                    // Get properties with case flexibility
                    const profileColor = profileGroup.Color || profileGroup.color;
                    const startCol = profileGroup.startCol !== undefined ? profileGroup.startCol : 
                                    (profileGroup.StartCol !== undefined ? profileGroup.StartCol : -1);
                    const endCol = profileGroup.endCol !== undefined ? profileGroup.endCol : 
                                  (profileGroup.EndCol !== undefined ? profileGroup.EndCol : -1);
                    
                    // Store style information for this column
                    columnStyles[promptIndex] = {
                        color: profileColor,
                        profileId: profileGroup.id || profileGroup.ID, // Handle both lowercase/uppercase
                        isStart: startCol === promptIndex,
                        isEnd: endCol === promptIndex
                    };
                    
                    // Apply CSS classes for header columns
                    if (startCol === promptIndex) {
                        col.classList.add('profile-start');
                        col.classList.add(`profile-${profileId}-start`);
                        console.log(`Applied start border to header col ${promptIndex}`);
                    }
                    
                    if (endCol === promptIndex) {
                        col.classList.add('profile-end');
                        col.classList.add(`profile-${profileId}-end`);
                        console.log(`Applied end border to header col ${promptIndex}`);
                    }
                }
            });
            
            // Now apply the same border styling to all data cells in the table
            const table = document.querySelector('.results-table');
            if (!table) return;
            
            // Get all profile IDs for tracking profile boundaries per row
            const profileIds = [...new Set(profileGroups.map(g => g.id || g.ID))].filter(id => id); // Remove empty IDs
            console.log("Profile IDs found:", profileIds);
            
            const tableRows = table.querySelectorAll('tbody tr');
            tableRows.forEach(row => {
                const cells = Array.from(row.querySelectorAll('td'));
                if (cells.length <= 3) return; // Skip rows with insufficient cells
                
                // Track the first cell of each profile group in this row
                const profileFirstCells = {};
                const profileLastCells = {};
                
                // First pass - identify first and last cells for each profile in this row
                for (let i = 3; i < cells.length - 1; i++) { // Skip first 3 cells and total cell
                    const columnIndex = i - 3; // Adjust index to match prompt indices
                    const style = columnStyles[columnIndex];
                    
                    if (style && style.profileId) {
                        // Track the first cell we see for each profile ID
                        if (!profileFirstCells[style.profileId]) {
                            profileFirstCells[style.profileId] = i;
                            console.log(`First cell for profile ${style.profileId}: ${i}`);
                        }
                        // Always update the last cell we see for this profile ID
                        profileLastCells[style.profileId] = i;
                    }
                }
                
                // Debug log the identified profile boundaries
                console.log("Profile first cells in row:", profileFirstCells);
                console.log("Profile last cells in row:", profileLastCells);
                
                // Reset all cell borders by removing previous profile classes
                for (let i = 3; i < cells.length - 1; i++) {
                    // Remove all profile classes to start fresh
                    cells[i].classList.remove('profile-start', 'profile-end');
                    
                    // Remove profile-specific classes
                    for (let j = 0; j < 5; j++) {
                        cells[i].classList.remove(`profile-${j}-start`, `profile-${j}-end`);
                    }
                }
                
                // Now apply styling for all cells
                for (let i = 3; i < cells.length - 1; i++) { // Exclude the last total column
                    const columnIndex = i - 3; // Adjust index to match prompt indices
                    
                    // Find the style for this column
                    const style = columnStyles[columnIndex];
                    if (style) {
                        // Apply basic column styling
                        cells[i].classList.add('score-cell', 'profile-column');
                        cells[i].style.setProperty('--profile-color', style.color);
                        
                        // Apply CSS classes for first cell of profile group
                        if (profileFirstCells[style.profileId] === i) {
                            // Add general and profile-specific classes
                            cells[i].classList.add('profile-start');
                            cells[i].classList.add(`profile-${style.profileId}-start`);
                            console.log(`Applied start border to cell ${i} for profile ${style.profileId}`);
                        }
                        
                        // Apply CSS classes for last cell of profile group
                        if (profileLastCells[style.profileId] === i) {
                            // Add general and profile-specific classes
                            cells[i].classList.add('profile-end');
                            cells[i].classList.add(`profile-${style.profileId}-end`);
                            console.log(`Applied end border to cell ${i} for profile ${style.profileId}`);
                        }
                    }
                }
            });
        }
    </script>
</head>

<body>
    {{template "nav" .}}
    <div class="sticky-header">
        <h2>Add Model</h2>
        <form action="/add_model" method="post" class="flex-form">
            <input type="text" name="model" placeholder="Enter new model name" class="margin-right-5" />
            <input type="submit" value="Add" />
        </form>
        <span id="connection-status" class="connection-status"></span>
    </div>
    <div class="title-row">
        <div class="filter-container">
            <form action="/results" method="get" id="filter-form" class="filter-form">
                <select name="model_filter" id="model_filter" aria-label="Filter by model">
                    <option value="">All Models</option>
                    {{range $model := .Models}}
                    <option value="{{$model}}" {{if and ($.ModelFilter) (eq $.ModelFilter $model)}}selected{{end}}>
                        {{$model}}
                    </option>
                    {{end}}
                </select>
                <input type="submit" value="Filter" class="filter-submit" />
            </form>
        </div>
        <div class="title-container">
            <button class="action-button" id="generate-mock-btn" onclick="generateMockScores()">Generate Random Mock Scores</button>
            <button class="action-button" id="restore-previous-btn" onclick="restorePrevious()" disabled>Previous</button>
        </div>
        <div class="search-container">
            <form id="search-form" class="search-form" onsubmit="handleSearch(); return false;">
                <input type="text" id="modelSearch" placeholder="Search models..." class="search-input"
                    aria-label="Search models" />
                <button type="submit" class="search-submit">Search</button>
            </form>
        </div>
    </div>
    <table class="results-table">
        <thead>
            <!-- Profile grouping row -->
            <tr class="profile-row">
                <th colspan="3"></th> <!-- For rank, actions, model columns -->
                {{$first := true}}
                {{range $index, $group := .ProfileGroups}}
                    {{if ne .StartCol -1}} <!-- Only include groups that have prompts -->
                    <th colspan="{{add (sub .EndCol .StartCol) 1}}" 
                        class="profile-header profile-header-cell profile-header-styled {{if not $first}}profile-divider-left{{end}}" 
                        data-profile-id="{{.ID}}"
                        style="--profile-color: {{.Color}};">
                        <div class="profile-header-text">{{.Name}}</div>
                    </th>
                    {{$first = false}}
                    {{end}}
                {{end}}
                <th rowspan="2">Total</th>
            </tr>
            
            <!-- Regular header row with numbers -->
            <tr>
                <th>#</th>
                <th>Actions</th>
                <th>Model</th>
                {{range $prompt := .OrderedPrompts}}
                    <th class="prompt-col" 
                        data-profile-id="{{$prompt.ProfileID}}"
                        data-prompt-index="{{$prompt.Index}}">
                        {{inc $prompt.Index}}
                    </th>
                {{end}}
            </tr>
        </thead>
        <tbody>
            <!-- Table content will be populated by JavaScript -->
        </tbody>
    </table>
    <div class="sticky-footer">
        <div class="results-management">
            <h2>Manage Results</h2>
            &nbsp;&nbsp;&nbsp;
            <form action="/reset_results" method="get" class="margin-right-5">
                <input type="submit" value="Reset Results" />
            </form>
            <form action="/confirm_refresh_results" method="get" class="margin-right-5">
                <input type="submit" value="Refresh Results" />
            </form>
            <form action="/export_results" method="post" class="margin-right-5">
                <input type="submit" value="Export Results" />
            </form>
            <form action="/import_results" method="post" enctype="multipart/form-data"
                class="file-import-form">
                <input type="file" name="results_file" class="margin-right-5" />
                <input type="submit" value="Import Results" />
            </form>
        </div>
    </div>
    <div class="scroll-buttons">
        <button class="scroll-button" onclick="scrollToTop()">↑</button>
        <button class="scroll-button" onclick="scrollToBottom()">↓</button>
    </div>
    <script>
        function scrollToTop() {
            window.scrollTo({top: 0, behavior: "smooth"});
        }

        function scrollToBottom() {
            window.scrollTo({
                top: document.body.scrollHeight,
                behavior: "smooth",
            });
        }
    </script>
    <div id="hidden-data" class="hidden-data">
        <span id="results-data">{{.Results | json}}</span>
        <span id="models-data">{{.Models | json}}</span>
        <span id="pass-percentages-data">{{.PassPercentages | json}}</span>
        <span id="total-scores-data">{{.TotalScores | json}}</span>
        <span id="profile-groups-data">{{.ProfileGroups | json}}</span>
        <span id="ordered-prompts-data">{{.OrderedPrompts | json}}</span>
        <span id="debug-data" class="debug-data">
            Results: {{.Results | json}}<br />
            Models: {{.Models | json}}<br />
            PassPercentages: {{.PassPercentages | json}}<br />
            TotalScores: {{.TotalScores | json}}<br />
            ProfileGroups: {{.ProfileGroups | json}}<br />
            OrderedPrompts: {{.OrderedPrompts | json}}
        </span>
    </div>
    <!-- Fallback data for debugging -->
    <script>
        // This ensures we have at least some data even if the template rendering fails
        window.fallbackData = {
            Results: {},
            Models: [],
            PassPercentages: {},
            TotalScores: {}
        };
    </script>
</body>

</html>
