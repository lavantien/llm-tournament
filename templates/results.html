<!doctype html>
<html data-theme="coffee">

<head>
    <title>Results</title>
    <link rel="stylesheet" href="/templates/output.css" />
    <link rel="icon" type="image/x-icon" href="/assets/favicon.ico" />
    <script src="/templates/constants.js"></script>
    <script src="/templates/utils.js"></script>
    <script>
        let socket;
        let connectionRetries = 0;
        let initialLoad = true;
        let currentSearchQuery = "";

        let previousState = {
            Results: {},
            Models: [],
            TotalScores: {},
            PassPercentages: {}
        };

        function connectWebSocket() {
            socket = new WebSocket("ws://" + window.location.host + "/ws");

            socket.onopen = function (e) {
                console.log("[open] Connection established");
                connectionRetries = 0;
                updateConnectionStatus("Connected", "connected");
            };

            fetchInitialData();

            socket.onmessage = function (event) {
                try {
                    const payload = JSON.parse(event.data);
                    console.log('Received WebSocket update:', payload);
        
                    if (payload.type === 'results') {
                        const safeData = {
                            Results: payload.data.results || {},
                            Models: payload.data.models || [],
                            PassPercentages: payload.data.passPercentages || {},
                            TotalScores: payload.data.totalScores || {}
                        };
             
                        updateHiddenData(safeData);
                        updateResults(safeData);
                    }
                } catch (error) {
                    console.error('Error parsing WebSocket message:', error, event.data);
                }
            };

            socket.onclose = function (event) {
                if (event.wasClean) {
                    console.log(`[close] Connection closed cleanly, code=${event.code} reason=${event.reason}`);
                } else {
                    console.log("[close] Connection died");
                }
                
                updateConnectionStatus("Disconnected", "disconnected");
                
                if (connectionRetries < MAX_WS_RETRIES) {
                    connectionRetries++;
                    console.log(`Attempting to reconnect (${connectionRetries}/${MAX_WS_RETRIES})...`);
                    setTimeout(connectWebSocket, WS_RETRY_DELAY_MS * connectionRetries);
                } else {
                    updateConnectionStatus("Connection failed", "failed");
                    console.log("Max retries reached. Connection failed.");
                }
            };

            socket.onerror = function (error) {
                console.log(`[error] ${error.message}`);
                updateConnectionStatus("Error", "error");
            };
        }
        
        function updateConnectionStatus(text, state) {
            const statusElement = document.getElementById("connection-status");
            statusElement.textContent = text;
            statusElement.className = `connection-status connection-status-${state}`;
        }
        
        function updateHiddenData(data) {
            document.getElementById('results-data').textContent = JSON.stringify(data.Results || {});
            document.getElementById('models-data').textContent = JSON.stringify(data.Models || []);
            document.getElementById('pass-percentages-data').textContent = JSON.stringify(data.PassPercentages || {});
            document.getElementById('total-scores-data').textContent = JSON.stringify(data.TotalScores || {});
        }

        function fetchInitialData() {
            console.log("Fetching initial data...");
            try {
                const elements = {
                    results: document.getElementById('results-data'),
                    models: document.getElementById('models-data'),
                    passPercentages: document.getElementById('pass-percentages-data'),
                    totalScores: document.getElementById('total-scores-data'),
                    profileGroups: document.getElementById('profile-groups-data'),
                    orderedPrompts: document.getElementById('ordered-prompts-data')
                };
                
                const payload = {
                    Results: safeJsonParse(elements.results?.textContent, {}),
                    Models: safeJsonParse(elements.models?.textContent, []),
                    PassPercentages: safeJsonParse(elements.passPercentages?.textContent, {}),
                    TotalScores: safeJsonParse(elements.totalScores?.textContent, {}),
                    ProfileGroups: safeJsonParse(elements.profileGroups?.textContent, []),
                    OrderedPrompts: safeJsonParse(elements.orderedPrompts?.textContent, [])
                };
                
                console.log('Data loaded from DOM elements:', { 
                    models_length: payload.Models.length,
                    firstModelData: payload.Models.length > 0 ? payload.Results[payload.Models[0]] : null,
                    profileGroups: payload.ProfileGroups
                });
                
                updateResults(payload);
                return Promise.resolve(payload);
            } catch (error) {
                console.error('Error parsing initial data:', error);
                const emptyPayload = {
                    Results: {},
                    Models: [],
                    PassPercentages: {},
                    TotalScores: {}
                };
                updateResults(emptyPayload);
                return Promise.resolve(emptyPayload);
            }
        }

        function handleSearch() {
            currentSearchQuery = document.getElementById("modelSearch").value.toLowerCase();
            
            const currentData = {
                Results: safeJsonParse(document.getElementById('results-data').textContent, {}),
                Models: safeJsonParse(document.getElementById('models-data').textContent, []),
                PassPercentages: safeJsonParse(document.getElementById('pass-percentages-data').textContent, {}),
                TotalScores: safeJsonParse(document.getElementById('total-scores-data').textContent, {})
            };
            
            updateResults(currentData);
        }

        function backupCurrentState() {
            previousState = {
                Results: safeJsonParse(document.getElementById('results-data').textContent, {}),
                Models: safeJsonParse(document.getElementById('models-data').textContent, []),
                TotalScores: safeJsonParse(document.getElementById('total-scores-data').textContent, {}),
                PassPercentages: safeJsonParse(document.getElementById('pass-percentages-data').textContent, {})
            };
            
            console.log('Current state backed up');
            
            document.getElementById('restore-previous-btn').disabled = false;
        }

        function restorePrevious() {
            if (!previousState.Models || previousState.Models.length === 0) {
                console.log('No previous state to restore');
                return;
            }
            
            console.log('Restoring previous state');
            
            updateHiddenData(previousState);
            
            sendDataToServer(previousState)
                .then(data => {
                    console.log('Previous state restored successfully');
                    updateResults(previousState);
                })
                .catch(error => {
                    console.error('Error restoring previous state:', error);
                    updateResults(previousState);
                });
        }
        
        function sendDataToServer(data) {
            return fetch('/update_mock_results', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify({
                    results: data.Results,
                    models: data.Models,
                    passPercentages: data.PassPercentages,
                    totalScores: data.TotalScores
                })
            })
            .then(response => response.json());
        }

        function generateMockScores() {
            console.log("Generating mock scores...");

            if (!confirm('Are you sure you want to generate mock data? This will override all current scores.')) {
                console.log('Mock data generation cancelled by user');
                return;
            }

            backupCurrentState();
    
            const models = safeJsonParse(document.getElementById('models-data').textContent, []);
            if (models.length === 0) {
                console.log('No existing models - backend will create mock models');
            }
            
            const promptsCount = {{len .Prompts}} || 0;
            
            let newData = generateTieredScores(models, promptsCount);
            
            updateHiddenData(newData);
            
            sendDataToServer(newData)
                .then(data => {
                    console.log('Mock data saved successfully');
                    location.reload();
                })
                .catch(error => {
                    console.error('Error saving mock data:', error);
                    alert('Failed to generate mock data. Please try again.');
                });
        }

        function randomizeScores() {
            console.log("Randomizing scores...");

            backupCurrentState();

            fetch('/randomize_scores', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                }
            })
            .then(response => {
                if (!response.ok) {
                    throw new Error('Failed to randomize scores');
                }
                return response.json();
            })
            .then(data => {
                console.log('Scores randomized successfully');
                location.reload();
            })
            .catch(error => {
                console.error('Error randomizing scores:', error);
                alert('Failed to randomize scores. Please try again.');
            });
        }

        function generateTieredScores(models, promptsCount) {
            const groupSize = Math.ceil(models.length / 11);
            
            let newResults = {};
            let newTotalScores = {};
            let newPassPercentages = {};
            
            models.forEach((model, index) => {
                const tierIndex = Math.min(10, Math.floor(index / groupSize));
                let scores = [];
                let total = 0;
                
                for (let i = 0; i < promptsCount; i++) {
                    let score = getRandomScoreForTier(tierIndex);
                    scores.push(score);
                    total += score;
                }
                
                newResults[model] = { Scores: scores };
                newTotalScores[model] = total;
                newPassPercentages[model] = (total / (promptsCount * 100)) * 100;
            });
            
            models.sort((a, b) => newTotalScores[b] - newTotalScores[a]);
            
            return {
                Results: newResults,
                Models: models,
                TotalScores: newTotalScores,
                PassPercentages: newPassPercentages
            };
        }
        
        function getRandomScoreForTier(tierIndex) {
            const tierWeights = [
                [1, 1, 8, 15, 25, 50],
                [1, 2, 10, 20, 40, 27],
                [2, 5, 15, 30, 35, 13],
                [5, 10, 25, 30, 20, 10],
                [7, 15, 33, 25, 15, 5],
                [10, 20, 35, 20, 10, 5],
                [15, 30, 30, 15, 8, 2],
                [20, 35, 25, 15, 4, 1],
                [30, 35, 20, 12, 2, 1],
                [40, 35, 15, 8, 2, 0],
                [55, 30, 10, 5, 0, 0],
                [17, 16, 16, 16, 16, 16]
            ];
            
            let weights = tierWeights[tierIndex] || tierWeights[11];
            
            const jitterFactor = 0.2;
            weights = weights.map(w => {
                const jitter = 1 + (Math.random() * jitterFactor * 2 - jitterFactor);
                return Math.max(0, Math.round(w * jitter));
            });
            
            const totalWeight = weights.reduce((a, b) => a + b, 0);
            let random = Math.random() * totalWeight;
            
            for (let i = 0; i < weights.length; i++) {
                random -= weights[i];
                if (random <= 0) {
                    return SCORE_VALUES[i];
                }
            }
            
            return 0;
        }

        function updateResults(payload) {
            const results = payload.Results || {};
            const models = payload.Models || [];
            const passPercentages = payload.PassPercentages || {};
            const totalScores = payload.TotalScores || {};
            const profileGroups = payload.ProfileGroups || [];
            const orderedPrompts = payload.OrderedPrompts || [];
            const modelFilter = document.getElementById("model_filter").value;

            initializeProfileHeaders(profileGroups);
            
            const tbody = getTableBody();
            if (!tbody) {
                console.error('Could not find or create table body');
                return;
            }
            
            const displayModels = ensureModelsExist(models, results);
            
            if (displayModels.length === 0) {
                console.error('No models available to display');
                tbody.innerHTML = '<tr><td colspan="100" class="no-models-message">No models available</td></tr>';
                return;
            }
            
            renderModelRows(tbody, displayModels, results, totalScores, passPercentages, modelFilter, profileGroups);
            
            setTimeout(applyDataCellStyling, 50);
        }
        
        function initializeProfileHeaders(profileGroups) {
            if (document.querySelector('.profile-row') === null && profileGroups.length > 0) {
                createProfileHeaderRow(profileGroups);
            }
            
            applyHeaderStyling(profileGroups);
        }
        
        function getTableBody() {
            let tbody = document.querySelector("table.results-table tbody") || 
                         document.querySelector("table tbody");
            
            if (!tbody) {
                console.log('Table body not found, creating one');
                const table = document.querySelector("table.results-table") || document.querySelector("table");
                if (table) {
                    const newTbody = document.createElement("tbody");
                    table.appendChild(newTbody);
                    tbody = newTbody;
                }
            }
            
            return tbody;
        }
        
        function ensureModelsExist(models, results) {
            if (models.length === 0 && Object.keys(results).length > 0) {
                console.log('Models array is empty, rebuilding from results keys');
                return Object.keys(results);
            }
            return models;
        }
        
        function renderModelRows(tbody, models, results, totalScores, passPercentages, modelFilter, profileGroups = []) {
            console.log(`Rendering ${models.length} models to table`);
            
            tbody.innerHTML = '';
            
            const fragment = document.createDocumentFragment();
            let rowCount = 0;
            
            models.forEach((model) => {
                if ((modelFilter === "" || model === modelFilter) &&
                    (currentSearchQuery === "" || model.toLowerCase().includes(currentSearchQuery))) {
                    rowCount++;
                    
                    const row = createModelRow(
                        model,
                        rowCount,
                        results[model],
                        totalScores[model] || 0,
                        passPercentages[model] || 0,
                        profileGroups
                    );
                    
                    fragment.appendChild(row);
                }
            });
            
            tbody.appendChild(fragment);
            
            console.log(`Table updated with ${rowCount} rows`);
            
            if (rowCount > 0 && tbody.children.length === 0) {
                console.error("Rows not appearing in table despite being created. Forcing redraw...");
                const temp = tbody.innerHTML;
                tbody.innerHTML = '';
                setTimeout(() => {
                    tbody.innerHTML = temp;
                }, 10);
            }
        }
        
        function createModelRow(model, rank, modelData, totalScore, passPercentage, profileGroups = []) {
            const row = document.createElement("tr");
            const promptsCount = {{len .Prompts}} || 0;
            
            const rankCell = document.createElement("td");
            rankCell.textContent = rank;
            
            const actionsCell = document.createElement("td");
            actionsCell.className = "model-actions";
            actionsCell.innerHTML = `
                <div class="prompt-actions">
                    <a class="action-button edit-button" href="/edit_model?model=${model}">‚úèÔ∏è</a>
                    <a class="action-button delete-button" href="/delete_model?model=${model}">üóëÔ∏è</a>
                </div>
            `;
            
            const modelCell = document.createElement("td");
            modelCell.textContent = model;
            
            const scores = modelData?.Scores || modelData?.scores || [];
            while (scores.length < promptsCount) {
                scores.push(0);
            }
            
            const scoreCells = createScoreCells(model, scores, promptsCount, profileGroups);
            
            const totalCell = createTotalScoreCell(totalScore, passPercentage);
            
            row.appendChild(rankCell);
            row.appendChild(actionsCell);
            row.appendChild(modelCell);
            scoreCells.forEach(cell => row.appendChild(cell));
            row.appendChild(totalCell);
            
            return row;
        }
        
        function createScoreCells(model, scores, promptsCount, profileGroups = []) {
            const cells = [];

            const dividerColumns = new Set();
            dividerColumns.add(0);
            profileGroups.forEach((group, idx) => {
                if (idx > 0 && group.startCol >= 0) {
                    dividerColumns.add(group.startCol);
                }
            });

            for (let index = 0; index < promptsCount; index++) {
                const score = scores[index] || 0;
                const scoreCell = document.createElement("td");

                let cellClass = 'score-cell';

                if (dividerColumns.has(index)) {
                    cellClass += ' profile-group-divider';
                }

                scoreCell.className = cellClass;
                
                const scoreColors = {
                    0: '#808080',
                    20: '#ffa500',
                    40: '#ffd700',
                    60: '#00bfff',
                    80: '#a77bff',
                    100: '#7cff6b'
                };
                const bgColor = scoreColors[score] || '#808080';
                scoreCell.style.backgroundColor = bgColor;
                scoreCell.style.color = 'white';
                scoreCell.style.width = '48px';
                scoreCell.style.height = '48px';
                scoreCell.style.fontWeight = 'bold';
                scoreCell.style.borderRadius = '8px';
                scoreCell.style.boxShadow = '0 1px 3px rgba(0,0,0,0.12)';
                scoreCell.textContent = score;
                
                scoreCell.setAttribute('data-prompt-index', index.toString());
                scoreCell.setAttribute('data-score', `Score: ${score}`);
                scoreCell.setAttribute('tabindex', '0');
                
                scoreCell.addEventListener('click', () => {
                    window.location.href = `/evaluate?model=${model}&prompt=${index}`;
                });
                
                scoreCell.addEventListener('keydown', (e) => {
                    if (e.key === 'Enter' || e.key === ' ') {
                        window.location.href = `/evaluate?model=${model}&prompt=${index}`;
                    }
                });
                
                cells.push(scoreCell);
            }
            
            return cells;
        }
        
        function createTotalScoreCell(totalScore, passPercentage) {
            const totalCell = document.createElement("td");
            totalCell.textContent = totalScore;
            totalCell.className = "progress-bar-wrapper";
            
            const progressDiv = document.createElement("div");
            progressDiv.className = "progress-bar-container progress-bar-standard-width";
            
            const progressBar = document.createElement("div");
            progressBar.className = "progress-bar";
            progressBar.style.setProperty('--progress-width', `${passPercentage}%`);
            
            progressDiv.appendChild(progressBar);
            totalCell.appendChild(progressDiv);
            
            return totalCell;
        }
          

        document.addEventListener('DOMContentLoaded', () => {
            console.log("DOM loaded, connecting to WebSocket...");
            connectWebSocket();
        });
        function createProfileHeaderRow(profileGroups) {
            const thead = document.querySelector('.results-table thead');
            if (!thead) return;
            
            const profileRow = document.createElement('tr');
            profileRow.className = 'profile-row';
            
            const emptyHeader = document.createElement('th');
            emptyHeader.setAttribute('colspan', '3');
            profileRow.appendChild(emptyHeader);
            
            profileGroups.forEach((group, index) => {
                if (group.StartCol !== -1) {
                    const span = group.EndCol - group.StartCol + 1;
                    const header = createProfileHeader(group, index, profileRow);
                    header.setAttribute('colspan', span);
                    profileRow.appendChild(header);
                }
            });
            
            const totalHeader = document.createElement('th');
            totalHeader.setAttribute('rowspan', '2');
            totalHeader.textContent = 'Total';
            profileRow.appendChild(totalHeader);
            
            thead.insertBefore(profileRow, thead.firstChild);
        }
        
        function createProfileHeader(group, index, parentRow) {
            const header = document.createElement('th');
            header.className = 'profile-header profile-header-cell';
            header.setAttribute('data-profile-id', group.ID);
            
            const textDiv = document.createElement('div');
            textDiv.className = 'profile-header-text';
            textDiv.textContent = group.Name;
            header.appendChild(textDiv);
            
            header.classList.add('profile-header-styled');
            header.style.setProperty('--profile-color', '#333');
            
            if (index > 0) {
                header.classList.add('profile-divider-left');
            }
            
            if (index > 0 && parentRow.lastChild && parentRow.lastChild.classList) {
                parentRow.lastChild.classList.add('profile-divider-right');
            }
            
            return header;
        }

        function applyHeaderStyling(profileGroups) {
            const columnMap = {};
            
            window.profileColumnMap = {};
            
            profileGroups.forEach(group => {
                const startCol = group.startCol !== undefined ? group.startCol : (group.StartCol !== undefined ? group.StartCol : -1);
                const endCol = group.endCol !== undefined ? group.endCol : (group.EndCol !== undefined ? group.EndCol : -1);
                const color = '#333';
                
                if (startCol !== -1) {
                    columnMap[startCol] = { isStart: true, isEnd: false, color: color };
                    columnMap[endCol] = { isStart: false, isEnd: true, color: color };
                    
                    window.profileColumnMap[startCol] = { isStart: true, color: color };
                    window.profileColumnMap[endCol] = { isEnd: true, color: color };
                }
            });

            const headerCells = document.querySelectorAll('.prompt-col');

            headerCells.forEach(cell => {
                const promptIndex = parseInt(cell.getAttribute('data-prompt-index'));
                const boundary = columnMap[promptIndex];

                cell.classList.remove('profile-start', 'profile-end', 'profile-group-start', 'profile-group-end', 'header-divider', 'profile-group-divider');
                cell.style.borderLeft = '';

                const existingDivider = cell.querySelector('.header-divider-line');
                if (existingDivider) {
                    existingDivider.remove();
                }

                if (promptIndex === 0) {
                    cell.classList.add('profile-group-divider', 'header-divider');
                    const dividerLine = document.createElement('div');
                    dividerLine.className = 'header-divider-line';
                    cell.appendChild(dividerLine);
                }
                else if (boundary && boundary.isStart) {
                    cell.classList.add('profile-group-start', 'profile-group-divider', 'header-divider');
                    const dividerLine = document.createElement('div');
                    dividerLine.className = 'header-divider-line';
                    cell.appendChild(dividerLine);
                }

                if (boundary && boundary.isEnd) {
                    cell.classList.add('profile-group-end');
                }
            });
        }

        function applyDataCellStyling() {
            if (!window.profileColumnMap) {
                console.error("Profile column map not initialized");
                return;
            }
            
            const columnMap = window.profileColumnMap;
            
            const table = document.querySelector('.results-table');
            if (!table) {
                console.error("Table not found");
                return;
            }
            
            const tableRows = table.querySelectorAll('tbody tr');
            
            tableRows.forEach(row => {
                const cells = Array.from(row.querySelectorAll('td'));
                if (cells.length <= 3) return;
                
                for (let i = 3; i < cells.length - 1; i++) {
                    const columnIndex = i - 3;
                    const boundary = columnMap[columnIndex];
                    
                    if (boundary) {
                        cells[i].classList.remove('profile-start', 'profile-end', 'profile-group-start', 'profile-group-end');
                        
                        if (boundary.isStart) {
                            cells[i].classList.add('profile-group-start', 'profile-group-divider');
                            cells[i].style.borderLeft = `${PROFILE_BORDER_WIDTH} solid #333`;
                        }
                        
                        if (boundary.isEnd) {
                            cells[i].classList.add('profile-group-end');
                            cells[i].style.borderRight = `${PROFILE_BORDER_WIDTH} solid #333`;
                        }
                    }
                }
            });
        }
    </script>
</head>

<body>
    <div class="flex flex-col min-h-screen bg-base-200 p-3">
        {{template "nav" .}}
        <main class="flex-1 flex flex-col gap-3 overflow-auto">
    <div class="card bg-base-100 shadow-lg p-4 m-0 flex items-center justify-between gap-3 sticky-header">
        <h2 class="card-title text-sm font-semibold flex-shrink-0">Add Model</h2>
        <form action="/add_model" method="post" class="flex items-center gap-2 flex-1">
            <input type="text" name="model" placeholder="Enter new model name" class="input input-bordered" />
            <input type="submit" value="Add" class="btn btn-primary" />
        </form>
        <span id="connection-status" class="badge badge-info flex-shrink-0"></span>
    </div>
    <div class="card bg-base-100 shadow-lg p-4 m-0 flex items-center justify-between gap-3 title-row">
        <div class="filter-container flex items-center gap-2 flex-shrink-0">
            <form action="/results" method="get" id="filter-form" class="flex items-center gap-2">
                <select name="model_filter" id="model_filter" aria-label="Filter by model" class="select select-bordered w-60 max-w-full">
                    <option value="">All Models</option>
                    {{range $model := .Models}}
                    <option value="{{$model}}" {{if and ($.ModelFilter) (eq $.ModelFilter $model)}}selected{{end}}>
                        {{$model}}
                    </option>
                    {{end}}
                </select>
                <input type="submit" value="Filter" class="btn btn-info filter-submit" />
            </form>
            <button class="btn btn-primary" id="generate-mock-btn" onclick="generateMockScores()">Generate Mock Data</button>
            <button class="btn btn-primary" id="randomize-scores-btn" onclick="randomizeScores()">Randomize Scores</button>
            <button class="btn btn-info" id="restore-previous-btn" onclick="restorePrevious()" disabled>Previous</button>
        </div>
        <div class="search-container flex items-center gap-2 flex-1">
            <form id="search-form" class="search-form flex items-center gap-2" onsubmit="handleSearch(); return false;">
                <input type="text" id="modelSearch" placeholder="Search models..." class="input input-bordered w-80 max-w-full" aria-label="Search models" />
                <button type="submit" class="btn btn-primary search-submit">Search</button>
            </form>
        </div>
    </div>
    <table class="table table-zebra results-table table-enhanced">
        <thead>
            <tr class="profile-row">
                <th colspan="3"></th>
                {{range $index, $group := .ProfileGroups}}
                    {{if ne .StartCol -1}}
                    <th colspan="{{add (sub .EndCol .StartCol) 1}}"
                        class="profile-header profile-header-cell profile-header-styled profile-divider-left"
                        data-profile-id="{{.ID}}"
                        style="position: relative; --profile-color: #333;">
                        <div class="header-divider-line"></div>
                        <div class="profile-header-text">{{.Name}}</div>
                    </th>
                    {{end}}
                {{end}}
                <th rowspan="2">Total</th>
            </tr>

            <tr>
                <th>#</th>
                <th>Actions</th>
                <th>Model</th>
                {{range $prompt := .OrderedPrompts}}
                    <th class="prompt-col"
                        data-profile-id="{{$prompt.ProfileID}}"
                        data-prompt-index="{{$prompt.Index}}">
                        {{inc $prompt.Index}}
                    </th>
                {{end}}
            </tr>
        </thead>
        <tbody>
        </tbody>
    </table>
    <div class="card bg-base-100 shadow-lg p-4 m-0 flex items-center justify-between gap-3 sticky-footer">
        <h2 class="text-sm font-semibold flex-shrink-0">Manage Results</h2>
        <form action="/reset_results" method="get">
            <input type="submit" value="Reset Results" class="btn btn-primary" />
        </form>
        <form action="/confirm_refresh_results" method="get">
            <input type="submit" value="Refresh Results" class="btn btn-primary" />
        </form>
        <form action="/export_results" method="post">
            <input type="submit" value="Export Results" class="btn btn-primary" />
        </form>
        <form action="/import_results" method="post" enctype="multipart/form-data" class="flex items-center gap-2">
            <input type="file" name="results_file" class="file-input file-input-bordered" />
            <input type="submit" value="Import Results" class="btn btn-primary" />
        </form>
    </div>
    <div class="fixed left-4 bottom-4 flex flex-col gap-2 z-[1000]">
        <button class="btn btn-info" onclick="scrollToTop()">‚Üë</button>
        <button class="btn btn-info" onclick="scrollToBottom()">‚Üì</button>
    </div>
    <script>
        function scrollToTop() {
            window.scrollTo({top: 0, behavior: "smooth"});
        }

        function scrollToBottom() {
            window.scrollTo({
                top: document.body.scrollHeight,
                behavior: "smooth",
            });
        }
        
        document.addEventListener('keydown', function(e) {
            if (document.activeElement && document.activeElement.classList.contains('score-cell')) {
                const currentCell = document.activeElement;
                const currentRow = currentCell.parentElement;
                const currentIndex = Array.from(currentRow.children).indexOf(currentCell);
                
                let nextCell;
                
                switch(e.key) {
                    case 'ArrowRight':
                        nextCell = currentRow.children[currentIndex + 1];
                        break;
                    case 'ArrowLeft':
                        nextCell = currentRow.children[currentIndex - 1];
                        break;
                    case 'ArrowUp':
                        const prevRow = currentRow.previousElementSibling;
                        if (prevRow) nextCell = prevRow.children[currentIndex];
                        break;
                    case 'ArrowDown':
                        const nextRow = currentRow.nextElementSibling;
                        if (nextRow) nextCell = nextRow.children[currentIndex];
                        break;
                }
                
                if (nextCell && nextCell.classList.contains('score-cell')) {
                    e.preventDefault();
                    nextCell.focus();
                }
            }
        });
    </script>
    <div id="hidden-data" class="hidden">
        <span id="results-data">{{.Results | json}}</span>
        <span id="models-data">{{.Models | json}}</span>
        <span id="pass-percentages-data">{{.PassPercentages | json}}</span>
        <span id="total-scores-data">{{.TotalScores | json}}</span>
        <span id="profile-groups-data">{{.ProfileGroups | json}}</span>
        <span id="ordered-prompts-data">{{.OrderedPrompts | json}}</span>
    </div>
    <script>
        window.fallbackData = {
            Results: {},
            Models: [],
            PassPercentages: {},
            TotalScores: {}
        };
    </script>
        </main>
    </div>
</body>

</html>
