
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>handlers: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">llm-tournament/handlers/evaluation.go (90.4%)</option>
				
				<option value="file1">llm-tournament/handlers/models.go (89.2%)</option>
				
				<option value="file2">llm-tournament/handlers/profiles.go (69.7%)</option>
				
				<option value="file3">llm-tournament/handlers/prompt.go (72.3%)</option>
				
				<option value="file4">llm-tournament/handlers/results.go (82.9%)</option>
				
				<option value="file5">llm-tournament/handlers/settings.go (78.9%)</option>
				
				<option value="file6">llm-tournament/handlers/stats.go (89.7%)</option>
				
				<option value="file7">llm-tournament/handlers/suites.go (74.7%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package handlers

import (
        "database/sql"
        "fmt"
        "llm-tournament/evaluator"
        "llm-tournament/middleware"
        "log"
        "net/http"
        "strconv"
)

var globalEvaluator *evaluator.Evaluator

// InitEvaluator initializes the global evaluator instance
func InitEvaluator(db *sql.DB) <span class="cov8" title="1">{
        pythonURL, _ := middleware.GetSetting("python_service_url")
        if pythonURL == "" </span><span class="cov0" title="0">{
                pythonURL = "http://localhost:8001"
        }</span>
        <span class="cov8" title="1">globalEvaluator = evaluator.NewEvaluator(db, pythonURL)
        log.Printf("Evaluator initialized with Python service URL: %s", pythonURL)</span>
}

// EvaluateAllHandler triggers evaluation of all models × all prompts
func EvaluateAllHandler(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        if r.Method != http.MethodPost </span><span class="cov8" title="1">{
                http.Error(w, "Method not allowed", http.StatusMethodNotAllowed)
                return
        }</span>

        <span class="cov8" title="1">suiteID, err := middleware.GetCurrentSuiteID()
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("Error getting current suite: %v", err)
                http.Error(w, "Failed to get current suite", http.StatusInternalServerError)
                return
        }</span>

        <span class="cov8" title="1">jobID, err := globalEvaluator.EvaluateAll(suiteID)
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("Error starting evaluation: %v", err)
                http.Error(w, fmt.Sprintf("Failed to start evaluation: %v", err), http.StatusInternalServerError)
                return
        }</span>

        <span class="cov8" title="1">middleware.RespondJSON(w, map[string]interface{}{
                "success": true,
                "job_id":  jobID,
                "message": "Evaluation started",
        })</span>
}

// EvaluateModelHandler triggers evaluation of one model × all prompts
func EvaluateModelHandler(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        if r.Method != http.MethodPost </span><span class="cov8" title="1">{
                http.Error(w, "Method not allowed", http.StatusMethodNotAllowed)
                return
        }</span>

        <span class="cov8" title="1">modelIDStr := r.URL.Query().Get("id")
        if modelIDStr == "" </span><span class="cov8" title="1">{
                http.Error(w, "Model ID required", http.StatusBadRequest)
                return
        }</span>

        <span class="cov8" title="1">modelID, err := strconv.Atoi(modelIDStr)
        if err != nil </span><span class="cov8" title="1">{
                http.Error(w, "Invalid model ID", http.StatusBadRequest)
                return
        }</span>

        <span class="cov8" title="1">jobID, err := globalEvaluator.EvaluateModel(modelID)
        if err != nil </span><span class="cov8" title="1">{
                log.Printf("Error starting model evaluation: %v", err)
                http.Error(w, fmt.Sprintf("Failed to start evaluation: %v", err), http.StatusInternalServerError)
                return
        }</span>

        <span class="cov8" title="1">middleware.RespondJSON(w, map[string]interface{}{
                "success": true,
                "job_id":  jobID,
                "message": "Model evaluation started",
        })</span>
}

// EvaluatePromptHandler triggers evaluation of all models × one prompt
func EvaluatePromptHandler(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        if r.Method != http.MethodPost </span><span class="cov8" title="1">{
                http.Error(w, "Method not allowed", http.StatusMethodNotAllowed)
                return
        }</span>

        <span class="cov8" title="1">promptIDStr := r.URL.Query().Get("id")
        if promptIDStr == "" </span><span class="cov8" title="1">{
                http.Error(w, "Prompt ID required", http.StatusBadRequest)
                return
        }</span>

        <span class="cov8" title="1">promptID, err := strconv.Atoi(promptIDStr)
        if err != nil </span><span class="cov8" title="1">{
                http.Error(w, "Invalid prompt ID", http.StatusBadRequest)
                return
        }</span>

        <span class="cov8" title="1">jobID, err := globalEvaluator.EvaluatePrompt(promptID)
        if err != nil </span><span class="cov8" title="1">{
                log.Printf("Error starting prompt evaluation: %v", err)
                http.Error(w, fmt.Sprintf("Failed to start evaluation: %v", err), http.StatusInternalServerError)
                return
        }</span>

        <span class="cov8" title="1">middleware.RespondJSON(w, map[string]interface{}{
                "success": true,
                "job_id":  jobID,
                "message": "Prompt evaluation started",
        })</span>
}

// EvaluationProgressHandler returns the status of an evaluation job
func EvaluationProgressHandler(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        jobIDStr := r.URL.Query().Get("id")
        if jobIDStr == "" </span><span class="cov8" title="1">{
                http.Error(w, "Job ID required", http.StatusBadRequest)
                return
        }</span>

        <span class="cov8" title="1">jobID, err := strconv.Atoi(jobIDStr)
        if err != nil </span><span class="cov8" title="1">{
                http.Error(w, "Invalid job ID", http.StatusBadRequest)
                return
        }</span>

        <span class="cov8" title="1">job, err := globalEvaluator.GetJobStatus(jobID)
        if err != nil </span><span class="cov8" title="1">{
                log.Printf("Error getting job status: %v", err)
                http.Error(w, "Failed to get job status", http.StatusInternalServerError)
                return
        }</span>

        <span class="cov8" title="1">middleware.RespondJSON(w, map[string]interface{}{
                "job_id":            job.ID,
                "status":            job.Status,
                "progress_current":  job.ProgressCurrent,
                "progress_total":    job.ProgressTotal,
                "estimated_cost":    job.EstimatedCost,
                "actual_cost":       job.ActualCost,
                "error":             job.ErrorMessage,
        })</span>
}

// CancelEvaluationHandler cancels a running evaluation job
func CancelEvaluationHandler(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        if r.Method != http.MethodPost </span><span class="cov8" title="1">{
                http.Error(w, "Method not allowed", http.StatusMethodNotAllowed)
                return
        }</span>

        <span class="cov8" title="1">jobIDStr := r.URL.Query().Get("id")
        if jobIDStr == "" </span><span class="cov8" title="1">{
                http.Error(w, "Job ID required", http.StatusBadRequest)
                return
        }</span>

        <span class="cov8" title="1">jobID, err := strconv.Atoi(jobIDStr)
        if err != nil </span><span class="cov8" title="1">{
                http.Error(w, "Invalid job ID", http.StatusBadRequest)
                return
        }</span>

        <span class="cov8" title="1">if err := globalEvaluator.CancelJob(jobID); err != nil </span><span class="cov8" title="1">{
                log.Printf("Error cancelling job: %v", err)
                http.Error(w, fmt.Sprintf("Failed to cancel job: %v", err), http.StatusInternalServerError)
                return
        }</span>

        <span class="cov0" title="0">middleware.RespondJSON(w, map[string]interface{}{
                "success": true,
                "message": "Job cancelled",
        })</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">package handlers

import (
        "log"
        "net/http"

        "llm-tournament/middleware"
)

// Handle add model
func AddModelHandler(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        log.Println("Handling add model")
        err := r.ParseForm()
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("Error parsing form: %v", err)
                http.Error(w, "Error parsing form", http.StatusBadRequest)
                return
        }</span>
        <span class="cov8" title="1">modelName := r.Form.Get("model")
        if modelName == "" </span><span class="cov8" title="1">{
                log.Println("Model name cannot be empty")
                http.Error(w, "Model name cannot be empty", http.StatusBadRequest)
                return
        }</span>
        <span class="cov8" title="1">results := middleware.ReadResults()
        if results == nil </span><span class="cov0" title="0">{
                results = make(map[string]middleware.Result)
        }</span>
        <span class="cov8" title="1">if _, ok := results[modelName]; !ok </span><span class="cov8" title="1">{
                results[modelName] = middleware.Result{Scores: make([]int, len(middleware.ReadPrompts()))}
        }</span>
        <span class="cov8" title="1">suiteName := middleware.GetCurrentSuiteName()
        err = middleware.WriteResults(suiteName, results)
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("Error writing results: %v", err)
                http.Error(w, "Error writing results", http.StatusInternalServerError)
                return
        }</span>
        <span class="cov8" title="1">log.Println("Model added successfully")
        middleware.BroadcastResults()
        http.Redirect(w, r, "/results", http.StatusSeeOther)</span>
}

// Handle edit model
func EditModelHandler(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        log.Println("Handling edit model")
        modelName := r.URL.Query().Get("model")
        if modelName == "" </span><span class="cov8" title="1">{
                http.Error(w, "Model name is required", http.StatusBadRequest)
                return
        }</span>

        <span class="cov8" title="1">if r.Method == "POST" </span><span class="cov8" title="1">{
                newModelName := r.FormValue("new_model_name")
                if newModelName == "" </span><span class="cov8" title="1">{
                        http.Error(w, "New model name cannot be empty", http.StatusBadRequest)
                        return
                }</span>

                <span class="cov8" title="1">results := middleware.ReadResults()
                if _, exists := results[newModelName]; exists </span><span class="cov8" title="1">{
                        http.Error(w, "Model with this name already exists", http.StatusBadRequest)
                        return
                }</span>

                <span class="cov8" title="1">results[newModelName] = results[modelName]
                delete(results, modelName)
                suiteName := middleware.GetCurrentSuiteName()
                middleware.WriteResults(suiteName, results)

                middleware.BroadcastResults()
                http.Redirect(w, r, "/results", http.StatusSeeOther)
                return</span>
        }

        // Render the edit model form
        <span class="cov8" title="1">middleware.RenderTemplateSimple(w, "edit_model.html", map[string]string{"Model": modelName})</span>
}

// Handle delete model
func DeleteModelHandler(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        log.Println("Handling delete model")
        if r.Method == "GET" </span><span class="cov8" title="1">{
                modelName := r.URL.Query().Get("model")
                if modelName == "" </span><span class="cov8" title="1">{
                        http.Error(w, "Model name is required", http.StatusBadRequest)
                        return
                }</span>
                <span class="cov8" title="1">middleware.RenderTemplateSimple(w, "delete_model.html", map[string]string{"Model": modelName})</span>
        } else<span class="cov8" title="1"> if r.Method == "POST" </span><span class="cov8" title="1">{
                modelName := r.FormValue("model")
                if modelName == "" </span><span class="cov8" title="1">{
                        http.Error(w, "Model name is required", http.StatusBadRequest)
                        return
                }</span>

                <span class="cov8" title="1">results := middleware.ReadResults()
                delete(results, modelName)
                suiteName := middleware.GetCurrentSuiteName()
                middleware.WriteResults(suiteName, results)

                middleware.BroadcastResults()
                http.Redirect(w, r, "/results", http.StatusSeeOther)</span>
        }
}
</pre>
		
		<pre class="file" id="file2" style="display: none">package handlers

import (
        "encoding/json"
        "html/template"
        "log"
        "net/http"
        "strconv"
        "strings"

        "github.com/microcosm-cc/bluemonday"
        "github.com/russross/blackfriday/v2"

        "llm-tournament/middleware"
)

// Handle profiles page
func ProfilesHandler(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        log.Println("Handling profiles page")
        searchQuery := r.FormValue("search_query")

        funcMap := template.FuncMap{
                "inc": func(i int) int </span><span class="cov8" title="1">{
                        return i + 1
                }</span>,
                "tolower":  strings.ToLower,
                "contains": strings.Contains,
        }
        <span class="cov8" title="1">funcMap["json"] = func(v interface{}) (string, error) </span><span class="cov0" title="0">{
                b, err := json.Marshal(v)
                return string(b), err
        }</span>

        <span class="cov8" title="1">pageName := "Profiles"
        t, err := template.New("profiles.html").Funcs(funcMap).ParseFiles("templates/profiles.html", "templates/nav.html")
        if err != nil </span><span class="cov8" title="1">{
                log.Printf("Error parsing template: %v", err)
                http.Error(w, "Error parsing template", http.StatusInternalServerError)
                return
        }</span>
        <span class="cov8" title="1">if t == nil </span><span class="cov0" title="0">{
                log.Println("Error parsing template")
                http.Error(w, "Error parsing template", http.StatusInternalServerError)
                return
        }</span>

        <span class="cov8" title="1">profiles := middleware.ReadProfiles()
        err = t.Execute(w, struct {
                PageName    string
                Profiles    []middleware.Profile
                SearchQuery string
        }{
                PageName:    pageName,
                Profiles:    profiles,
                SearchQuery: searchQuery,
        })
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("Error executing template: %v", err)
                http.Error(w, "Error executing template", http.StatusInternalServerError)
                return
        }</span>
        <span class="cov8" title="1">log.Println("Profiles page rendered successfully")</span>
}

// Handle add profile
func AddProfileHandler(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        log.Println("Handling add profile")
        err := r.ParseForm()
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("Error parsing form: %v", err)
                http.Error(w, "Error parsing form", http.StatusBadRequest)
                return
        }</span>
        <span class="cov8" title="1">profileName := r.Form.Get("profile_name")
        profileDescription := r.Form.Get("profile_description")
        if profileName == "" </span><span class="cov8" title="1">{
                log.Println("Profile name cannot be empty")
                http.Error(w, "Profile name cannot be empty", http.StatusBadRequest)
                return
        }</span>

        <span class="cov8" title="1">profiles := middleware.ReadProfiles()
        profiles = append(profiles, middleware.Profile{Name: profileName, Description: profileDescription})
        err = middleware.WriteProfiles(profiles)
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("Error writing profiles: %v", err)
                http.Error(w, "Error writing profiles", http.StatusInternalServerError)
                return
        }</span>
        <span class="cov8" title="1">log.Println("Profile added successfully")
        http.Redirect(w, r, "/profiles", http.StatusSeeOther)</span>
}

// Handle edit profile
func EditProfileHandler(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        log.Println("Handling edit profile")
        if r.Method == "GET" </span><span class="cov8" title="1">{
                err := r.ParseForm()
                if err != nil </span><span class="cov0" title="0">{
                        log.Printf("Error parsing form: %v", err)
                        http.Error(w, "Error parsing form", http.StatusBadRequest)
                        return
                }</span>
                <span class="cov8" title="1">indexStr := r.Form.Get("index")
                index, err := strconv.Atoi(indexStr)
                if err != nil </span><span class="cov8" title="1">{
                        log.Printf("Invalid index: %v", err)
                        http.Error(w, "Invalid index", http.StatusBadRequest)
                        return
                }</span>
                <span class="cov8" title="1">profiles := middleware.ReadProfiles()
                if index &gt;= 0 &amp;&amp; index &lt; len(profiles) </span><span class="cov8" title="1">{
                        funcMap := template.FuncMap{
                                "markdown": func(text string) template.HTML </span><span class="cov8" title="1">{
                                        unsafe := blackfriday.Run([]byte(text), blackfriday.WithNoExtensions())
                                        html := bluemonday.UGCPolicy().SanitizeBytes(unsafe)
                                        return template.HTML(html)
                                }</span>,
                        }
                        <span class="cov8" title="1">t, err := template.New("edit_profile.html").Funcs(funcMap).ParseFiles("templates/edit_profile.html")
                        if err != nil </span><span class="cov0" title="0">{
                                log.Printf("Error parsing template: %v", err)
                                http.Error(w, "Error parsing template", http.StatusInternalServerError)
                                return
                        }</span>
                        <span class="cov8" title="1">err = t.Execute(w, struct {
                                Index   int
                                Profile middleware.Profile
                        }{
                                Index:   index,
                                Profile: profiles[index],
                        })
                        if err != nil </span><span class="cov0" title="0">{
                                log.Printf("Error executing template: %v", err)
                                http.Error(w, "Error executing template", http.StatusInternalServerError)
                                return
                        }</span>
                }
        } else<span class="cov8" title="1"> if r.Method == "POST" </span><span class="cov8" title="1">{
                err := r.ParseForm()
                if err != nil </span><span class="cov0" title="0">{
                        log.Printf("Error parsing form: %v", err)
                        http.Error(w, "Error parsing form", http.StatusBadRequest)
                        return
                }</span>
                <span class="cov8" title="1">indexStr := r.Form.Get("index")
                index, err := strconv.Atoi(indexStr)
                if err != nil </span><span class="cov8" title="1">{
                        log.Printf("Invalid index: %v", err)
                        http.Error(w, "Invalid index", http.StatusBadRequest)
                        return
                }</span>
                <span class="cov8" title="1">editedProfileName := r.Form.Get("profile_name")
                editedProfileDescription := r.Form.Get("profile_description")
                if editedProfileName == "" </span><span class="cov8" title="1">{
                        log.Println("Profile name cannot be empty")
                        http.Error(w, "Profile name cannot be empty", http.StatusBadRequest)
                        return
                }</span>
                <span class="cov8" title="1">profiles := middleware.ReadProfiles()
                if index &gt;= 0 &amp;&amp; index &lt; len(profiles) </span><span class="cov8" title="1">{
                        oldProfileName := profiles[index].Name
                        profiles[index].Name = editedProfileName
                        profiles[index].Description = editedProfileDescription
                        
                        // Update prompts that reference this profile
                        prompts := middleware.ReadPrompts()
                        for i := range prompts </span><span class="cov8" title="1">{
                                if prompts[i].Profile == oldProfileName </span><span class="cov8" title="1">{
                                        prompts[i].Profile = editedProfileName
                                }</span>
                        }
                        <span class="cov8" title="1">err = middleware.WritePrompts(prompts)
                        if err != nil </span><span class="cov0" title="0">{
                                log.Printf("Error updating prompts: %v", err)
                                http.Error(w, "Error updating prompts", http.StatusInternalServerError)
                                return
                        }</span>
                }
                <span class="cov8" title="1">err = middleware.WriteProfiles(profiles)
                if err != nil </span><span class="cov0" title="0">{
                        log.Printf("Error writing profiles: %v", err)
                        http.Error(w, "Error writing profiles", http.StatusInternalServerError)
                        return
                }</span>
                <span class="cov8" title="1">log.Println("Profile edited successfully")
                http.Redirect(w, r, "/profiles", http.StatusSeeOther)</span>
        }
}

// Handle delete profile
func DeleteProfileHandler(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        log.Println("Handling delete profile")
        if r.Method == "GET" </span><span class="cov8" title="1">{
                err := r.ParseForm()
                if err != nil </span><span class="cov0" title="0">{
                        log.Printf("Error parsing form: %v", err)
                        http.Error(w, "Error parsing form", http.StatusBadRequest)
                        return
                }</span>
                <span class="cov8" title="1">indexStr := r.Form.Get("index")
                index, err := strconv.Atoi(indexStr)
                if err != nil </span><span class="cov8" title="1">{
                        log.Printf("Invalid index: %v", err)
                        http.Error(w, "Invalid index", http.StatusBadRequest)
                        return
                }</span>
                <span class="cov8" title="1">profiles := middleware.ReadProfiles()
                if index &gt;= 0 &amp;&amp; index &lt; len(profiles) </span><span class="cov8" title="1">{
                        funcMap := template.FuncMap{
                                "markdown": func(text string) template.HTML </span><span class="cov0" title="0">{
                                        unsafe := blackfriday.Run([]byte(text), blackfriday.WithNoExtensions())
                                        html := bluemonday.UGCPolicy().SanitizeBytes(unsafe)
                                        return template.HTML(html)
                                }</span>,
                        }
                        <span class="cov8" title="1">t, err := template.New("delete_profile.html").Funcs(funcMap).ParseFiles("templates/delete_profile.html")
                        if err != nil </span><span class="cov0" title="0">{
                                log.Printf("Error parsing template: %v", err)
                                http.Error(w, "Error parsing template", http.StatusInternalServerError)
                                return
                        }</span>
                        <span class="cov8" title="1">err = t.Execute(w, struct {
                                Index   int
                                Profile middleware.Profile
                        }{
                                Index:   index,
                                Profile: profiles[index],
                        })
                        if err != nil </span><span class="cov0" title="0">{
                                log.Printf("Error executing template: %v", err)
                                http.Error(w, "Error executing template", http.StatusInternalServerError)
                                return
                        }</span>
                }
        } else<span class="cov8" title="1"> if r.Method == "POST" </span><span class="cov8" title="1">{
                err := r.ParseForm()
                if err != nil </span><span class="cov0" title="0">{
                        log.Printf("Error parsing form: %v", err)
                        http.Error(w, "Error parsing form", http.StatusBadRequest)
                        return
                }</span>
                <span class="cov8" title="1">indexStr := r.Form.Get("index")
                index, err := strconv.Atoi(indexStr)
                if err != nil </span><span class="cov8" title="1">{
                        log.Printf("Invalid index: %v", err)
                        http.Error(w, "Invalid index", http.StatusBadRequest)
                        return
                }</span>
                <span class="cov8" title="1">profiles := middleware.ReadProfiles()
                if index &gt;= 0 &amp;&amp; index &lt; len(profiles) </span><span class="cov8" title="1">{
                        profiles = append(profiles[:index], profiles[index+1:]...)
                }</span>
                <span class="cov8" title="1">err = middleware.WriteProfiles(profiles)
                if err != nil </span><span class="cov0" title="0">{
                        log.Printf("Error writing profiles: %v", err)
                        http.Error(w, "Error writing profiles", http.StatusInternalServerError)
                        return
                }</span>
                <span class="cov8" title="1">log.Println("Profile deleted successfully")
                http.Redirect(w, r, "/profiles", http.StatusSeeOther)</span>
        }
}

// Handle reset profiles
func ResetProfilesHandler(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        log.Println("Handling reset profiles")
        if r.Method == "GET" </span><span class="cov8" title="1">{
                middleware.RenderTemplateSimple(w, "reset_profiles.html", nil)
        }</span> else<span class="cov8" title="1"> if r.Method == "POST" </span><span class="cov8" title="1">{
                err := middleware.WriteProfiles([]middleware.Profile{})
                if err != nil </span><span class="cov0" title="0">{
                        log.Printf("Error writing profiles: %v", err)
                        http.Error(w, "Error writing profiles", http.StatusInternalServerError)
                        return
                }</span>
                <span class="cov8" title="1">log.Println("Profiles reset successfully")
                http.Redirect(w, r, "/profiles", http.StatusSeeOther)</span>
        }
}
</pre>
		
		<pre class="file" id="file3" style="display: none">package handlers

import (
        "encoding/json"
        "html/template"
        "io"
        "log"
        "net/http"
        "strconv"
        "strings"

        "github.com/microcosm-cc/bluemonday"
        "github.com/russross/blackfriday/v2"

        "llm-tournament/middleware"
)

// Handle prompt list page
func PromptListHandler(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        log.Println("Handling prompt list page")
        orderFilter := r.FormValue("order_filter")
        profileFilter := r.FormValue("profile_filter")
        searchQuery := r.FormValue("search_query")

        orderFilterInt := 0
        if orderFilter != "" </span><span class="cov8" title="1">{
                var err error
                orderFilterInt, err = strconv.Atoi(orderFilter)
                if err != nil </span><span class="cov8" title="1">{
                        log.Printf("Invalid order filter: %v", err)
                        http.Error(w, "Invalid order filter", http.StatusBadRequest)
                        return
                }</span>
        }

        <span class="cov8" title="1">funcMap := template.FuncMap{
                "inc": func(i int) int </span><span class="cov8" title="1">{
                        return i + 1
                }</span>,
                "markdown": func(text string) template.HTML <span class="cov8" title="1">{
                        unsafe := blackfriday.Run([]byte(text), blackfriday.WithNoExtensions())
                        html := bluemonday.UGCPolicy().SanitizeBytes(unsafe)
                        return template.HTML(html)
                }</span>,
                "string": func(i int) string <span class="cov0" title="0">{
                        return strconv.Itoa(i)
                }</span>,
                "tolower":  strings.ToLower,
                "contains": strings.Contains,
        }
        <span class="cov8" title="1">funcMap["json"] = func(v interface{}) (string, error) </span><span class="cov8" title="1">{
                b, err := json.Marshal(v)
                return string(b), err
        }</span>
        <span class="cov8" title="1">pageName := "Prompts"
        t, err := template.New("prompt_list.html").Funcs(funcMap).ParseFiles("templates/prompt_list.html", "templates/nav.html")
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("Error parsing template: %v", err)
                return
        }</span>
        <span class="cov8" title="1">if t == nil </span><span class="cov0" title="0">{
                log.Println("Error parsing template")
                http.Error(w, "Error parsing template", http.StatusInternalServerError)
                return
        }</span>

        <span class="cov8" title="1">suites, err := middleware.ListPromptSuites()
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("Error listing prompt suites: %v", err)
                http.Error(w, "Error listing prompt suites", http.StatusInternalServerError)
                return
        }</span>

        <span class="cov8" title="1">currentSuite := middleware.GetCurrentSuiteName()
        var prompts []middleware.Prompt
        if currentSuite == "" </span><span class="cov0" title="0">{
                currentSuite = "default"
        }</span>
        <span class="cov8" title="1">prompts, err = middleware.ReadPromptSuite(currentSuite)
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("Error reading prompt suite: %v", err)
                http.Error(w, "Error reading prompt suite", http.StatusInternalServerError)
                return
        }</span>
        <span class="cov8" title="1">if len(prompts) == 0 &amp;&amp; currentSuite == "default" </span><span class="cov0" title="0">{
                prompts, err = middleware.ReadPromptSuite("default")
                if err != nil </span><span class="cov0" title="0">{
                        log.Printf("Error reading default prompt suite: %v", err)
                        http.Error(w, "Error reading default prompt suite", http.StatusInternalServerError)
                        return
                }</span>
        }
        <span class="cov8" title="1">promptTexts := make([]middleware.Prompt, len(prompts))
        promptIndices := make([]int, len(prompts))
        for i, prompt := range prompts </span><span class="cov8" title="1">{
                promptTexts[i] = prompt
                promptIndices[i] = i + 1
        }</span>

        <span class="cov8" title="1">profiles := middleware.ReadProfiles()
        err = t.Execute(w, struct {
                PageName      string
                Prompts       []middleware.Prompt
                PromptIndices []int
                Profiles      []middleware.Profile
                OrderFilter   int
                ProfileFilter string
                SearchQuery   string
                Suites        []string
                CurrentSuite  string
        }{
                PageName:      pageName,
                Prompts:       promptTexts,
                PromptIndices: promptIndices,
                Profiles:      profiles,
                OrderFilter:   orderFilterInt,
                ProfileFilter: profileFilter,
                SearchQuery:   searchQuery,
                Suites:        suites,
                CurrentSuite:  currentSuite,
        })
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("Error executing template: %v", err)
                return
        }</span>
        <span class="cov8" title="1">log.Println("Prompt list page rendered successfully")</span>
}

// Handle update prompts order
func UpdatePromptsOrderHandler(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        log.Println("Handling update prompts order")
        err := r.ParseForm()
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("Error parsing form: %v", err)
                http.Error(w, "Error parsing form", http.StatusBadRequest)
                return
        }</span>
        <span class="cov8" title="1">orderStr := r.Form.Get("order")
        if orderStr == "" </span><span class="cov8" title="1">{
                log.Println("Order cannot be empty")
                http.Error(w, "Order cannot be empty", http.StatusBadRequest)
                return
        }</span>
        <span class="cov8" title="1">var order []int
        err = json.Unmarshal([]byte(orderStr), &amp;order)
        if err != nil </span><span class="cov8" title="1">{
                log.Printf("Error parsing order: %v", err)
                http.Error(w, "Error parsing order", http.StatusBadRequest)
                return
        }</span>
        <span class="cov8" title="1">middleware.UpdatePromptsOrder(order)
        http.Redirect(w, r, "/prompts", http.StatusSeeOther)</span>
}

// Handle add prompt
func AddPromptHandler(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        log.Println("Handling add prompt")
        err := r.ParseForm()
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("Error parsing form: %v", err)
                http.Error(w, "Error parsing form", http.StatusBadRequest)
                return
        }</span>
        <span class="cov8" title="1">promptText := r.Form.Get("prompt")
        if promptText == "" </span><span class="cov8" title="1">{
                log.Println("Prompt text cannot be empty")
                http.Error(w, "Prompt text cannot be empty", http.StatusBadRequest)
                return
        }</span>
        <span class="cov8" title="1">solutionText := r.Form.Get("solution")
        profile := r.Form.Get("profile")

        currentSuite := middleware.GetCurrentSuiteName()
        if currentSuite == "" </span><span class="cov0" title="0">{
                currentSuite = "default"
        }</span>

        <span class="cov8" title="1">prompts, err := middleware.ReadPromptSuite(currentSuite)
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("Error reading prompt suite: %v", err)
                http.Error(w, "Error reading prompt suite", http.StatusInternalServerError)
                return
        }</span>

        <span class="cov8" title="1">prompts = append(prompts, middleware.Prompt{Text: promptText, Solution: solutionText, Profile: profile})
        err = middleware.WritePromptSuite(currentSuite, prompts)
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("Error writing prompts: %v", err)
                http.Error(w, "Error writing prompts", http.StatusInternalServerError)
                return
        }</span>
        <span class="cov8" title="1">log.Println("Prompt added successfully")
        middleware.BroadcastResults()
        http.Redirect(w, r, "/prompts", http.StatusSeeOther)</span>
}

// Handle export prompts
func ExportPromptsHandler(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        log.Println("Handling export prompts")
        prompts := middleware.ReadPrompts()

        // Convert prompts to JSON
        jsonData, err := json.MarshalIndent(prompts, "", "  ")
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("Error marshaling prompts to JSON: %v", err)
                http.Error(w, "Error creating JSON export", http.StatusInternalServerError)
                return
        }</span>

        // Set headers for JSON download
        <span class="cov8" title="1">w.Header().Set("Content-Type", "application/json")
        w.Header().Set("Content-Disposition", "attachment;filename=prompts.json")

        // Write JSON to response
        _, err = w.Write(jsonData)
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("Error writing response: %v", err)
                http.Error(w, "Error writing response", http.StatusInternalServerError)
                return
        }</span>
        <span class="cov8" title="1">log.Println("Prompts exported successfully as JSON")</span>
}

// Handle import prompts
func ImportPromptsHandler(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        log.Println("Handling import prompts")
        if r.Method == "POST" </span><span class="cov8" title="1">{
                file, _, err := r.FormFile("prompts_file")
                if err != nil </span><span class="cov8" title="1">{
                        log.Printf("Error uploading file: %v", err)
                        http.Redirect(w, r, "/import_error", http.StatusSeeOther)
                        return
                }</span>
                <span class="cov8" title="1">defer file.Close()

                if file == nil </span><span class="cov0" title="0">{
                        log.Println("No file provided")
                        http.Redirect(w, r, "/import_error", http.StatusSeeOther)
                        return
                }</span>

                // Read the file content
                <span class="cov8" title="1">data, err := io.ReadAll(file)
                if err != nil </span><span class="cov0" title="0">{
                        log.Printf("Error reading file: %v", err)
                        http.Error(w, "Error reading file", http.StatusInternalServerError)
                        return
                }</span>

                // Parse JSON data
                <span class="cov8" title="1">var prompts []middleware.Prompt
                err = json.Unmarshal(data, &amp;prompts)
                if err != nil </span><span class="cov8" title="1">{
                        log.Printf("Error parsing JSON: %v", err)
                        http.Redirect(w, r, "/import_error", http.StatusSeeOther)
                        return
                }</span>

                // Validate imported prompts
                <span class="cov8" title="1">if len(prompts) == 0 </span><span class="cov8" title="1">{
                        log.Println("No prompts found in JSON file")
                        http.Redirect(w, r, "/import_error", http.StatusSeeOther)
                        return
                }</span>

                // Write the imported prompts
                <span class="cov8" title="1">err = middleware.WritePrompts(prompts)
                if err != nil </span><span class="cov0" title="0">{
                        log.Printf("Error writing prompts: %v", err)
                        http.Error(w, "Error writing prompts", http.StatusInternalServerError)
                        return
                }</span>

                <span class="cov8" title="1">log.Println("Prompts imported successfully from JSON")
                middleware.BroadcastResults()
                http.Redirect(w, r, "/prompts", http.StatusSeeOther)</span>
        } else<span class="cov8" title="1"> {
                middleware.RenderTemplateSimple(w, "import_prompts.html", nil)
        }</span>
}

// Handle import results
func ImportResultsHandler(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        log.Println("Handling import results")
        if r.Method == "POST" </span><span class="cov8" title="1">{
                file, _, err := r.FormFile("results_file")
                if err != nil </span><span class="cov8" title="1">{
                        log.Printf("Error uploading file: %v", err)
                        http.Redirect(w, r, "/import_error", http.StatusSeeOther)
                        return
                }</span>
                <span class="cov8" title="1">defer file.Close()

                if file == nil </span><span class="cov0" title="0">{
                        log.Println("No file provided")
                        http.Redirect(w, r, "/import_error", http.StatusSeeOther)
                        return
                }</span>

                // Read the file content
                <span class="cov8" title="1">data, err := io.ReadAll(file)
                if err != nil </span><span class="cov0" title="0">{
                        log.Printf("Error reading file: %v", err)
                        http.Error(w, "Error reading file", http.StatusInternalServerError)
                        return
                }</span>

                // Parse JSON data
                <span class="cov8" title="1">var results map[string]middleware.Result
                err = json.Unmarshal(data, &amp;results)
                if err != nil </span><span class="cov8" title="1">{
                        log.Printf("Error parsing JSON: %v", err)
                        http.Redirect(w, r, "/import_error", http.StatusSeeOther)
                        return
                }</span>

                // Validate imported results
                <span class="cov8" title="1">if len(results) == 0 </span><span class="cov8" title="1">{
                        log.Println("No results found in JSON file")
                        http.Redirect(w, r, "/import_error", http.StatusSeeOther)
                        return
                }</span>

                // Ensure scores arrays match prompts length
                <span class="cov8" title="1">prompts := middleware.ReadPrompts()
                for model, result := range results </span><span class="cov8" title="1">{
                        if len(result.Scores) &lt; len(prompts) </span><span class="cov8" title="1">{
                                newScores := make([]int, len(prompts))
                                copy(newScores, result.Scores)
                                result.Scores = newScores
                                results[model] = result
                        }</span>
                }

                // Write the imported results
                <span class="cov8" title="1">suiteName := middleware.GetCurrentSuiteName()
                err = middleware.WriteResults(suiteName, results)
                if err != nil </span><span class="cov0" title="0">{
                        log.Printf("Error writing results: %v", err)
                        http.Error(w, "Error writing results", http.StatusInternalServerError)
                        return
                }</span>

                <span class="cov8" title="1">log.Println("Results imported successfully from JSON")
                middleware.BroadcastResults()
                http.Redirect(w, r, "/results", http.StatusSeeOther)</span>
        } else<span class="cov8" title="1"> {
                middleware.RenderTemplateSimple(w, "import_results.html", nil)
        }</span>
}

// Handle edit prompt
func EditPromptHandler(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        log.Println("Handling edit prompt")
        if r.Method == "GET" </span><span class="cov8" title="1">{
                err := r.ParseForm()
                if err != nil </span><span class="cov0" title="0">{
                        log.Printf("Error parsing form: %v", err)
                        http.Error(w, "Error parsing form", http.StatusBadRequest)
                        return
                }</span>
                <span class="cov8" title="1">indexStr := r.Form.Get("index")
                index, err := strconv.Atoi(indexStr)
                if err != nil </span><span class="cov8" title="1">{
                        log.Printf("Invalid index: %v", err)
                        http.Error(w, "Invalid index", http.StatusBadRequest)
                        return
                }</span>
                <span class="cov8" title="1">prompts := middleware.ReadPrompts()
                if index &gt;= 0 &amp;&amp; index &lt; len(prompts) </span><span class="cov8" title="1">{
                        funcMap := template.FuncMap{
                                "markdown": func(text string) template.HTML </span><span class="cov8" title="1">{
                                        unsafe := blackfriday.Run([]byte(text), blackfriday.WithNoExtensions())
                                        html := bluemonday.UGCPolicy().SanitizeBytes(unsafe)
                                        return template.HTML(html)
                                }</span>,
                        }
                        <span class="cov8" title="1">profiles := middleware.ReadProfiles()
                        t, err := template.New("edit_prompt.html").Funcs(funcMap).ParseFiles("templates/edit_prompt.html")
                        if err != nil </span><span class="cov0" title="0">{
                                log.Printf("Error parsing template: %v", err)
                                http.Error(w, "Error parsing template", http.StatusInternalServerError)
                                return
                        }</span>
                        <span class="cov8" title="1">err = t.Execute(w, struct {
                                Index    int
                                Prompt   middleware.Prompt
                                Profiles []middleware.Profile
                        }{
                                Index:    index,
                                Prompt:   prompts[index],
                                Profiles: profiles,
                        })
                        if err != nil </span><span class="cov0" title="0">{
                                log.Printf("Error executing template: %v", err)
                                http.Error(w, "Error executing template", http.StatusInternalServerError)
                                return
                        }</span>
                }
        } else<span class="cov8" title="1"> if r.Method == "POST" </span><span class="cov8" title="1">{
                err := r.ParseForm()
                if err != nil </span><span class="cov0" title="0">{
                        log.Printf("Error parsing form: %v", err)
                        http.Error(w, "Error parsing form", http.StatusBadRequest)
                        return
                }</span>
                <span class="cov8" title="1">indexStr := r.Form.Get("index")
                index, err := strconv.Atoi(indexStr)
                if err != nil </span><span class="cov8" title="1">{
                        log.Printf("Invalid index: %v", err)
                        http.Error(w, "Invalid index", http.StatusBadRequest)
                        return
                }</span>
                <span class="cov8" title="1">editedPrompt := r.Form.Get("prompt")
                editedSolution := r.Form.Get("solution")
                editedProfile := r.Form.Get("profile")
                if editedPrompt == "" </span><span class="cov8" title="1">{
                        log.Println("Prompt text cannot be empty")
                        http.Error(w, "Prompt text cannot be empty", http.StatusBadRequest)
                        return
                }</span>
                <span class="cov8" title="1">prompts := middleware.ReadPrompts()
                if index &gt;= 0 &amp;&amp; index &lt; len(prompts) </span><span class="cov8" title="1">{
                        prompts[index].Text = editedPrompt
                        prompts[index].Solution = editedSolution
                        prompts[index].Profile = editedProfile
                }</span>
                <span class="cov8" title="1">err = middleware.WritePrompts(prompts)
                if err != nil </span><span class="cov0" title="0">{
                        log.Printf("Error writing prompts: %v", err)
                        http.Error(w, "Error writing prompts", http.StatusInternalServerError)
                        return
                }</span>
                <span class="cov8" title="1">log.Println("Prompt edited successfully")
                middleware.BroadcastResults()
                http.Redirect(w, r, "/prompts", http.StatusSeeOther)</span>
        }
}

// Handle bulk delete prompts page
func BulkDeletePromptsPageHandler(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        log.Println("Handling bulk delete prompts page")
        if r.Method != "GET" </span><span class="cov8" title="1">{
                http.Error(w, "Method not allowed", http.StatusMethodNotAllowed)
                return
        }</span>

        <span class="cov8" title="1">indicesStr := r.URL.Query().Get("indices")
        if indicesStr == "" </span><span class="cov8" title="1">{
                log.Println("No indices provided for deletion")
                http.Error(w, "No indices provided for deletion", http.StatusBadRequest)
                return
        }</span>

        <span class="cov8" title="1">var indices []int
        err := json.Unmarshal([]byte(indicesStr), &amp;indices)
        if err != nil </span><span class="cov8" title="1">{
                log.Printf("Error unmarshalling indices: %v", err)
                http.Error(w, "Error unmarshalling indices", http.StatusBadRequest)
                return
        }</span>

        <span class="cov8" title="1">prompts := middleware.ReadPrompts()
        var selectedPrompts []middleware.Prompt
        for _, index := range indices </span><span class="cov8" title="1">{
                if index &gt;= 0 &amp;&amp; index &lt; len(prompts) </span><span class="cov8" title="1">{
                        selectedPrompts = append(selectedPrompts, prompts[index])
                }</span>
        }

        <span class="cov8" title="1">funcMap := template.FuncMap{
                "markdown": func(text string) template.HTML </span><span class="cov8" title="1">{
                        unsafe := blackfriday.Run([]byte(text), blackfriday.WithNoExtensions())
                        html := bluemonday.UGCPolicy().SanitizeBytes(unsafe)
                        return template.HTML(html)
                }</span>,
        }

        <span class="cov8" title="1">t, err := template.New("bulk_delete_prompts.html").Funcs(funcMap).ParseFiles("templates/bulk_delete_prompts.html")
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("Error parsing template: %v", err)
                http.Error(w, "Error parsing template", http.StatusInternalServerError)
                return
        }</span>

        <span class="cov8" title="1">err = t.Execute(w, struct {
                Indices string
                Prompts []middleware.Prompt
        }{
                Indices: indicesStr,
                Prompts: selectedPrompts,
        })
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("Error executing template: %v", err)
                http.Error(w, "Error executing template", http.StatusInternalServerError)
                return
        }</span>
}

// Handle bulk delete prompts
func BulkDeletePromptsHandler(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        log.Println("Handling bulk delete prompts")
        if r.Method != "POST" </span><span class="cov8" title="1">{
                http.Error(w, "Method not allowed", http.StatusMethodNotAllowed)
                return
        }</span>

        <span class="cov8" title="1">var request struct {
                Indices []int `json:"indices"`
        }

        err := json.NewDecoder(r.Body).Decode(&amp;request)
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("Error decoding request: %v", err)
                http.Error(w, "Error decoding request", http.StatusBadRequest)
                return
        }</span>

        <span class="cov8" title="1">indices := request.Indices

        prompts := middleware.ReadPrompts()
        if len(prompts) == 0 </span><span class="cov0" title="0">{
                log.Println("No prompts to delete")
                http.Error(w, "No prompts to delete", http.StatusBadRequest)
                return
        }</span>

        <span class="cov8" title="1">if len(indices) == 0 </span><span class="cov8" title="1">{
                log.Println("No indices provided for deletion")
                http.Error(w, "No indices provided for deletion", http.StatusBadRequest)
                return
        }</span>

        <span class="cov8" title="1">var filteredPrompts []middleware.Prompt
        for i, prompt := range prompts </span><span class="cov8" title="1">{
                found := false
                for _, index := range indices </span><span class="cov8" title="1">{
                        if i == index </span><span class="cov8" title="1">{
                                found = true
                                break</span>
                        }
                }
                <span class="cov8" title="1">if !found </span><span class="cov8" title="1">{
                        filteredPrompts = append(filteredPrompts, prompt)
                }</span>
        }

        <span class="cov8" title="1">err = middleware.WritePrompts(filteredPrompts)
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("Error writing prompts: %v", err)
                http.Error(w, "Error writing prompts", http.StatusInternalServerError)
                return
        }</span>

        <span class="cov8" title="1">log.Println("Prompts deleted successfully")
        middleware.BroadcastResults()
        w.WriteHeader(http.StatusOK)</span>
}

// Handle delete prompt
func DeletePromptHandler(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        log.Println("Handling delete prompt")
        if r.Method == "GET" </span><span class="cov8" title="1">{
                err := r.ParseForm()
                if err != nil </span><span class="cov0" title="0">{
                        log.Printf("Error parsing form: %v", err)
                        http.Error(w, "Error parsing form", http.StatusBadRequest)
                        return
                }</span>
                <span class="cov8" title="1">indexStr := r.Form.Get("index")
                index, err := strconv.Atoi(indexStr)
                if err != nil </span><span class="cov8" title="1">{
                        log.Printf("Invalid index: %v", err)
                        http.Error(w, "Invalid index", http.StatusBadRequest)
                        return
                }</span>
                <span class="cov8" title="1">prompts := middleware.ReadPrompts()
                if index &gt;= 0 &amp;&amp; index &lt; len(prompts) </span><span class="cov8" title="1">{
                        funcMap := template.FuncMap{
                                "markdown": func(text string) template.HTML </span><span class="cov8" title="1">{
                                        unsafe := blackfriday.Run([]byte(text), blackfriday.WithNoExtensions())
                                        html := bluemonday.UGCPolicy().SanitizeBytes(unsafe)
                                        return template.HTML(html)
                                }</span>,
                        }
                        <span class="cov8" title="1">t, err := template.New("delete_prompt.html").Funcs(funcMap).ParseFiles("templates/delete_prompt.html")
                        if err != nil </span><span class="cov0" title="0">{
                                log.Printf("Error parsing template: %v", err)
                                http.Error(w, "Error parsing template", http.StatusInternalServerError)
                                return
                        }</span>
                        <span class="cov8" title="1">err = t.Execute(w, struct {
                                Index  int
                                Prompt middleware.Prompt
                        }{
                                Index:  index,
                                Prompt: prompts[index],
                        })
                        if err != nil </span><span class="cov0" title="0">{
                                log.Printf("Error executing template: %v", err)
                                http.Error(w, "Error executing template", http.StatusInternalServerError)
                                return
                        }</span>
                }
        } else<span class="cov8" title="1"> if r.Method == "POST" </span><span class="cov8" title="1">{
                err := r.ParseForm()
                if err != nil </span><span class="cov0" title="0">{
                        log.Printf("Error parsing form: %v", err)
                        http.Error(w, "Error parsing form", http.StatusBadRequest)
                        return
                }</span>
                <span class="cov8" title="1">indexStr := r.Form.Get("index")
                index, err := strconv.Atoi(indexStr)
                if err != nil </span><span class="cov8" title="1">{
                        log.Printf("Invalid index: %v", err)
                        http.Error(w, "Invalid index", http.StatusBadRequest)
                        return
                }</span>
                <span class="cov8" title="1">prompts := middleware.ReadPrompts()
                if index &gt;= 0 &amp;&amp; index &lt; len(prompts) </span><span class="cov8" title="1">{
                        prompts = append(prompts[:index], prompts[index+1:]...)
                }</span>
                <span class="cov8" title="1">err = middleware.WritePrompts(prompts)
                if err != nil </span><span class="cov0" title="0">{
                        log.Printf("Error writing prompts: %v", err)
                        http.Error(w, "Error writing prompts", http.StatusInternalServerError)
                        return
                }</span>
                <span class="cov8" title="1">log.Println("Prompt deleted successfully")
                middleware.BroadcastResults()
                http.Redirect(w, r, "/prompts", http.StatusSeeOther)</span>
        }
}

// Handle move prompt
func MovePromptHandler(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        log.Println("Handling move prompt")
        if r.Method == "GET" </span><span class="cov8" title="1">{
                err := r.ParseForm()
                if err != nil </span><span class="cov0" title="0">{
                        log.Printf("Error parsing form: %v", err)
                        http.Error(w, "Error parsing form", http.StatusBadRequest)
                        return
                }</span>
                <span class="cov8" title="1">indexStr := r.Form.Get("index")
                index, err := strconv.Atoi(indexStr)
                if err != nil </span><span class="cov8" title="1">{
                        log.Printf("Invalid index: %v", err)
                        http.Error(w, "Invalid index", http.StatusBadRequest)
                        return
                }</span>
                <span class="cov8" title="1">prompts := middleware.ReadPrompts()
                if index &gt;= 0 &amp;&amp; index &lt; len(prompts) </span><span class="cov0" title="0">{
                        funcMap := template.FuncMap{
                                "inc": func(i int) int </span><span class="cov0" title="0">{
                                        return i + 1
                                }</span>,
                                "markdown": func(text string) template.HTML <span class="cov0" title="0">{
                                        unsafe := blackfriday.Run([]byte(text), blackfriday.WithNoExtensions())
                                        html := bluemonday.UGCPolicy().SanitizeBytes(unsafe)
                                        return template.HTML(html)
                                }</span>,
                        }
                        <span class="cov0" title="0">t, err := template.New("move_prompt.html").Funcs(funcMap).ParseFiles("templates/move_prompt.html")
                        if err != nil </span><span class="cov0" title="0">{
                                log.Printf("Error parsing template: %v", err)
                                http.Error(w, "Error parsing template", http.StatusInternalServerError)
                                return
                        }</span>
                        <span class="cov0" title="0">err = t.Execute(w, struct {
                                Index   int
                                Prompt  string
                                Prompts []middleware.Prompt
                        }{
                                Index:   index,
                                Prompt:  prompts[index].Text,
                                Prompts: prompts,
                        })
                        if err != nil </span><span class="cov0" title="0">{
                                log.Printf("Error executing template: %v", err)
                                http.Error(w, "Error executing template", http.StatusInternalServerError)
                                return
                        }</span>
                }
        } else<span class="cov8" title="1"> if r.Method == "POST" </span><span class="cov8" title="1">{
                err := r.ParseForm()
                if err != nil </span><span class="cov0" title="0">{
                        log.Printf("Error parsing form: %v", err)
                        http.Error(w, "Error parsing form", http.StatusBadRequest)
                        return
                }</span>
                <span class="cov8" title="1">indexStr := r.Form.Get("index")
                index, err := strconv.Atoi(indexStr)
                if err != nil </span><span class="cov8" title="1">{
                        log.Printf("Invalid index: %v", err)
                        http.Error(w, "Invalid index", http.StatusBadRequest)
                        return
                }</span>
                <span class="cov8" title="1">newIndexStr := r.Form.Get("new_index")
                newIndex, err := strconv.Atoi(newIndexStr)
                if err != nil </span><span class="cov8" title="1">{
                        log.Printf("Invalid new index: %v", err)
                        http.Error(w, "Invalid new index", http.StatusBadRequest)
                        return
                }</span>
                <span class="cov8" title="1">prompts := middleware.ReadPrompts()
                if index &gt;= 0 &amp;&amp; index &lt; len(prompts) &amp;&amp; newIndex &gt;= 0 &amp;&amp; newIndex &lt;= len(prompts) </span><span class="cov8" title="1">{
                        prompt := prompts[index]
                        prompts = append(prompts[:index], prompts[index+1:]...)
                        if newIndex &gt; index </span><span class="cov8" title="1">{
                                newIndex--
                        }</span>
                        <span class="cov8" title="1">prompts = append(prompts[:newIndex], append([]middleware.Prompt{prompt}, prompts[newIndex:]...)...)</span>
                }
                <span class="cov8" title="1">err = middleware.WritePrompts(prompts)
                if err != nil </span><span class="cov0" title="0">{
                        log.Printf("Error writing prompts: %v", err)
                        http.Error(w, "Error writing prompts", http.StatusInternalServerError)
                        return
                }</span>
                <span class="cov8" title="1">log.Println("Prompt moved successfully")
                middleware.BroadcastResults()
                http.Redirect(w, r, "/prompts", http.StatusSeeOther)</span>
        }
}

// Handle reset prompts
func ResetPromptsHandler(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        log.Println("Handling reset prompts")
        if r.Method == "GET" </span><span class="cov8" title="1">{
                middleware.RenderTemplateSimple(w, "reset_prompts.html", nil)
        }</span> else<span class="cov8" title="1"> if r.Method == "POST" </span><span class="cov8" title="1">{
                err := middleware.WritePrompts([]middleware.Prompt{})
                if err != nil </span><span class="cov0" title="0">{
                        log.Printf("Error writing prompts: %v", err)
                        http.Error(w, "Error writing prompts", http.StatusInternalServerError)
                        return
                }</span>
                <span class="cov8" title="1">log.Println("Prompts reset successfully")
                middleware.BroadcastResults()
                http.Redirect(w, r, "/prompts", http.StatusSeeOther)</span>
        }
}
</pre>
		
		<pre class="file" id="file4" style="display: none">package handlers

import (
        "encoding/json"
        "html/template"
        "io"
        "log"
        "math/rand"
        "net/http"
        "sort"
        "strconv"
        "strings"
        "time"

        "llm-tournament/middleware"
        "llm-tournament/templates"
)

// min returns the smaller of x or y
func min(x, y int) int <span class="cov8" title="1">{
        if x &lt; y </span><span class="cov8" title="1">{
                return x
        }</span>
        <span class="cov8" title="1">return y</span>
}

// max returns the larger of x or y
func max(x, y int) int <span class="cov8" title="1">{
        if x &gt; y </span><span class="cov8" title="1">{
                return x
        }</span>
        <span class="cov8" title="1">return y</span>
}

// initRand returns a new random number generator seeded with the current time
func initRand() *rand.Rand <span class="cov8" title="1">{
        source := rand.NewSource(time.Now().UnixNano())
        return rand.New(source)
}</span>

// GroupedPrompt represents a prompt with its profile information
type GroupedPrompt struct {
        Index       int
        Text        string
        ProfileID   string
        ProfileName string
}

// Handle results page
func ResultsHandler(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        log.Println("Handling results page")
        prompts := middleware.ReadPrompts()
        results := middleware.ReadResults()

        // Group prompts by profile
        var orderedPrompts []GroupedPrompt

        // Get all profiles first (to include empty ones)
        profiles := middleware.ReadProfiles()

        // Get profile groups using the utility function
        profileGroups, profileMap := middleware.GetProfileGroups(prompts, profiles)

        // Check if we have any uncategorized prompts
        hasUncategorized := false
        for _, prompt := range prompts </span><span class="cov8" title="1">{
                if prompt.Profile == "" </span><span class="cov8" title="1">{
                        hasUncategorized = true
                        break</span>
                }
        }

        // Add a group for prompts with no profile only if needed
        <span class="cov8" title="1">if hasUncategorized </span><span class="cov8" title="1">{
                noProfileGroup := &amp;middleware.ProfileGroup{
                        ID:    "none",
                        Name:  "Uncategorized",
                        Color: "hsl(0, 0%, 50%)",
                }
                profileGroups = append(profileGroups, noProfileGroup)
                profileMap[""] = noProfileGroup
        }</span>

        // Process prompts and assign them to profile groups
        <span class="cov8" title="1">currentCol := 0
        for i, prompt := range prompts </span><span class="cov8" title="1">{
                profileName := prompt.Profile

                group, exists := profileMap[profileName]
                if !exists </span><span class="cov0" title="0">{
                        // Skip if group doesn't exist and we don't have uncategorized group
                        if _, hasUncategorized := profileMap[""]; !hasUncategorized </span><span class="cov0" title="0">{
                                continue</span>
                        }
                        <span class="cov0" title="0">group = profileMap[""]</span>
                }

                <span class="cov8" title="1">if group.StartCol == -1 </span><span class="cov8" title="1">{
                        group.StartCol = currentCol
                }</span>
                <span class="cov8" title="1">group.EndCol = currentCol

                orderedPrompts = append(orderedPrompts, GroupedPrompt{
                        Index:       i,
                        Text:        prompt.Text,
                        ProfileID:   group.ID,
                        ProfileName: profileName,
                })

                currentCol++</span>
        }

        <span class="cov8" title="1">log.Println("Calculating total scores for each model")
        // Calculate total scores for each model
        modelScores := make(map[string]int)
        for model, result := range results </span><span class="cov8" title="1">{
                totalScore := 0
                for _, score := range result.Scores </span><span class="cov8" title="1">{
                        totalScore += score
                }</span>
                <span class="cov8" title="1">modelScores[model] = totalScore</span>
        }

        <span class="cov8" title="1">log.Println("Sorting models by score in descending order")
        // Sort models by score in descending order
        models := make([]string, 0, len(results))
        for model := range results </span><span class="cov8" title="1">{
                models = append(models, model)
        }</span>
        <span class="cov8" title="1">if len(models) == 0 </span><span class="cov8" title="1">{
                // If no results exist, get models from somewhere else if needed
                // This is just a fallback - you may need to adjust based on your data source
                models = []string{"Model1", "Model2"} // Example fallback
        }</span>
        <span class="cov8" title="1">sort.Slice(models, func(i, j int) bool </span><span class="cov8" title="1">{
                return modelScores[models[i]] &gt; modelScores[models[j]]
        }</span>)
        <span class="cov8" title="1">log.Printf("Sorted models: %v", models)

        modelFilter := r.FormValue("model_filter")
        searchQuery := strings.ToLower(r.FormValue("search"))

        filteredResults := make(map[string]middleware.Result)
        for model, result := range results </span><span class="cov8" title="1">{
                // Apply model filter if specified
                if modelFilter != "" &amp;&amp; model != modelFilter </span><span class="cov0" title="0">{
                        continue</span>
                }
                // Apply search filter if specified
                <span class="cov8" title="1">if searchQuery != "" &amp;&amp; !strings.Contains(strings.ToLower(model), searchQuery) </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov8" title="1">filteredResults[model] = result</span>
        }

        <span class="cov8" title="1">pageName := templates.PageNameResults
        t, err := template.New("results.html").Funcs(templates.FuncMap).ParseFiles("templates/results.html", "templates/nav.html")
        if err != nil </span><span class="cov8" title="1">{
                log.Printf("Error parsing template: %v", err)
                http.Error(w, "Error parsing template: "+err.Error(), http.StatusInternalServerError)
                return
        }</span>
        <span class="cov8" title="1">if t == nil </span><span class="cov0" title="0">{
                log.Println("Error parsing template")
                http.Error(w, "Error parsing template", http.StatusInternalServerError)
                return
        }</span>
        <span class="cov8" title="1">promptTexts := make([]string, len(prompts))
        for i, prompt := range prompts </span><span class="cov8" title="1">{
                promptTexts[i] = prompt.Text
        }</span>
        <span class="cov8" title="1">resultsForTemplate := make(map[string]middleware.Result)
        for model, result := range filteredResults </span><span class="cov8" title="1">{
                // Initialize scores array if nil
                if result.Scores == nil </span><span class="cov0" title="0">{
                        result.Scores = make([]int, len(prompts))
                }</span>

                // Ensure scores array matches prompts length
                <span class="cov8" title="1">if len(result.Scores) != len(prompts) </span><span class="cov0" title="0">{
                        newScores := make([]int, len(prompts))
                        copy(newScores, result.Scores)
                        result.Scores = newScores
                }</span>

                // Ensure all scores are valid (0-100)
                <span class="cov8" title="1">for i, score := range result.Scores </span><span class="cov8" title="1">{
                        if score &lt; 0 || score &gt; 100 </span><span class="cov0" title="0">{
                                result.Scores[i] = 0
                        }</span>
                }

                // Create a new Result struct to ensure proper initialization
                <span class="cov8" title="1">resultsForTemplate[model] = middleware.Result{
                        Scores: result.Scores,
                }</span>
        }
        <span class="cov8" title="1">modelPassPercentages := make(map[string]float64)
        modelTotalScores := make(map[string]int)
        promptIndices := make([]int, len(prompts))
        for i := range prompts </span><span class="cov8" title="1">{
                promptIndices[i] = i + 1
        }</span>
        <span class="cov8" title="1">for model, result := range filteredResults </span><span class="cov8" title="1">{
                totalScore := 0
                for _, score := range result.Scores </span><span class="cov8" title="1">{
                        totalScore += score
                }</span>
                <span class="cov8" title="1">modelPassPercentages[model] = float64(totalScore) / float64(len(prompts)*100) * 100
                modelTotalScores[model] = totalScore</span>
        }

        // Log the data we're about to send to the template for debugging
        <span class="cov8" title="1">if len(models) &gt; 0 &amp;&amp; len(promptTexts) &gt; 0 </span><span class="cov8" title="1">{
                log.Printf("First model: %s, scores: %v", models[0], resultsForTemplate[models[0]].Scores)
        }</span>

        <span class="cov8" title="1">templateData := struct {
                PageName        string
                Prompts         []string
                Results         map[string]middleware.Result
                Models          []string
                PassPercentages map[string]float64
                ModelFilter     string
                TotalScores     map[string]int
                PromptIndices   []int
                SearchQuery     string
                ProfileGroups   []*middleware.ProfileGroup
                OrderedPrompts  []GroupedPrompt
        }{
                PageName:        pageName,
                Prompts:         promptTexts,
                Results:         resultsForTemplate,
                Models:          models,
                PassPercentages: modelPassPercentages,
                ModelFilter:     modelFilter,
                TotalScores:     modelTotalScores,
                PromptIndices:   promptIndices,
                SearchQuery:     searchQuery,
                ProfileGroups:   profileGroups,
                OrderedPrompts:  orderedPrompts,
        }

        err = t.Execute(w, templateData)
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("Error executing template: %v", err)
                http.Error(w, "Error executing template", http.StatusInternalServerError)
                return
        }</span>
        <span class="cov8" title="1">log.Println("Results page rendered successfully")</span>
}

// Handle AJAX requests to update results
func UpdateResultHandler(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        log.Println("Handling update result")
        r.ParseForm()
        model := r.Form.Get("model")
        promptIndexStr := r.Form.Get("promptIndex")
        passStr := r.Form.Get("pass")
        promptIndex, _ := strconv.Atoi(promptIndexStr)
        pass, err := strconv.ParseBool(passStr)
        if err != nil </span><span class="cov8" title="1">{
                log.Printf("Invalid pass value: %v", err)
                http.Error(w, "Invalid pass value", http.StatusBadRequest)
                return
        }</span>

        <span class="cov8" title="1">suiteName := middleware.GetCurrentSuiteName()
        results := middleware.ReadResults()
        if results == nil </span><span class="cov0" title="0">{
                results = make(map[string]middleware.Result)
        }</span>
        <span class="cov8" title="1">if _, ok := results[model]; !ok </span><span class="cov8" title="1">{
                results[model] = middleware.Result{
                        Scores: make([]int, len(middleware.ReadPrompts())),
                }
        }</span>

        <span class="cov8" title="1">prompts := middleware.ReadPrompts()
        result := results[model]
        if len(result.Scores) &lt; len(prompts) </span><span class="cov0" title="0">{
                result.Scores = append(result.Scores, make([]int, len(prompts)-len(result.Scores))...)
        }</span>
        <span class="cov8" title="1">if promptIndex &gt;= 0 &amp;&amp; promptIndex &lt; len(result.Scores) </span><span class="cov8" title="1">{
                if pass </span><span class="cov8" title="1">{
                        result.Scores[promptIndex] = 100
                }</span> else<span class="cov0" title="0"> {
                        result.Scores[promptIndex] = 0
                }</span>
        }
        <span class="cov8" title="1">results[model] = result
        err = middleware.WriteResults(suiteName, results)
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("Error writing results: %v", err)
                http.Error(w, "Error writing results", http.StatusInternalServerError)
                return
        }</span>

        <span class="cov8" title="1">middleware.BroadcastResults()

        _, err = w.Write([]byte("OK"))
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("Error writing response: %v", err)
                http.Error(w, "Error writing response", http.StatusInternalServerError)
                return
        }</span>
        <span class="cov8" title="1">log.Println("protocols.Result updated successfully")</span>
}

// Handle reset results
func ResetResultsHandler(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        log.Println("Handling reset results")
        if r.Method == "GET" </span><span class="cov8" title="1">{
                middleware.RenderTemplateSimple(w, "reset_results.html", nil)
        }</span> else<span class="cov8" title="1"> if r.Method == "POST" </span><span class="cov8" title="1">{
                emptyResults := make(map[string]middleware.Result)
                suiteName := middleware.GetCurrentSuiteName()
                err := middleware.WriteResults(suiteName, emptyResults)
                if err != nil </span><span class="cov0" title="0">{
                        log.Printf("Error writing results: %v", err)
                        http.Error(w, "Error writing results", http.StatusInternalServerError)
                        return
                }</span>
                <span class="cov8" title="1">log.Println("Results reset successfully")
                middleware.BroadcastResults()
                http.Redirect(w, r, "/results", http.StatusSeeOther)</span>
        }
}

// Handle confirm refresh results
func ConfirmRefreshResultsHandler(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        log.Println("Handling confirm refresh results")
        if r.Method == "GET" </span><span class="cov8" title="1">{
                middleware.RenderTemplateSimple(w, "confirm_refresh_results.html", nil)
        }</span> else<span class="cov8" title="1"> if r.Method == "POST" </span><span class="cov8" title="1">{
                results := middleware.ReadResults()
                for model := range results </span><span class="cov8" title="1">{
                        results[model] = middleware.Result{
                                Scores: make([]int, len(middleware.ReadPrompts())),
                        }
                }</span>
                <span class="cov8" title="1">suiteName := middleware.GetCurrentSuiteName()
                err := middleware.WriteResults(suiteName, results)
                if err != nil </span><span class="cov0" title="0">{
                        log.Printf("Error writing results: %v", err)
                        http.Error(w, "Error writing results", http.StatusInternalServerError)
                        return
                }</span>
                <span class="cov8" title="1">log.Println("Results refreshed successfully")
                middleware.BroadcastResults()
                http.Redirect(w, r, "/results", http.StatusSeeOther)</span>
        }
}

// Handle refresh results
func RefreshResultsHandler(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        log.Println("Handling refresh results")
        if r.Method == "GET" </span><span class="cov8" title="1">{
                middleware.RenderTemplateSimple(w, "confirm_refresh_results.html", nil)
        }</span> else<span class="cov8" title="1"> if r.Method == "POST" </span><span class="cov8" title="1">{
                results := middleware.ReadResults()
                for model := range results </span><span class="cov8" title="1">{
                        results[model] = middleware.Result{Scores: make([]int, len(middleware.ReadPrompts()))}
                }</span>
                <span class="cov8" title="1">suiteName := middleware.GetCurrentSuiteName()
                err := middleware.WriteResults(suiteName, results)
                if err != nil </span><span class="cov0" title="0">{
                        log.Printf("Error writing results: %v", err)
                        http.Error(w, "Error writing results", http.StatusInternalServerError)
                        return
                }</span>
                <span class="cov8" title="1">log.Println("Results refreshed successfully")
                middleware.BroadcastResults()
                http.Redirect(w, r, "/results", http.StatusSeeOther)</span>
        }
}

// Handle evaluation of individual results
func EvaluateResult(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        model := r.URL.Query().Get("model")
        promptIndexStr := r.URL.Query().Get("prompt")

        if r.Method == "POST" </span><span class="cov8" title="1">{
                scoreStr := r.FormValue("score")
                score, err := strconv.Atoi(scoreStr)
                if err != nil </span><span class="cov8" title="1">{
                        http.Error(w, "Invalid score value", http.StatusBadRequest)
                        return
                }</span>

                <span class="cov8" title="1">results := middleware.ReadResults()
                if results == nil </span><span class="cov0" title="0">{
                        results = make(map[string]middleware.Result)
                }</span>

                <span class="cov8" title="1">result, exists := results[model]
                if !exists </span><span class="cov8" title="1">{
                        // Initialize new result with scores array matching prompts length
                        prompts := middleware.ReadPrompts()
                        result = middleware.Result{
                                Scores: make([]int, len(prompts)),
                        }
                }</span>

                <span class="cov8" title="1">index, err := strconv.Atoi(promptIndexStr)
                if err != nil || index &lt; 0 || index &gt;= len(result.Scores) </span><span class="cov8" title="1">{
                        http.Error(w, "Invalid prompt index", http.StatusBadRequest)
                        return
                }</span>

                // Update the score (ensure it's within 0-100 range)
                <span class="cov8" title="1">if score &lt; 0 </span><span class="cov8" title="1">{
                        score = 0
                }</span> else<span class="cov8" title="1"> if score &gt; 100 </span><span class="cov8" title="1">{
                        score = 100
                }</span>
                <span class="cov8" title="1">result.Scores[index] = score
                results[model] = result

                // Write updated results
                err = middleware.WriteResults(middleware.GetCurrentSuiteName(), results)
                if err != nil </span><span class="cov0" title="0">{
                        http.Error(w, "Failed to save results", http.StatusInternalServerError)
                        return
                }</span>

                // Broadcast updated results to all clients
                <span class="cov8" title="1">middleware.BroadcastResults()

                // Add debug logging
                log.Printf("Updated score for model %s, prompt %d: %d", model, index, score)
                log.Printf("Current results for model %s: %v", model, result.Scores)

                // Redirect back to results page
                http.Redirect(w, r, "/results", http.StatusSeeOther)
                return</span>
        }

        // Get current score for this model/prompt
        <span class="cov8" title="1">results := middleware.ReadResults()
        currentScore := 0
        if result, exists := results[model]; exists </span><span class="cov8" title="1">{
                if index, err := strconv.Atoi(promptIndexStr); err == nil &amp;&amp; index &lt; len(result.Scores) </span><span class="cov8" title="1">{
                        currentScore = result.Scores[index]
                }</span>
        }

        // Get the prompt text and solution for display
        <span class="cov8" title="1">prompts := middleware.ReadPrompts()
        var promptText, solution string
        promptIndex, err := strconv.Atoi(promptIndexStr)
        if err == nil &amp;&amp; promptIndex &gt;= 0 &amp;&amp; promptIndex &lt; len(prompts) </span><span class="cov8" title="1">{
                promptText = prompts[promptIndex].Text
                solution = prompts[promptIndex].Solution
        }</span>

        <span class="cov8" title="1">data := struct {
                PageName     string
                Model        string
                PromptIndex  string
                ScoreOptions map[string]int
                CurrentScore int
                PromptText   string
                Solution     string
                TotalPrompts int
        }{
                PageName:     templates.PageNameEvaluate,
                Model:        model,
                PromptIndex:  promptIndexStr,
                ScoreOptions: templates.ScoreOptions,
                CurrentScore: currentScore,
                PromptText:   promptText,
                Solution:     solution,
                TotalPrompts: len(prompts),
        }

        t, err := template.New("evaluate.html").Funcs(templates.FuncMap).ParseFiles("templates/evaluate.html", "templates/nav.html")
        if err != nil </span><span class="cov8" title="1">{
                log.Printf("Error parsing template: %v", err)
                http.Error(w, "Error parsing template: "+err.Error(), http.StatusInternalServerError)
                return
        }</span>

        <span class="cov8" title="1">err = t.Execute(w, data)
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("Error executing template: %v", err)
                http.Error(w, "Error executing template", http.StatusInternalServerError)
                return
        }</span>
}

// Handle export results
func ExportResultsHandler(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        log.Println("Handling export results")
        results := middleware.ReadResults()

        // Convert results to JSON
        jsonData, err := json.MarshalIndent(results, "", "  ")
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("Error marshaling results to JSON: %v", err)
                http.Error(w, "Error creating JSON export", http.StatusInternalServerError)
                return
        }</span>

        // Set headers for JSON download
        <span class="cov8" title="1">w.Header().Set("Content-Type", "application/json")
        w.Header().Set("Content-Disposition", "attachment;filename=results.json")

        // Write JSON to response
        _, err = w.Write(jsonData)
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("Error writing response: %v", err)
                http.Error(w, "Error writing response", http.StatusInternalServerError)
                return
        }</span>
        <span class="cov8" title="1">log.Println("Results exported successfully as JSON")</span>
}

// UpdateMockResultsHandler handles updating results with randomly generated mock data
// that ensures even distribution across all tier levels
func UpdateMockResultsHandler(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        log.Println("Handling update mock results")

        if r.Method != "POST" </span><span class="cov8" title="1">{
                http.Error(w, "Method not allowed", http.StatusMethodNotAllowed)
                return
        }</span>

        // Parse the JSON request body
        <span class="cov8" title="1">var mockData struct {
                Results         map[string]middleware.Result `json:"results"`
                Models          []string                     `json:"models"`
                PassPercentages map[string]float64           `json:"passPercentages"`
                TotalScores     map[string]int               `json:"totalScores"`
        }

        log.Println("Received mock data request")

        body, err := io.ReadAll(r.Body)
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("Error reading request body: %v", err)
                http.Error(w, "Error reading request body", http.StatusBadRequest)
                return
        }</span>

        <span class="cov8" title="1">err = json.Unmarshal(body, &amp;mockData)
        if err != nil </span><span class="cov8" title="1">{
                log.Printf("Error decoding mock data: %v", err)
                http.Error(w, "Invalid JSON data", http.StatusBadRequest)
                return
        }</span>

        // Use client-provided scores instead of generating new ones
        <span class="cov8" title="1">log.Println("Using client-provided scores for mock data")

        prompts := middleware.ReadPrompts()

        // Get all model names
        models := mockData.Models
        if len(models) == 0 </span><span class="cov8" title="1">{
                // If no models passed, use models from existing results
                for model := range mockData.Results </span><span class="cov8" title="1">{
                        models = append(models, model)
                }</span>
        }

        // Use the client's results directly
        <span class="cov8" title="1">results := mockData.Results

        // Validate that all scores are legitimate values: 0, 20, 40, 60, 80, 100
        for model, result := range results </span><span class="cov8" title="1">{
                for i, score := range result.Scores </span><span class="cov8" title="1">{
                        // Only allow valid score values
                        switch score </span>{
                        case 0, 20, 40, 60, 80, 100:<span class="cov8" title="1"></span>
                                // Valid score, keep it
                        default:<span class="cov8" title="1">
                                // Invalid score, set to 0
                                log.Printf("Correcting invalid score %d for model %s prompt %d", score, model, i)
                                result.Scores[i] = 0</span>
                        }
                }
                <span class="cov8" title="1">results[model] = result</span>
        }

        // Skip the evenly distributed tier generation since we're using client scores

        // Save the evenly distributed mock results
        <span class="cov8" title="1">suiteName := middleware.GetCurrentSuiteName()
        err = middleware.WriteResults(suiteName, results)
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("Error writing mock results: %v", err)
                http.Error(w, "Error saving mock results", http.StatusInternalServerError)
                return
        }</span>

        // Broadcast the updated results to all connected clients
        <span class="cov8" title="1">middleware.BroadcastResults()

        // Calculate totalScores and passPercentages for the response
        totalScores := make(map[string]int)
        passPercentages := make(map[string]float64)

        log.Println("Calculating total scores for each model:")
        for model, result := range results </span><span class="cov8" title="1">{
                totalScore := 0
                for _, score := range result.Scores </span><span class="cov8" title="1">{
                        totalScore += score
                }</span>
                <span class="cov8" title="1">totalScores[model] = totalScore
                passPercentages[model] = float64(totalScore) / float64(len(prompts)*100) * 100

                log.Printf("Model %s: total score = %d, pass percentage = %.2f%%",
                        model, totalScore, passPercentages[model])</span>
        }

        // Sort models by total score in descending order
        <span class="cov8" title="1">sort.Slice(models, func(i, j int) bool </span><span class="cov0" title="0">{
                return totalScores[models[i]] &gt; totalScores[models[j]]
        }</span>)

        <span class="cov8" title="1">log.Printf("Sorted models after mock generation: %v", models[:min(5, len(models))])

        // Return success response with the generated data
        w.Header().Set("Content-Type", "application/json")
        response := map[string]interface{}{
                "status":          "success",
                "results":         results,
                "models":          models, // Now sorted by score
                "totalScores":     totalScores,
                "passPercentages": passPercentages,
        }

        err = json.NewEncoder(w).Encode(response)
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("Error encoding response: %v", err)
        }</span>

        <span class="cov8" title="1">log.Println("Mock results with even tier distribution updated successfully")</span>
}
</pre>
		
		<pre class="file" id="file5" style="display: none">package handlers

import (
        "llm-tournament/middleware"
        "log"
        "net/http"
        "strconv"
)

// SettingsHandler displays the settings page
func SettingsHandler(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        log.Println("Handling settings page")

        // Get masked API keys for display
        maskedKeys, err := middleware.GetMaskedAPIKeys()
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("Error getting masked API keys: %v", err)
                http.Error(w, "Failed to load settings", http.StatusInternalServerError)
                return
        }</span>

        // Get other settings
        <span class="cov8" title="1">threshold, _ := middleware.GetSetting("cost_alert_threshold_usd")
        autoEval, _ := middleware.GetSetting("auto_evaluate_new_models")
        pythonURL, _ := middleware.GetSetting("python_service_url")

        // Parse threshold as float
        thresholdFloat, _ := strconv.ParseFloat(threshold, 64)
        if thresholdFloat == 0 </span><span class="cov8" title="1">{
                thresholdFloat = 100.0
        }</span>

        <span class="cov8" title="1">data := struct {
                PageName      string
                MaskedAPIKeys map[string]string
                Threshold     float64
                AutoEvaluate  bool
                PythonURL     string
        }{
                PageName:      "Settings",
                MaskedAPIKeys: maskedKeys,
                Threshold:     thresholdFloat,
                AutoEvaluate:  autoEval == "true",
                PythonURL:     pythonURL,
        }

        middleware.RenderTemplate(w, "settings.html", data)</span>
}

// UpdateSettingsHandler updates settings from form submission
func UpdateSettingsHandler(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        if r.Method != http.MethodPost </span><span class="cov8" title="1">{
                http.Error(w, "Method not allowed", http.StatusMethodNotAllowed)
                return
        }</span>

        <span class="cov8" title="1">log.Println("Updating settings")

        // Parse form
        if err := r.ParseForm(); err != nil </span><span class="cov0" title="0">{
                log.Printf("Error parsing form: %v", err)
                http.Error(w, "Failed to parse form", http.StatusBadRequest)
                return
        }</span>

        // Update API keys (only if not empty)
        <span class="cov8" title="1">apiKeys := map[string]string{
                "anthropic": r.FormValue("api_key_anthropic"),
                "openai":    r.FormValue("api_key_openai"),
                "google":    r.FormValue("api_key_google"),
        }

        for provider, key := range apiKeys </span><span class="cov8" title="1">{
                if key != "" &amp;&amp; key != "********" </span><span class="cov8" title="1">{ // Don't update if placeholder
                        if err := middleware.SetAPIKey(provider, key); err != nil </span><span class="cov0" title="0">{
                                log.Printf("Error setting API key for %s: %v", provider, err)
                                http.Error(w, "Failed to save API key", http.StatusInternalServerError)
                                return
                        }</span>
                }
        }

        // Update other settings
        <span class="cov8" title="1">threshold := r.FormValue("cost_alert_threshold_usd")
        if threshold != "" </span><span class="cov8" title="1">{
                if err := middleware.SetSetting("cost_alert_threshold_usd", threshold); err != nil </span><span class="cov0" title="0">{
                        log.Printf("Error setting threshold: %v", err)
                }</span>
        }

        <span class="cov8" title="1">autoEval := r.FormValue("auto_evaluate_new_models")
        autoEvalValue := "false"
        if autoEval == "on" </span><span class="cov8" title="1">{
                autoEvalValue = "true"
        }</span>
        <span class="cov8" title="1">if err := middleware.SetSetting("auto_evaluate_new_models", autoEvalValue); err != nil </span><span class="cov0" title="0">{
                log.Printf("Error setting auto_evaluate: %v", err)
        }</span>

        <span class="cov8" title="1">pythonURL := r.FormValue("python_service_url")
        if pythonURL != "" </span><span class="cov8" title="1">{
                if err := middleware.SetSetting("python_service_url", pythonURL); err != nil </span><span class="cov0" title="0">{
                        log.Printf("Error setting Python URL: %v", err)
                }</span>
        }

        <span class="cov8" title="1">log.Println("Settings updated successfully")

        // Redirect back to settings page
        http.Redirect(w, r, "/settings", http.StatusSeeOther)</span>
}

// TestAPIKeyHandler tests an API key by making a health check to Python service
func TestAPIKeyHandler(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        if r.Method != http.MethodPost </span><span class="cov8" title="1">{
                http.Error(w, "Method not allowed", http.StatusMethodNotAllowed)
                return
        }</span>

        <span class="cov8" title="1">provider := r.FormValue("provider")
        if provider == "" </span><span class="cov8" title="1">{
                http.Error(w, "Provider required", http.StatusBadRequest)
                return
        }</span>

        // Get API key
        <span class="cov8" title="1">apiKey, err := middleware.GetAPIKey(provider)
        if err != nil || apiKey == "" </span><span class="cov8" title="1">{
                middleware.RespondJSON(w, map[string]interface{}{
                        "success": false,
                        "message": "API key not configured",
                })
                return
        }</span>

        // TODO: Make actual test call to respective API
        // For now, just return success
        <span class="cov8" title="1">middleware.RespondJSON(w, map[string]interface{}{
                "success": true,
                "message": "API key appears valid (test not fully implemented)",
        })</span>
}
</pre>
		
		<pre class="file" id="file6" style="display: none">package handlers

import (
        "bytes"
        "encoding/json"
        "html/template"
        "log"
        "net/http"
        "strings"

        "llm-tournament/middleware"
)

// Calculate tiers based on total scores
func calculateTiers(totalScores map[string]int) (map[string][]string, map[string]string) <span class="cov8" title="1">{
        tiers := map[string][]string{
                "transcendental": {},
                "cosmic":         {},
                "divine":         {},
                "celestial":      {},
                "ascendant":      {},
                "ethereal":       {},
                "mystic":         {},
                "astral":         {},
                "spiritual":      {},
                "primal":         {},
                "mortal":         {},
                "primordial":     {},
        }

        tierRanges := map[string]string{
                "transcendental": "3780+",
                "cosmic":         "3360-3779",
                "divine":         "2700-3359",
                "celestial":      "2400-2699",
                "ascendant":      "2100-2399",
                "ethereal":       "1800-2099",
                "mystic":         "1500-1799",
                "astral":         "1200-1499",
                "spiritual":      "900-1199",
                "primal":         "600-899",
                "mortal":         "300-599",
                "primordial":     "0-299",
        }

        for model, score := range totalScores </span><span class="cov8" title="1">{
                switch </span>{
                case score &gt;= 3780:<span class="cov8" title="1">
                        tiers["transcendental"] = append(tiers["transcendental"], model)</span>
                case score &gt;= 3360:<span class="cov8" title="1">
                        tiers["cosmic"] = append(tiers["cosmic"], model)</span>
                case score &gt;= 2700:<span class="cov8" title="1">
                        tiers["divine"] = append(tiers["divine"], model)</span>
                case score &gt;= 2400:<span class="cov8" title="1">
                        tiers["celestial"] = append(tiers["celestial"], model)</span>
                case score &gt;= 2100:<span class="cov8" title="1">
                        tiers["ascendant"] = append(tiers["ascendant"], model)</span>
                case score &gt;= 1800:<span class="cov8" title="1">
                        tiers["ethereal"] = append(tiers["ethereal"], model)</span>
                case score &gt;= 1500:<span class="cov8" title="1">
                        tiers["mystic"] = append(tiers["mystic"], model)</span>
                case score &gt;= 1200:<span class="cov8" title="1">
                        tiers["astral"] = append(tiers["astral"], model)</span>
                case score &gt;= 900:<span class="cov8" title="1">
                        tiers["spiritual"] = append(tiers["spiritual"], model)</span>
                case score &gt;= 600:<span class="cov8" title="1">
                        tiers["primal"] = append(tiers["primal"], model)</span>
                case score &gt;= 300:<span class="cov8" title="1">
                        tiers["mortal"] = append(tiers["mortal"], model)</span>
                default:<span class="cov8" title="1">
                        tiers["primordial"] = append(tiers["primordial"], model)</span>
                }
        }

        <span class="cov8" title="1">return tiers, tierRanges</span>
}

// Handle stats page
func StatsHandler(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        log.Println("Handling stats page")
        results := middleware.ReadResults()

        // Calculate score breakdowns
        type ScoreStats struct {
                TotalScore int `json:"TotalScore"`
                Count20    int `json:"Count20"`
                Count40    int `json:"Count40"`
                Count60    int `json:"Count60"`
                Count80    int `json:"Count80"`
                Count100   int `json:"Count100"`
        }

        scoreStats := make(map[string]ScoreStats)
        for model, result := range results </span><span class="cov8" title="1">{
                stats := ScoreStats{}
                for _, score := range result.Scores </span><span class="cov8" title="1">{
                        stats.TotalScore += score
                        switch score </span>{
                        case 20:<span class="cov8" title="1">
                                stats.Count20++</span>
                        case 40:<span class="cov8" title="1">
                                stats.Count40++</span>
                        case 60:<span class="cov8" title="1">
                                stats.Count60++</span>
                        case 80:<span class="cov8" title="1">
                                stats.Count80++</span>
                        case 100:<span class="cov8" title="1">
                                stats.Count100++</span>
                        }
                }

                // Double-check total score calculation to ensure consistency
                <span class="cov8" title="1">calculatedTotal := stats.Count20*20 + stats.Count40*40 + stats.Count60*60 + stats.Count80*80 + stats.Count100*100
                if calculatedTotal != stats.TotalScore </span><span class="cov0" title="0">{
                        log.Printf("Warning: Score mismatch for %s: calculated=%d, summed=%d", model, calculatedTotal, stats.TotalScore)
                        // Fix the total score if there's a discrepancy
                        stats.TotalScore = calculatedTotal
                }</span>
                <span class="cov8" title="1">scoreStats[model] = stats</span>
        }

        // Create total scores map for tier calculations
        <span class="cov8" title="1">totalScores := make(map[string]int)
        for model, stats := range scoreStats </span><span class="cov8" title="1">{
                totalScores[model] = stats.TotalScore
        }</span>

        // Calculate tiers
        <span class="cov8" title="1">tiers, tierRanges := calculateTiers(totalScores)

        // Prepare template data
        templateData := struct {
                PageName     string
                TotalScores  map[string]ScoreStats
                Tiers        map[string][]string
                TierRanges   map[string]string
                OrderedTiers []string
        }{
                PageName:    "Statistics",
                TotalScores: scoreStats,
                Tiers:       tiers,
                TierRanges:  tierRanges,
                OrderedTiers: []string{
                        "transcendental",
                        "cosmic",
                        "divine",
                        "celestial",
                        "ascendant",
                        "ethereal",
                        "mystic",
                        "astral",
                        "spiritual",
                        "primal",
                        "mortal",
                        "primordial",
                },
        }

        // Parse and execute template
        t, err := template.New("stats.html").Funcs(template.FuncMap{
                "json": func(v interface{}) template.JS </span><span class="cov8" title="1">{ // Updated to return template.JS
                        a, _ := json.Marshal(v)
                        return template.JS(a)
                }</span>,
                "tierClass": func(tier string) string <span class="cov8" title="1">{
                        return tier
                }</span>,
                "formatTierName": func(tier string) string <span class="cov8" title="1">{
                        return strings.Title(strings.ReplaceAll(tier, "-", " "))
                }</span>,
                "join": strings.Join,
        }).ParseFiles("templates/stats.html", "templates/nav.html")

        <span class="cov8" title="1">if err != nil </span><span class="cov8" title="1">{
                http.Error(w, "Error parsing template: "+err.Error(), http.StatusInternalServerError)
                return
        }</span>

        <span class="cov8" title="1">buf := new(bytes.Buffer)
        err = t.Execute(buf, templateData)
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("Template execution error: %v", err)
                http.Error(w, "Error executing template: "+err.Error(), http.StatusInternalServerError)
                return
        }</span>

        // Write the buffered template output to response
        <span class="cov8" title="1">_, err = buf.WriteTo(w)
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("Error writing response: %v", err)
        }</span>
}
</pre>
		
		<pre class="file" id="file7" style="display: none">package handlers

import (
        "fmt"
        "log"
        "net/http"
        "os"

        "llm-tournament/middleware"
)

// Handle delete prompt suite page
func DeletePromptSuiteHandler(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        log.Println("Handling delete prompt suite page")
        if r.Method == "GET" </span><span class="cov8" title="1">{
                suiteName := r.URL.Query().Get("suite_name")
                middleware.RenderTemplate(w, "delete_prompt_suite.html", map[string]string{"SuiteName": suiteName})
                log.Println("Delete prompt suite page rendered successfully")
        }</span> else<span class="cov8" title="1"> if r.Method == "POST" </span><span class="cov8" title="1">{
                suiteName := r.FormValue("suite_name")
                if suiteName == "" </span><span class="cov8" title="1">{
                        http.Error(w, "Suite name is required", http.StatusBadRequest)
                        return
                }</span>

                <span class="cov8" title="1">currentSuite := middleware.GetCurrentSuiteName()
                if suiteName == currentSuite </span><span class="cov0" title="0">{
                        err := os.WriteFile("data/current_suite.txt", []byte("default"), 0644)
                        if err != nil </span><span class="cov0" title="0">{
                                log.Printf("Error updating current suite: %v", err)
                                http.Error(w, "Error updating current suite", http.StatusInternalServerError)
                                return
                        }</span>
                }

                <span class="cov8" title="1">err := middleware.DeletePromptSuite(suiteName)
                if err != nil </span><span class="cov0" title="0">{
                        log.Printf("Error deleting prompt suite: %v", err)
                        http.Error(w, "Error deleting prompt suite", http.StatusInternalServerError)
                        return
                }</span>

                <span class="cov8" title="1">log.Printf("Prompt suite '%s' deleted successfully", suiteName)
                middleware.BroadcastResults()
                http.Redirect(w, r, "/prompts", http.StatusSeeOther)</span>
        }
}

// Handle select prompt suite
func SelectPromptSuiteHandler(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        log.Println("Handling select prompt suite")
        err := r.ParseForm()
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("Error parsing form: %v", err)
                http.Error(w, "Error parsing form", http.StatusBadRequest)
                return
        }</span>
        <span class="cov8" title="1">suiteName := r.Form.Get("suite_name")
        if suiteName == "" </span><span class="cov8" title="1">{
                log.Println("Suite name cannot be empty")
                http.Error(w, "Suite name cannot be empty", http.StatusBadRequest)
                return
        }</span>

        <span class="cov8" title="1">err = os.WriteFile("data/current_suite.txt", []byte(suiteName), 0644)
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("Error writing current suite: %v", err)
                http.Error(w, "Error writing current suite", http.StatusInternalServerError)
                return
        }</span>

        <span class="cov8" title="1">log.Printf("Prompt suite '%s' selected successfully", suiteName)
        middleware.BroadcastResults()
        http.Redirect(w, r, "/prompts", http.StatusSeeOther)</span>
}

// Handle new prompt suite
func NewPromptSuiteHandler(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        log.Println("Handling new prompt suite")
        if r.Method == "GET" </span><span class="cov8" title="1">{
                middleware.RenderTemplate(w, "new_prompt_suite.html", nil)
                log.Println("New prompt suite page rendered successfully")
        }</span> else<span class="cov8" title="1"> if r.Method == "POST" </span><span class="cov8" title="1">{
                err := r.ParseForm()
                if err != nil </span><span class="cov0" title="0">{
                        log.Printf("Error parsing form: %v", err)
                        http.Error(w, "Error parsing form", http.StatusBadRequest)
                        return
                }</span>
                <span class="cov8" title="1">suiteName := r.Form.Get("suite_name")
                if suiteName == "" </span><span class="cov8" title="1">{
                        log.Println("Suite name cannot be empty")
                        http.Error(w, "Suite name cannot be empty", http.StatusBadRequest)
                        return
                }</span>
                <span class="cov8" title="1">err = middleware.WritePromptSuite(suiteName, []middleware.Prompt{})
                if err != nil </span><span class="cov0" title="0">{
                        log.Printf("Error creating prompt suite: %v", err)
                        http.Error(w, "Error creating prompt suite", http.StatusInternalServerError)
                        return
                }</span>
                <span class="cov8" title="1">log.Printf("Prompt suite '%s' created successfully", suiteName)
                middleware.BroadcastResults()
                http.Redirect(w, r, "/prompts", http.StatusSeeOther)</span>
        }
}

// Handle edit prompt suite
func EditPromptSuiteHandler(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        log.Println("Handling edit prompt suite")
        if r.Method == "GET" </span><span class="cov8" title="1">{
                suiteName := r.URL.Query().Get("suite_name")
                middleware.RenderTemplate(w, "edit_prompt_suite.html", map[string]string{"SuiteName": suiteName})
                log.Println("Edit prompt suite page rendered successfully")
        }</span> else<span class="cov8" title="1"> if r.Method == "POST" </span><span class="cov8" title="1">{
                err := r.ParseForm()
                if err != nil </span><span class="cov0" title="0">{
                        log.Printf("Error parsing form: %v", err)
                        http.Error(w, "Error parsing form", http.StatusBadRequest)
                        return
                }</span>
                <span class="cov8" title="1">oldSuiteName := r.Form.Get("suite_name")
                newSuiteName := r.Form.Get("new_suite_name")

                if oldSuiteName == "" || newSuiteName == "" </span><span class="cov8" title="1">{
                        log.Println("Both old and new names required")
                        http.Error(w, "Both original and new suite names are required", http.StatusBadRequest)
                        return
                }</span>

                <span class="cov8" title="1">if err := middleware.RenameSuiteFiles(oldSuiteName, newSuiteName); err != nil </span><span class="cov8" title="1">{
                        log.Printf("Error renaming suite: %v", err)
                        http.Error(w, fmt.Sprintf("Error renaming suite: %v", err), http.StatusBadRequest)
                        return
                }</span>
                <span class="cov8" title="1">log.Printf("Prompt suite '%s' edited successfully to '%s'", oldSuiteName, newSuiteName)
                middleware.BroadcastResults()
                http.Redirect(w, r, "/prompts", http.StatusSeeOther)</span>
        }
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
