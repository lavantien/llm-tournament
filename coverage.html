
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>handlers: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">llm-tournament/handlers/evaluation.go (100.0%)</option>
				
				<option value="file1">llm-tournament/handlers/handler.go (100.0%)</option>
				
				<option value="file2">llm-tournament/handlers/models.go (100.0%)</option>
				
				<option value="file3">llm-tournament/handlers/profiles.go (100.0%)</option>
				
				<option value="file4">llm-tournament/handlers/prompt.go (100.0%)</option>
				
				<option value="file5">llm-tournament/handlers/results.go (96.2%)</option>
				
				<option value="file6">llm-tournament/handlers/settings.go (100.0%)</option>
				
				<option value="file7">llm-tournament/handlers/stats.go (100.0%)</option>
				
				<option value="file8">llm-tournament/handlers/suites.go (100.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">no coverage</span>
				<span class="cov1">low coverage</span>
				<span class="cov2">*</span>
				<span class="cov3">*</span>
				<span class="cov4">*</span>
				<span class="cov5">*</span>
				<span class="cov6">*</span>
				<span class="cov7">*</span>
				<span class="cov8">*</span>
				<span class="cov9">*</span>
				<span class="cov10">high coverage</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package handlers

import (
        "database/sql"
        "encoding/json"
        "fmt"
        "llm-tournament/evaluator"
        "llm-tournament/middleware"
        "log"
        "net/http"
        "strconv"
)

var globalEvaluator *evaluator.Evaluator

// InitEvaluator initializes the global evaluator instance
func InitEvaluator(db *sql.DB) <span class="cov10" title="42">{
        pythonURL, _ := middleware.GetSetting("python_service_url")
        if pythonURL == "" </span><span class="cov3" title="3">{
                pythonURL = "http://localhost:8001"
        }</span>
        <span class="cov10" title="42">globalEvaluator = evaluator.NewEvaluator(db, pythonURL)
        log.Printf("Evaluator initialized with Python service URL: %s", pythonURL)</span>
}

// EvaluateAllHandler triggers evaluation of all models × all prompts
func EvaluateAllHandler(w http.ResponseWriter, r *http.Request) <span class="cov7" title="15">{
        if r.Method != http.MethodPost </span><span class="cov3" title="3">{
                http.Error(w, "Method not allowed", http.StatusMethodNotAllowed)
                return
        }</span>

        <span class="cov6" title="12">suiteID, err := middleware.GetCurrentSuiteID()
        if err != nil </span><span class="cov3" title="3">{
                log.Printf("Error getting current suite: %v", err)
                http.Error(w, "Failed to get current suite", http.StatusInternalServerError)
                return
        }</span>

        <span class="cov6" title="9">jobID, err := globalEvaluator.EvaluateAll(suiteID)
        if err != nil </span><span class="cov3" title="3">{
                log.Printf("Error starting evaluation: %v", err)
                http.Error(w, fmt.Sprintf("Failed to start evaluation: %v", err), http.StatusInternalServerError)
                return
        }</span>

        <span class="cov3" title="3">middleware.RespondJSON(w, map[string]interface{}{
                "success": true,
                "job_id":  jobID,
                "message": "Evaluation started",
        })</span>
}

// EvaluateModelHandler triggers evaluation of one model × all prompts
func EvaluateModelHandler(w http.ResponseWriter, r *http.Request) <span class="cov7" title="15">{
        if r.Method != http.MethodPost </span><span class="cov3" title="3">{
                http.Error(w, "Method not allowed", http.StatusMethodNotAllowed)
                return
        }</span>

        <span class="cov6" title="12">modelIDStr := r.URL.Query().Get("id")
        if modelIDStr == "" </span><span class="cov3" title="3">{
                http.Error(w, "Model ID required", http.StatusBadRequest)
                return
        }</span>

        <span class="cov6" title="9">modelID, err := strconv.Atoi(modelIDStr)
        if err != nil </span><span class="cov3" title="3">{
                http.Error(w, "Invalid model ID", http.StatusBadRequest)
                return
        }</span>

        <span class="cov5" title="6">jobID, err := globalEvaluator.EvaluateModel(modelID)
        if err != nil </span><span class="cov3" title="3">{
                log.Printf("Error starting model evaluation: %v", err)
                http.Error(w, fmt.Sprintf("Failed to start evaluation: %v", err), http.StatusInternalServerError)
                return
        }</span>

        <span class="cov3" title="3">middleware.RespondJSON(w, map[string]interface{}{
                "success": true,
                "job_id":  jobID,
                "message": "Model evaluation started",
        })</span>
}

// EvaluatePromptHandler triggers evaluation of all models × one prompt
func EvaluatePromptHandler(w http.ResponseWriter, r *http.Request) <span class="cov7" title="15">{
        if r.Method != http.MethodPost </span><span class="cov3" title="3">{
                http.Error(w, "Method not allowed", http.StatusMethodNotAllowed)
                return
        }</span>

        <span class="cov6" title="12">promptIDStr := r.URL.Query().Get("id")
        if promptIDStr == "" </span><span class="cov3" title="3">{
                http.Error(w, "Prompt ID required", http.StatusBadRequest)
                return
        }</span>

        <span class="cov6" title="9">promptID, err := strconv.Atoi(promptIDStr)
        if err != nil </span><span class="cov3" title="3">{
                http.Error(w, "Invalid prompt ID", http.StatusBadRequest)
                return
        }</span>

        <span class="cov5" title="6">jobID, err := globalEvaluator.EvaluatePrompt(promptID)
        if err != nil </span><span class="cov3" title="3">{
                log.Printf("Error starting prompt evaluation: %v", err)
                http.Error(w, fmt.Sprintf("Failed to start evaluation: %v", err), http.StatusInternalServerError)
                return
        }</span>

        <span class="cov3" title="3">middleware.RespondJSON(w, map[string]interface{}{
                "success": true,
                "job_id":  jobID,
                "message": "Prompt evaluation started",
        })</span>
}

// EvaluationProgressHandler returns the status of an evaluation job
func EvaluationProgressHandler(w http.ResponseWriter, r *http.Request) <span class="cov6" title="12">{
        jobIDStr := r.URL.Query().Get("id")
        if jobIDStr == "" </span><span class="cov3" title="3">{
                http.Error(w, "Job ID required", http.StatusBadRequest)
                return
        }</span>

        <span class="cov6" title="9">jobID, err := strconv.Atoi(jobIDStr)
        if err != nil </span><span class="cov3" title="3">{
                http.Error(w, "Invalid job ID", http.StatusBadRequest)
                return
        }</span>

        <span class="cov5" title="6">job, err := globalEvaluator.GetJobStatus(jobID)
        if err != nil </span><span class="cov3" title="3">{
                log.Printf("Error getting job status: %v", err)
                http.Error(w, "Failed to get job status", http.StatusInternalServerError)
                return
        }</span>

        <span class="cov3" title="3">middleware.RespondJSON(w, map[string]interface{}{
                "job_id":           job.ID,
                "status":           job.Status,
                "progress_current": job.ProgressCurrent,
                "progress_total":   job.ProgressTotal,
                "estimated_cost":   job.EstimatedCost,
                "actual_cost":      job.ActualCost,
                "error":            job.ErrorMessage,
        })</span>
}

// CancelEvaluationHandler cancels a running evaluation job
func CancelEvaluationHandler(w http.ResponseWriter, r *http.Request) <span class="cov7" title="18">{
        if r.Method != http.MethodPost </span><span class="cov3" title="3">{
                http.Error(w, "Method not allowed", http.StatusMethodNotAllowed)
                return
        }</span>

        <span class="cov7" title="15">jobIDStr := r.URL.Query().Get("id")
        if jobIDStr == "" </span><span class="cov3" title="3">{
                http.Error(w, "Job ID required", http.StatusBadRequest)
                return
        }</span>

        <span class="cov6" title="12">jobID, err := strconv.Atoi(jobIDStr)
        if err != nil </span><span class="cov3" title="3">{
                http.Error(w, "Invalid job ID", http.StatusBadRequest)
                return
        }</span>

        <span class="cov6" title="9">if err := globalEvaluator.CancelJob(jobID); err != nil </span><span class="cov5" title="6">{
                log.Printf("Error cancelling job: %v", err)
                http.Error(w, fmt.Sprintf("Failed to cancel job: %v", err), http.StatusInternalServerError)
                return
        }</span>

        <span class="cov3" title="3">middleware.RespondJSON(w, map[string]interface{}{
                "success": true,
                "message": "Job cancelled",
        })</span>
}

// SaveModelResponseHandler saves or updates a model's response for a prompt
func SaveModelResponseHandler(w http.ResponseWriter, r *http.Request) <span class="cov10" title="42">{
        if r.Method != http.MethodPost </span><span class="cov5" title="6">{
                http.Error(w, "Method not allowed", http.StatusMethodNotAllowed)
                return
        }</span>

        <span class="cov9" title="36">var reqBody struct {
                ModelID      int    `json:"model_id"`
                PromptID     int    `json:"prompt_id"`
                ResponseText string `json:"response_text"`
        }
        if err := json.NewDecoder(r.Body).Decode(&amp;reqBody); err != nil || reqBody.ModelID == 0 </span><span class="cov6" title="9">{
                http.Error(w, "model_id is required", http.StatusBadRequest)
                return
        }</span>
        <span class="cov8" title="27">if reqBody.PromptID == 0 </span><span class="cov5" title="6">{
                http.Error(w, "prompt_id is required", http.StatusBadRequest)
                return
        }</span>
        <span class="cov8" title="21">if reqBody.ResponseText == "" </span><span class="cov5" title="6">{
                http.Error(w, "response_text is required", http.StatusBadRequest)
                return
        }</span>

        // Get database connection
        <span class="cov7" title="15">db := middleware.GetDB()

        // Insert or update the model response
        query := `
                INSERT INTO model_responses (model_id, prompt_id, response_text, response_source)
                VALUES (?, ?, ?, 'manual')
                ON CONFLICT(model_id, prompt_id) DO UPDATE SET
                        response_text = excluded.response_text,
                        updated_at = CURRENT_TIMESTAMP
        `
        _, err := db.Exec(query, reqBody.ModelID, reqBody.PromptID, reqBody.ResponseText)
        if err != nil </span><span class="cov5" title="6">{
                log.Printf("Error saving model response: %v", err)
                http.Error(w, "Failed to save response", http.StatusInternalServerError)
                return
        }</span>

        // Return success
        <span class="cov6" title="9">w.Header().Set("Content-Type", "application/json")
        if err := json.NewEncoder(w).Encode(map[string]interface{}{
                "success": true,
                "message": "Response saved successfully",
        }); err != nil </span><span class="cov3" title="3">{
                log.Printf("Error encoding response: %v", err)
        }</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">package handlers

import (
        "llm-tournament/middleware"
)

// Handler holds dependencies for HTTP handlers
type Handler struct {
        DataStore middleware.DataStore
        Renderer  middleware.TemplateRenderer
}

// NewHandler creates a new Handler with default dependencies
func NewHandler() *Handler <span class="cov2" title="3">{
        return &amp;Handler{
                DataStore: middleware.DefaultDataStore,
                Renderer:  middleware.DefaultRenderer,
        }
}</span>

// NewHandlerWithDeps creates a new Handler with custom dependencies (for testing)
func NewHandlerWithDeps(ds middleware.DataStore, r middleware.TemplateRenderer) *Handler <span class="cov10" title="153">{
        return &amp;Handler{
                DataStore: ds,
                Renderer:  r,
        }
}</span>

// DefaultHandler is the default handler instance used by HTTP routes
var DefaultHandler = NewHandler()
</pre>
		
		<pre class="file" id="file2" style="display: none">package handlers

import (
        "llm-tournament/middleware"
        "log"
        "net/http"
)

// AddModelHandler handles adding a model (backward compatible wrapper)
func AddModelHandler(w http.ResponseWriter, r *http.Request) <span class="cov9" title="66">{
        DefaultHandler.AddModel(w, r)
}</span>

// EditModelHandler handles editing a model (backward compatible wrapper)
func EditModelHandler(w http.ResponseWriter, r *http.Request) <span class="cov7" title="24">{
        DefaultHandler.EditModel(w, r)
}</span>

// DeleteModelHandler handles deleting a model (backward compatible wrapper)
func DeleteModelHandler(w http.ResponseWriter, r *http.Request) <span class="cov7" title="21">{
        DefaultHandler.DeleteModel(w, r)
}</span>

// AddModel handles adding a model
func (h *Handler) AddModel(w http.ResponseWriter, r *http.Request) <span class="cov10" title="75">{
        log.Println("Handling add model")
        if r.Method != http.MethodPost </span><span class="cov3" title="3">{
                http.Error(w, "Method not allowed", http.StatusMethodNotAllowed)
                return
        }</span>
        <span class="cov9" title="72">err := r.ParseForm()
        if err != nil </span><span class="cov3" title="3">{
                log.Printf("Error parsing form: %v", err)
                http.Error(w, "Error parsing form", http.StatusBadRequest)
                return
        }</span>
        <span class="cov9" title="69">modelName := r.Form.Get("model")
        if modelName == "" </span><span class="cov3" title="3">{
                log.Println("Model name cannot be empty")
                http.Error(w, "Model name cannot be empty", http.StatusBadRequest)
                return
        }</span>
        <span class="cov9" title="66">results := h.DataStore.ReadResults()
        if results == nil </span><span class="cov3" title="3">{
                results = make(map[string]middleware.Result)
        }</span>
        <span class="cov9" title="66">if _, ok := results[modelName]; !ok </span><span class="cov9" title="63">{
                results[modelName] = middleware.Result{Scores: make([]int, len(h.DataStore.ReadPrompts()))}
        }</span>
        <span class="cov9" title="66">suiteName := h.DataStore.GetCurrentSuiteName()
        err = h.DataStore.WriteResults(suiteName, results)
        if err != nil </span><span class="cov3" title="3">{
                log.Printf("Error writing results: %v", err)
                http.Error(w, "Error writing results", http.StatusInternalServerError)
                return
        }</span>
        <span class="cov9" title="63">log.Println("Model added successfully")
        h.DataStore.BroadcastResults()
        http.Redirect(w, r, "/results", http.StatusSeeOther)</span>
}

// EditModel handles editing a model
func (h *Handler) EditModel(w http.ResponseWriter, r *http.Request) <span class="cov7" title="27">{
        log.Println("Handling edit model")
        modelName := r.URL.Query().Get("model")
        if modelName == "" </span><span class="cov3" title="3">{
                http.Error(w, "Model name is required", http.StatusBadRequest)
                return
        }</span>

        <span class="cov7" title="24">if r.Method == "POST" </span><span class="cov6" title="15">{
                newModelName := r.FormValue("new_model_name")
                if newModelName == "" </span><span class="cov3" title="3">{
                        http.Error(w, "New model name cannot be empty", http.StatusBadRequest)
                        return
                }</span>

                <span class="cov6" title="12">results := h.DataStore.ReadResults()
                if _, exists := results[newModelName]; exists </span><span class="cov3" title="3">{
                        http.Error(w, "Model with this name already exists", http.StatusBadRequest)
                        return
                }</span>

                <span class="cov5" title="9">results[newModelName] = results[modelName]
                delete(results, modelName)
                suiteName := h.DataStore.GetCurrentSuiteName()
                if err := h.DataStore.WriteResults(suiteName, results); err != nil </span><span class="cov3" title="3">{
                        log.Printf("Error writing results: %v", err)
                        http.Error(w, "Error writing results", http.StatusInternalServerError)
                        return
                }</span>

                <span class="cov4" title="6">h.DataStore.BroadcastResults()
                http.Redirect(w, r, "/results", http.StatusSeeOther)
                return</span>
        }

        <span class="cov5" title="9">if r.Method != "GET" </span><span class="cov3" title="3">{
                http.Error(w, "Method not allowed", http.StatusMethodNotAllowed)
                return
        }</span>

        // Render the edit model form
        <span class="cov4" title="6">if err := h.Renderer.RenderTemplateSimple(w, "edit_model.html", map[string]string{"Model": modelName}); err != nil </span><span class="cov3" title="3">{
                log.Printf("Error rendering template: %v", err)
                http.Error(w, "Error rendering template", http.StatusInternalServerError)
        }</span>
}

// DeleteModel handles deleting a model
func (h *Handler) DeleteModel(w http.ResponseWriter, r *http.Request) <span class="cov7" title="24">{
        log.Println("Handling delete model")
        switch r.Method </span>{
        case http.MethodGet:<span class="cov5" title="9">
                modelName := r.URL.Query().Get("model")
                if modelName == "" </span><span class="cov3" title="3">{
                        http.Error(w, "Model name is required", http.StatusBadRequest)
                        return
                }</span>
                <span class="cov4" title="6">if err := h.Renderer.RenderTemplateSimple(w, "delete_model.html", map[string]string{"Model": modelName}); err != nil </span><span class="cov3" title="3">{
                        log.Printf("Error rendering template: %v", err)
                        http.Error(w, "Error rendering template", http.StatusInternalServerError)
                }</span>
        case http.MethodPost:<span class="cov6" title="12">
                modelName := r.FormValue("model")
                if modelName == "" </span><span class="cov3" title="3">{
                        http.Error(w, "Model name is required", http.StatusBadRequest)
                        return
                }</span>

                <span class="cov5" title="9">results := h.DataStore.ReadResults()
                delete(results, modelName)
                suiteName := h.DataStore.GetCurrentSuiteName()
                if err := h.DataStore.WriteResults(suiteName, results); err != nil </span><span class="cov3" title="3">{
                        log.Printf("Error writing results: %v", err)
                        http.Error(w, "Error writing results", http.StatusInternalServerError)
                        return
                }</span>

                <span class="cov4" title="6">h.DataStore.BroadcastResults()
                http.Redirect(w, r, "/results", http.StatusSeeOther)</span>
        default:<span class="cov3" title="3">
                http.Error(w, "Method not allowed", http.StatusMethodNotAllowed)</span>
        }
}
</pre>
		
		<pre class="file" id="file3" style="display: none">package handlers

import (
        "llm-tournament/middleware"
        "llm-tournament/templates"
        "log"
        "net/http"
        "strconv"
)

// ProfilesHandler handles the profiles page (backward compatible wrapper)
func ProfilesHandler(w http.ResponseWriter, r *http.Request) <span class="cov6" title="12">{
        DefaultHandler.Profiles(w, r)
}</span>

// AddProfileHandler handles adding a profile (backward compatible wrapper)
func AddProfileHandler(w http.ResponseWriter, r *http.Request) <span class="cov8" title="27">{
        DefaultHandler.AddProfile(w, r)
}</span>

// EditProfileHandler handles editing a profile (backward compatible wrapper)
func EditProfileHandler(w http.ResponseWriter, r *http.Request) <span class="cov9" title="33">{
        DefaultHandler.EditProfile(w, r)
}</span>

// DeleteProfileHandler handles deleting a profile (backward compatible wrapper)
func DeleteProfileHandler(w http.ResponseWriter, r *http.Request) <span class="cov8" title="24">{
        DefaultHandler.DeleteProfile(w, r)
}</span>

// ResetProfilesHandler handles resetting profiles (backward compatible wrapper)
func ResetProfilesHandler(w http.ResponseWriter, r *http.Request) <span class="cov6" title="12">{
        DefaultHandler.ResetProfiles(w, r)
}</span>

// Profiles handles the profiles page
func (h *Handler) Profiles(w http.ResponseWriter, r *http.Request) <span class="cov6" title="12">{
        log.Println("Handling profiles page")
        searchQuery := r.FormValue("search_query")

        funcMap := templates.FuncMap

        pageName := "Profiles"
        profiles := h.DataStore.ReadProfiles()

        err := h.Renderer.Render(w, "profiles.html", funcMap, struct {
                PageName    string
                Profiles    []middleware.Profile
                SearchQuery string
                CurrentPath string
        }{
                PageName:    pageName,
                Profiles:    profiles,
                SearchQuery: searchQuery,
                CurrentPath: "/profiles",
        }, "templates/profiles.html", "templates/nav.html")
        if err != nil </span><span class="cov3" title="3">{
                log.Printf("Error rendering template: %v", err)
                http.Error(w, "Error rendering template", http.StatusInternalServerError)
                return
        }</span>
        <span class="cov6" title="9">log.Println("Profiles page rendered successfully")</span>
}

// AddProfile handles adding a profile
func (h *Handler) AddProfile(w http.ResponseWriter, r *http.Request) <span class="cov9" title="36">{
        log.Println("Handling add profile")
        if r.Method != http.MethodPost </span><span class="cov3" title="3">{
                http.Error(w, "Method not allowed", http.StatusMethodNotAllowed)
                return
        }</span>
        <span class="cov9" title="33">err := r.ParseForm()
        if err != nil </span><span class="cov3" title="3">{
                log.Printf("Error parsing form: %v", err)
                http.Error(w, "Error parsing form", http.StatusBadRequest)
                return
        }</span>
        <span class="cov8" title="30">profileName := r.Form.Get("profile_name")
        profileDescription := r.Form.Get("profile_description")
        if profileName == "" </span><span class="cov3" title="3">{
                log.Println("Profile name cannot be empty")
                http.Error(w, "Profile name cannot be empty", http.StatusBadRequest)
                return
        }</span>

        <span class="cov8" title="27">profiles := h.DataStore.ReadProfiles()
        profiles = append(profiles, middleware.Profile{Name: profileName, Description: profileDescription})
        err = h.DataStore.WriteProfiles(profiles)
        if err != nil </span><span class="cov5" title="6">{
                log.Printf("Error writing profiles: %v", err)
                http.Error(w, "Error writing profiles", http.StatusInternalServerError)
                return
        }</span>
        <span class="cov8" title="21">log.Println("Profile added successfully")
        http.Redirect(w, r, "/profiles", http.StatusSeeOther)</span>
}

// EditProfile handles editing a profile
func (h *Handler) EditProfile(w http.ResponseWriter, r *http.Request) <span class="cov10" title="48">{
        log.Println("Handling edit profile")
        switch r.Method </span>{
        case http.MethodGet:<span class="cov7" title="15">
                err := r.ParseForm()
                if err != nil </span><span class="cov3" title="3">{
                        log.Printf("Error parsing form: %v", err)
                        http.Error(w, "Error parsing form", http.StatusBadRequest)
                        return
                }</span>
                <span class="cov6" title="12">indexStr := r.Form.Get("index")
                index, err := strconv.Atoi(indexStr)
                if err != nil </span><span class="cov3" title="3">{
                        log.Printf("Invalid index: %v", err)
                        http.Error(w, "Invalid index", http.StatusBadRequest)
                        return
                }</span>
                <span class="cov6" title="9">profiles := h.DataStore.ReadProfiles()
                if index &gt;= 0 &amp;&amp; index &lt; len(profiles) </span><span class="cov5" title="6">{
                        funcMap := templates.FuncMap
                        err := h.Renderer.Render(w, "edit_profile.html", funcMap, struct {
                                Index   int
                                Profile middleware.Profile
                        }{
                                Index:   index,
                                Profile: profiles[index],
                        }, "templates/edit_profile.html")
                        if err != nil </span><span class="cov3" title="3">{
                                log.Printf("Error rendering template: %v", err)
                                http.Error(w, "Error rendering template", http.StatusInternalServerError)
                                return
                        }</span>
                }
        case http.MethodPost:<span class="cov8" title="30">
                err := r.ParseForm()
                if err != nil </span><span class="cov3" title="3">{
                        log.Printf("Error parsing form: %v", err)
                        http.Error(w, "Error parsing form", http.StatusBadRequest)
                        return
                }</span>
                <span class="cov8" title="27">indexStr := r.Form.Get("index")
                index, err := strconv.Atoi(indexStr)
                if err != nil </span><span class="cov3" title="3">{
                        log.Printf("Invalid index: %v", err)
                        http.Error(w, "Invalid index", http.StatusBadRequest)
                        return
                }</span>
                <span class="cov8" title="24">editedProfileName := r.Form.Get("profile_name")
                editedProfileDescription := r.Form.Get("profile_description")
                if editedProfileName == "" </span><span class="cov3" title="3">{
                        log.Println("Profile name cannot be empty")
                        http.Error(w, "Profile name cannot be empty", http.StatusBadRequest)
                        return
                }</span>
                <span class="cov8" title="21">profiles := h.DataStore.ReadProfiles()
                if index &gt;= 0 &amp;&amp; index &lt; len(profiles) </span><span class="cov7" title="15">{
                        oldProfileName := profiles[index].Name
                        profiles[index].Name = editedProfileName
                        profiles[index].Description = editedProfileDescription

                        // Update prompts that reference this profile
                        prompts := h.DataStore.ReadPrompts()
                        for i := range prompts </span><span class="cov6" title="12">{
                                if prompts[i].Profile == oldProfileName </span><span class="cov6" title="9">{
                                        prompts[i].Profile = editedProfileName
                                }</span>
                        }
                        <span class="cov7" title="15">err = h.DataStore.WritePrompts(prompts)
                        if err != nil </span><span class="cov3" title="3">{
                                log.Printf("Error updating prompts: %v", err)
                                http.Error(w, "Error updating prompts", http.StatusInternalServerError)
                                return
                        }</span>
                }
                <span class="cov7" title="18">err = h.DataStore.WriteProfiles(profiles)
                if err != nil </span><span class="cov3" title="3">{
                        log.Printf("Error writing profiles: %v", err)
                        http.Error(w, "Error writing profiles", http.StatusInternalServerError)
                        return
                }</span>
                <span class="cov7" title="15">log.Println("Profile edited successfully")
                http.Redirect(w, r, "/profiles", http.StatusSeeOther)</span>
        default:<span class="cov3" title="3">
                http.Error(w, "Method not allowed", http.StatusMethodNotAllowed)</span>
        }
}

// DeleteProfile handles deleting a profile
func (h *Handler) DeleteProfile(w http.ResponseWriter, r *http.Request) <span class="cov9" title="36">{
        log.Println("Handling delete profile")
        switch r.Method </span>{
        case http.MethodGet:<span class="cov7" title="15">
                err := r.ParseForm()
                if err != nil </span><span class="cov3" title="3">{
                        log.Printf("Error parsing form: %v", err)
                        http.Error(w, "Error parsing form", http.StatusBadRequest)
                        return
                }</span>
                <span class="cov6" title="12">indexStr := r.Form.Get("index")
                index, err := strconv.Atoi(indexStr)
                if err != nil </span><span class="cov3" title="3">{
                        log.Printf("Invalid index: %v", err)
                        http.Error(w, "Invalid index", http.StatusBadRequest)
                        return
                }</span>
                <span class="cov6" title="9">profiles := h.DataStore.ReadProfiles()
                if index &gt;= 0 &amp;&amp; index &lt; len(profiles) </span><span class="cov5" title="6">{
                        funcMap := templates.FuncMap
                        err := h.Renderer.Render(w, "delete_profile.html", funcMap, struct {
                                Index   int
                                Profile middleware.Profile
                        }{
                                Index:   index,
                                Profile: profiles[index],
                        }, "templates/delete_profile.html")
                        if err != nil </span><span class="cov3" title="3">{
                                log.Printf("Error rendering template: %v", err)
                                http.Error(w, "Error rendering template", http.StatusInternalServerError)
                                return
                        }</span>
                }
        case http.MethodPost:<span class="cov7" title="18">
                err := r.ParseForm()
                if err != nil </span><span class="cov3" title="3">{
                        log.Printf("Error parsing form: %v", err)
                        http.Error(w, "Error parsing form", http.StatusBadRequest)
                        return
                }</span>
                <span class="cov7" title="15">indexStr := r.Form.Get("index")
                index, err := strconv.Atoi(indexStr)
                if err != nil </span><span class="cov3" title="3">{
                        log.Printf("Invalid index: %v", err)
                        http.Error(w, "Invalid index", http.StatusBadRequest)
                        return
                }</span>
                <span class="cov6" title="12">profiles := h.DataStore.ReadProfiles()
                if index &gt;= 0 &amp;&amp; index &lt; len(profiles) </span><span class="cov5" title="6">{
                        profiles = append(profiles[:index], profiles[index+1:]...)
                }</span>
                <span class="cov6" title="12">err = h.DataStore.WriteProfiles(profiles)
                if err != nil </span><span class="cov3" title="3">{
                        log.Printf("Error writing profiles: %v", err)
                        http.Error(w, "Error writing profiles", http.StatusInternalServerError)
                        return
                }</span>
                <span class="cov6" title="9">log.Println("Profile deleted successfully")
                http.Redirect(w, r, "/profiles", http.StatusSeeOther)</span>
        default:<span class="cov3" title="3">
                http.Error(w, "Method not allowed", http.StatusMethodNotAllowed)</span>
        }
}

// ResetProfiles handles resetting profiles
func (h *Handler) ResetProfiles(w http.ResponseWriter, r *http.Request) <span class="cov7" title="15">{
        log.Println("Handling reset profiles")
        switch r.Method </span>{
        case http.MethodGet:<span class="cov5" title="6">
                if err := h.Renderer.RenderTemplateSimple(w, "reset_profiles.html", nil); err != nil </span><span class="cov3" title="3">{
                        log.Printf("Error rendering template: %v", err)
                        http.Error(w, "Error rendering template", http.StatusInternalServerError)
                }</span>
        case http.MethodPost:<span class="cov5" title="6">
                err := h.DataStore.WriteProfiles([]middleware.Profile{})
                if err != nil </span><span class="cov3" title="3">{
                        log.Printf("Error writing profiles: %v", err)
                        http.Error(w, "Error writing profiles", http.StatusInternalServerError)
                        return
                }</span>
                <span class="cov3" title="3">log.Println("Profiles reset successfully")
                http.Redirect(w, r, "/profiles", http.StatusSeeOther)</span>
        default:<span class="cov3" title="3">
                http.Error(w, "Method not allowed", http.StatusMethodNotAllowed)</span>
        }
}
</pre>
		
		<pre class="file" id="file4" style="display: none">package handlers

import (
        "encoding/json"
        "io"
        "llm-tournament/middleware"
        "llm-tournament/templates"
        "log"
        "net/http"
        "strconv"
)

var readAll = io.ReadAll

// PromptListHandler handles the prompt list page (backward compatible wrapper)
func PromptListHandler(w http.ResponseWriter, r *http.Request) <span class="cov6" title="15">{
        DefaultHandler.PromptList(w, r)
}</span>

// UpdatePromptsOrderHandler handles updating prompts order (backward compatible wrapper)
func UpdatePromptsOrderHandler(w http.ResponseWriter, r *http.Request) <span class="cov6" title="12">{
        DefaultHandler.UpdatePromptsOrder(w, r)
}</span>

// AddPromptHandler handles adding a prompt (backward compatible wrapper)
func AddPromptHandler(w http.ResponseWriter, r *http.Request) <span class="cov9" title="63">{
        DefaultHandler.AddPrompt(w, r)
}</span>

// ExportPromptsHandler handles exporting prompts (backward compatible wrapper)
func ExportPromptsHandler(w http.ResponseWriter, r *http.Request) <span class="cov6" title="15">{
        DefaultHandler.ExportPrompts(w, r)
}</span>

// ImportPromptsHandler handles importing prompts (backward compatible wrapper)
func ImportPromptsHandler(w http.ResponseWriter, r *http.Request) <span class="cov7" title="18">{
        DefaultHandler.ImportPrompts(w, r)
}</span>

// ImportResultsHandler handles importing results (backward compatible wrapper)
func ImportResultsHandler(w http.ResponseWriter, r *http.Request) <span class="cov7" title="24">{
        DefaultHandler.ImportResults(w, r)
}</span>

// EditPromptHandler handles editing a prompt (backward compatible wrapper)
func EditPromptHandler(w http.ResponseWriter, r *http.Request) <span class="cov7" title="18">{
        DefaultHandler.EditPrompt(w, r)
}</span>

// BulkDeletePromptsPageHandler handles bulk delete prompts page (backward compatible wrapper)
func BulkDeletePromptsPageHandler(w http.ResponseWriter, r *http.Request) <span class="cov6" title="12">{
        DefaultHandler.BulkDeletePromptsPage(w, r)
}</span>

// BulkDeletePromptsHandler handles bulk delete prompts (backward compatible wrapper)
func BulkDeletePromptsHandler(w http.ResponseWriter, r *http.Request) <span class="cov5" title="9">{
        DefaultHandler.BulkDeletePrompts(w, r)
}</span>

// DeletePromptHandler handles deleting a prompt (backward compatible wrapper)
func DeletePromptHandler(w http.ResponseWriter, r *http.Request) <span class="cov7" title="18">{
        DefaultHandler.DeletePrompt(w, r)
}</span>

// MovePromptHandler handles moving a prompt (backward compatible wrapper)
func MovePromptHandler(w http.ResponseWriter, r *http.Request) <span class="cov8" title="42">{
        DefaultHandler.MovePrompt(w, r)
}</span>

// ResetPromptsHandler handles resetting prompts (backward compatible wrapper)
func ResetPromptsHandler(w http.ResponseWriter, r *http.Request) <span class="cov6" title="15">{
        DefaultHandler.ResetPrompts(w, r)
}</span>

// PromptList handles the prompt list page
func (h *Handler) PromptList(w http.ResponseWriter, r *http.Request) <span class="cov8" title="42">{
        log.Println("Handling prompt list page")
        orderFilter := r.FormValue("order_filter")
        profileFilter := r.FormValue("profile_filter")
        searchQuery := r.FormValue("search_query")

        orderFilterInt := 0
        if orderFilter != "" </span><span class="cov6" title="12">{
                var err error
                orderFilterInt, err = strconv.Atoi(orderFilter)
                if err != nil </span><span class="cov4" title="6">{
                        log.Printf("Invalid order filter: %v", err)
                        http.Error(w, "Invalid order filter", http.StatusBadRequest)
                        return
                }</span>
        }

        <span class="cov8" title="36">funcMap := templates.FuncMap

        suites, err := h.DataStore.ListPromptSuites()
        if err != nil </span><span class="cov3" title="3">{
                log.Printf("Error listing prompt suites: %v", err)
                http.Error(w, "Error listing prompt suites", http.StatusInternalServerError)
                return
        }</span>

        <span class="cov8" title="33">currentSuite := h.DataStore.GetCurrentSuiteName()
        var prompts []middleware.Prompt
        if currentSuite == "" </span><span class="cov3" title="3">{
                currentSuite = "default"
        }</span>
        <span class="cov8" title="33">prompts, err = h.DataStore.ReadPromptSuite(currentSuite)
        if err != nil </span><span class="cov3" title="3">{
                log.Printf("Error reading prompt suite: %v", err)
                http.Error(w, "Error reading prompt suite", http.StatusInternalServerError)
                return
        }</span>
        <span class="cov8" title="30">if len(prompts) == 0 &amp;&amp; currentSuite == "default" </span><span class="cov6" title="12">{
                prompts, err = h.DataStore.ReadPromptSuite("default")
                if err != nil </span><span class="cov3" title="3">{
                        log.Printf("Error reading default prompt suite: %v", err)
                        http.Error(w, "Error reading default prompt suite", http.StatusInternalServerError)
                        return
                }</span>
        }
        <span class="cov7" title="27">promptTexts := make([]middleware.Prompt, len(prompts))
        promptIndices := make([]int, len(prompts))
        for i, prompt := range prompts </span><span class="cov7" title="27">{
                promptTexts[i] = prompt
                promptIndices[i] = i + 1
        }</span>

        <span class="cov7" title="27">profiles := h.DataStore.ReadProfiles()
        pageName := "Prompts"

        err = h.Renderer.Render(w, "prompt_list.html", funcMap, struct {
                PageName      string
                Prompts       []middleware.Prompt
                PromptIndices []int
                Profiles      []middleware.Profile
                OrderFilter   int
                ProfileFilter string
                SearchQuery   string
                Suites        []string
                CurrentSuite  string
                CurrentPath   string
        }{
                PageName:      pageName,
                Prompts:       promptTexts,
                PromptIndices: promptIndices,
                Profiles:      profiles,
                OrderFilter:   orderFilterInt,
                ProfileFilter: profileFilter,
                SearchQuery:   searchQuery,
                Suites:        suites,
                CurrentSuite:  currentSuite,
                CurrentPath:   "/prompts",
        }, "templates/prompt_list.html", "templates/nav.html")
        if err != nil </span><span class="cov4" title="6">{
                log.Printf("Error rendering template: %v", err)
                http.Error(w, "Error rendering template", http.StatusInternalServerError)
                return
        }</span>
        <span class="cov7" title="21">log.Println("Prompt list page rendered successfully")</span>
}

// UpdatePromptsOrder handles updating prompts order
func (h *Handler) UpdatePromptsOrder(w http.ResponseWriter, r *http.Request) <span class="cov6" title="15">{
        log.Println("Handling update prompts order")
        if r.Method != http.MethodPost </span><span class="cov3" title="3">{
                http.Error(w, "Method not allowed", http.StatusMethodNotAllowed)
                return
        }</span>
        <span class="cov6" title="12">err := r.ParseForm()
        if err != nil </span><span class="cov3" title="3">{
                log.Printf("Error parsing form: %v", err)
                http.Error(w, "Error parsing form", http.StatusBadRequest)
                return
        }</span>
        <span class="cov5" title="9">orderStr := r.Form.Get("order")
        if orderStr == "" </span><span class="cov3" title="3">{
                log.Println("Order cannot be empty")
                http.Error(w, "Order cannot be empty", http.StatusBadRequest)
                return
        }</span>
        <span class="cov4" title="6">var order []int
        err = json.Unmarshal([]byte(orderStr), &amp;order)
        if err != nil </span><span class="cov3" title="3">{
                log.Printf("Error parsing order: %v", err)
                http.Error(w, "Error parsing order", http.StatusBadRequest)
                return
        }</span>
        <span class="cov3" title="3">h.DataStore.UpdatePromptsOrder(order)
        http.Redirect(w, r, "/prompts", http.StatusSeeOther)</span>
}

// AddPrompt handles adding a prompt
func (h *Handler) AddPrompt(w http.ResponseWriter, r *http.Request) <span class="cov10" title="75">{
        log.Println("Handling add prompt")
        if r.Method != http.MethodPost </span><span class="cov3" title="3">{
                http.Error(w, "Method not allowed", http.StatusMethodNotAllowed)
                return
        }</span>
        <span class="cov9" title="72">err := r.ParseForm()
        if err != nil </span><span class="cov3" title="3">{
                log.Printf("Error parsing form: %v", err)
                http.Error(w, "Error parsing form", http.StatusBadRequest)
                return
        }</span>
        <span class="cov9" title="69">promptText := r.Form.Get("prompt")
        if promptText == "" </span><span class="cov3" title="3">{
                log.Println("Prompt text cannot be empty")
                http.Error(w, "Prompt text cannot be empty", http.StatusBadRequest)
                return
        }</span>
        <span class="cov9" title="66">solutionText := r.Form.Get("solution")
        profile := r.Form.Get("profile")

        currentSuite := h.DataStore.GetCurrentSuiteName()
        if currentSuite == "" </span><span class="cov3" title="3">{
                currentSuite = "default"
        }</span>

        <span class="cov9" title="66">prompts, err := h.DataStore.ReadPromptSuite(currentSuite)
        if err != nil </span><span class="cov3" title="3">{
                log.Printf("Error reading prompt suite: %v", err)
                http.Error(w, "Error reading prompt suite", http.StatusInternalServerError)
                return
        }</span>

        <span class="cov9" title="63">prompts = append(prompts, middleware.Prompt{Text: promptText, Solution: solutionText, Profile: profile})
        err = h.DataStore.WritePromptSuite(currentSuite, prompts)
        if err != nil </span><span class="cov3" title="3">{
                log.Printf("Error writing prompts: %v", err)
                http.Error(w, "Error writing prompts", http.StatusInternalServerError)
                return
        }</span>
        <span class="cov9" title="60">log.Println("Prompt added successfully")
        h.DataStore.BroadcastResults()
        http.Redirect(w, r, "/prompts", http.StatusSeeOther)</span>
}

// ExportPrompts handles exporting prompts
func (h *Handler) ExportPrompts(w http.ResponseWriter, r *http.Request) <span class="cov7" title="18">{
        log.Println("Handling export prompts")
        if r.Method != http.MethodGet </span><span class="cov3" title="3">{
                http.Error(w, "Method not allowed", http.StatusMethodNotAllowed)
                return
        }</span>
        <span class="cov6" title="15">prompts := h.DataStore.ReadPrompts()

        // Convert prompts to JSON
        jsonData, _ := json.MarshalIndent(prompts, "", "  ")

        // Set headers for JSON download
        w.Header().Set("Content-Type", "application/json")
        w.Header().Set("Content-Disposition", "attachment;filename=prompts.json")

        // Write JSON to response
        _, err := w.Write(jsonData)
        if err != nil </span><span class="cov3" title="3">{
                log.Printf("Error writing response: %v", err)
                http.Error(w, "Error writing response", http.StatusInternalServerError)
                return
        }</span>
        <span class="cov6" title="12">log.Println("Prompts exported successfully as JSON")</span>
}

// ImportPrompts handles importing prompts
func (h *Handler) ImportPrompts(w http.ResponseWriter, r *http.Request) <span class="cov7" title="27">{
        log.Println("Handling import prompts")
        switch r.Method </span>{
        case http.MethodPost:<span class="cov7" title="18">
                file, _, err := r.FormFile("prompts_file")
                if err != nil </span><span class="cov3" title="3">{
                        log.Printf("Error uploading file: %v", err)
                        http.Redirect(w, r, "/import_error", http.StatusSeeOther)
                        return
                }</span>
                <span class="cov6" title="15">defer func() </span><span class="cov6" title="15">{ _ = file.Close() }</span>()

                // Read the file content
                <span class="cov6" title="15">data, err := readAll(file)
                if err != nil </span><span class="cov3" title="3">{
                        log.Printf("Error reading file: %v", err)
                        http.Error(w, "Error reading file", http.StatusInternalServerError)
                        return
                }</span>

                // Parse JSON data
                <span class="cov6" title="12">var prompts []middleware.Prompt
                err = json.Unmarshal(data, &amp;prompts)
                if err != nil </span><span class="cov3" title="3">{
                        log.Printf("Error parsing JSON: %v", err)
                        http.Redirect(w, r, "/import_error", http.StatusSeeOther)
                        return
                }</span>

                // Validate imported prompts
                <span class="cov5" title="9">if len(prompts) == 0 </span><span class="cov3" title="3">{
                        log.Println("No prompts found in JSON file")
                        http.Redirect(w, r, "/import_error", http.StatusSeeOther)
                        return
                }</span>

                // Write the imported prompts
                <span class="cov4" title="6">err = h.DataStore.WritePrompts(prompts)
                if err != nil </span><span class="cov3" title="3">{
                        log.Printf("Error writing prompts: %v", err)
                        http.Error(w, "Error writing prompts", http.StatusInternalServerError)
                        return
                }</span>

                <span class="cov3" title="3">log.Println("Prompts imported successfully from JSON")
                h.DataStore.BroadcastResults()
                http.Redirect(w, r, "/prompts", http.StatusSeeOther)</span>
        case http.MethodGet:<span class="cov4" title="6">
                if err := h.Renderer.RenderTemplateSimple(w, "import_prompts.html", nil); err != nil </span><span class="cov3" title="3">{
                        log.Printf("Error rendering template: %v", err)
                        http.Error(w, "Error rendering template", http.StatusInternalServerError)
                }</span>
        default:<span class="cov3" title="3">
                http.Error(w, "Method not allowed", http.StatusMethodNotAllowed)</span>
        }
}

// ImportResults handles importing results
func (h *Handler) ImportResults(w http.ResponseWriter, r *http.Request) <span class="cov8" title="36">{
        log.Println("Handling import results")
        switch r.Method </span>{
        case http.MethodPost:<span class="cov7" title="27">
                file, _, err := r.FormFile("results_file")
                if err != nil </span><span class="cov3" title="3">{
                        log.Printf("Error uploading file: %v", err)
                        http.Redirect(w, r, "/import_error", http.StatusSeeOther)
                        return
                }</span>
                <span class="cov7" title="24">defer func() </span><span class="cov7" title="24">{ _ = file.Close() }</span>()

                // Read the file content
                <span class="cov7" title="24">data, err := readAll(file)
                if err != nil </span><span class="cov3" title="3">{
                        log.Printf("Error reading file: %v", err)
                        http.Error(w, "Error reading file", http.StatusInternalServerError)
                        return
                }</span>

                // Parse JSON data
                <span class="cov7" title="21">var results map[string]middleware.Result
                err = json.Unmarshal(data, &amp;results)
                if err != nil </span><span class="cov3" title="3">{
                        log.Printf("Error parsing JSON: %v", err)
                        http.Redirect(w, r, "/import_error", http.StatusSeeOther)
                        return
                }</span>

                // Validate imported results
                <span class="cov7" title="18">if len(results) == 0 </span><span class="cov4" title="6">{
                        log.Println("No results found in JSON file")
                        http.Redirect(w, r, "/import_error", http.StatusSeeOther)
                        return
                }</span>

                // Ensure scores arrays match prompts length
                <span class="cov6" title="12">prompts := h.DataStore.ReadPrompts()
                for model, result := range results </span><span class="cov6" title="15">{
                        if len(result.Scores) &lt; len(prompts) </span><span class="cov4" title="6">{
                                newScores := make([]int, len(prompts))
                                copy(newScores, result.Scores)
                                result.Scores = newScores
                                results[model] = result
                        }</span>
                }

                // Write the imported results
                <span class="cov6" title="12">suiteName := h.DataStore.GetCurrentSuiteName()
                err = h.DataStore.WriteResults(suiteName, results)
                if err != nil </span><span class="cov3" title="3">{
                        log.Printf("Error writing results: %v", err)
                        http.Error(w, "Error writing results", http.StatusInternalServerError)
                        return
                }</span>

                <span class="cov5" title="9">log.Println("Results imported successfully from JSON")
                h.DataStore.BroadcastResults()
                http.Redirect(w, r, "/results", http.StatusSeeOther)</span>
        case http.MethodGet:<span class="cov4" title="6">
                if err := h.Renderer.RenderTemplateSimple(w, "import_results.html", nil); err != nil </span><span class="cov3" title="3">{
                        log.Printf("Error rendering template: %v", err)
                        http.Error(w, "Error rendering template", http.StatusInternalServerError)
                }</span>
        default:<span class="cov3" title="3">
                http.Error(w, "Method not allowed", http.StatusMethodNotAllowed)</span>
        }
}

// EditPrompt handles editing a prompt
func (h *Handler) EditPrompt(w http.ResponseWriter, r *http.Request) <span class="cov8" title="30">{
        log.Println("Handling edit prompt")
        switch r.Method </span>{
        case "GET":<span class="cov6" title="12">
                err := r.ParseForm()
                if err != nil </span><span class="cov3" title="3">{
                        log.Printf("Error parsing form: %v", err)
                        http.Error(w, "Error parsing form", http.StatusBadRequest)
                        return
                }</span>
                <span class="cov5" title="9">indexStr := r.Form.Get("index")
                index, err := strconv.Atoi(indexStr)
                if err != nil </span><span class="cov3" title="3">{
                        log.Printf("Invalid index: %v", err)
                        http.Error(w, "Invalid index", http.StatusBadRequest)
                        return
                }</span>
                <span class="cov4" title="6">prompts := h.DataStore.ReadPrompts()
                if index &gt;= 0 &amp;&amp; index &lt; len(prompts) </span><span class="cov4" title="6">{
                        funcMap := templates.FuncMap
                        profiles := h.DataStore.ReadProfiles()
                        err := h.Renderer.Render(w, "edit_prompt.html", funcMap, struct {
                                Index    int
                                Prompt   middleware.Prompt
                                Profiles []middleware.Profile
                        }{
                                Index:    index,
                                Prompt:   prompts[index],
                                Profiles: profiles,
                        }, "templates/edit_prompt.html")
                        if err != nil </span><span class="cov3" title="3">{
                                log.Printf("Error rendering template: %v", err)
                                http.Error(w, "Error rendering template", http.StatusInternalServerError)
                                return
                        }</span>
                }
        case "POST":<span class="cov6" title="15">
                err := r.ParseForm()
                if err != nil </span><span class="cov3" title="3">{
                        log.Printf("Error parsing form: %v", err)
                        http.Error(w, "Error parsing form", http.StatusBadRequest)
                        return
                }</span>
                <span class="cov6" title="12">indexStr := r.Form.Get("index")
                index, err := strconv.Atoi(indexStr)
                if err != nil </span><span class="cov3" title="3">{
                        log.Printf("Invalid index: %v", err)
                        http.Error(w, "Invalid index", http.StatusBadRequest)
                        return
                }</span>
                <span class="cov5" title="9">editedPrompt := r.Form.Get("prompt")
                editedSolution := r.Form.Get("solution")
                editedProfile := r.Form.Get("profile")
                if editedPrompt == "" </span><span class="cov3" title="3">{
                        log.Println("Prompt text cannot be empty")
                        http.Error(w, "Prompt text cannot be empty", http.StatusBadRequest)
                        return
                }</span>
                <span class="cov4" title="6">prompts := h.DataStore.ReadPrompts()
                if index &gt;= 0 &amp;&amp; index &lt; len(prompts) </span><span class="cov4" title="6">{
                        prompts[index].Text = editedPrompt
                        prompts[index].Solution = editedSolution
                        prompts[index].Profile = editedProfile
                }</span>
                <span class="cov4" title="6">err = h.DataStore.WritePrompts(prompts)
                if err != nil </span><span class="cov3" title="3">{
                        log.Printf("Error writing prompts: %v", err)
                        http.Error(w, "Error writing prompts", http.StatusInternalServerError)
                        return
                }</span>
                <span class="cov3" title="3">log.Println("Prompt edited successfully")
                h.DataStore.BroadcastResults()
                http.Redirect(w, r, "/prompts", http.StatusSeeOther)</span>
        default:<span class="cov3" title="3">
                http.Error(w, "Method not allowed", http.StatusMethodNotAllowed)</span>
        }
}

// BulkDeletePromptsPage handles bulk delete prompts page
func (h *Handler) BulkDeletePromptsPage(w http.ResponseWriter, r *http.Request) <span class="cov6" title="15">{
        log.Println("Handling bulk delete prompts page")
        if r.Method != "GET" </span><span class="cov3" title="3">{
                http.Error(w, "Method not allowed", http.StatusMethodNotAllowed)
                return
        }</span>

        <span class="cov6" title="12">indicesStr := r.URL.Query().Get("indices")
        if indicesStr == "" </span><span class="cov3" title="3">{
                log.Println("No indices provided for deletion")
                http.Error(w, "No indices provided for deletion", http.StatusBadRequest)
                return
        }</span>

        <span class="cov5" title="9">var indices []int
        err := json.Unmarshal([]byte(indicesStr), &amp;indices)
        if err != nil </span><span class="cov3" title="3">{
                log.Printf("Error unmarshalling indices: %v", err)
                http.Error(w, "Error unmarshalling indices", http.StatusBadRequest)
                return
        }</span>

        <span class="cov4" title="6">prompts := h.DataStore.ReadPrompts()
        var selectedPrompts []middleware.Prompt
        for _, index := range indices </span><span class="cov4" title="6">{
                if index &gt;= 0 &amp;&amp; index &lt; len(prompts) </span><span class="cov4" title="6">{
                        selectedPrompts = append(selectedPrompts, prompts[index])
                }</span>
        }

        <span class="cov4" title="6">funcMap := templates.FuncMap

        err = h.Renderer.Render(w, "bulk_delete_prompts.html", funcMap, struct {
                Indices string
                Prompts []middleware.Prompt
        }{
                Indices: indicesStr,
                Prompts: selectedPrompts,
        }, "templates/bulk_delete_prompts.html")
        if err != nil </span><span class="cov3" title="3">{
                log.Printf("Error rendering template: %v", err)
                http.Error(w, "Error rendering template", http.StatusInternalServerError)
                return
        }</span>
}

// BulkDeletePrompts handles bulk delete prompts
func (h *Handler) BulkDeletePrompts(w http.ResponseWriter, r *http.Request) <span class="cov7" title="18">{
        log.Println("Handling bulk delete prompts")
        if r.Method != "POST" </span><span class="cov3" title="3">{
                http.Error(w, "Method not allowed", http.StatusMethodNotAllowed)
                return
        }</span>

        <span class="cov6" title="15">var request struct {
                Indices []int `json:"indices"`
        }

        err := json.NewDecoder(r.Body).Decode(&amp;request)
        if err != nil </span><span class="cov3" title="3">{
                log.Printf("Error decoding request: %v", err)
                http.Error(w, "Error decoding request", http.StatusBadRequest)
                return
        }</span>

        <span class="cov6" title="12">indices := request.Indices

        prompts := h.DataStore.ReadPrompts()
        if len(prompts) == 0 </span><span class="cov3" title="3">{
                log.Println("No prompts to delete")
                http.Error(w, "No prompts to delete", http.StatusBadRequest)
                return
        }</span>

        <span class="cov5" title="9">if len(indices) == 0 </span><span class="cov3" title="3">{
                log.Println("No indices provided for deletion")
                http.Error(w, "No indices provided for deletion", http.StatusBadRequest)
                return
        }</span>

        <span class="cov4" title="6">var filteredPrompts []middleware.Prompt
        for i, prompt := range prompts </span><span class="cov7" title="18">{
                found := false
                for _, index := range indices </span><span class="cov8" title="30">{
                        if i == index </span><span class="cov6" title="12">{
                                found = true
                                break</span>
                        }
                }
                <span class="cov7" title="18">if !found </span><span class="cov4" title="6">{
                        filteredPrompts = append(filteredPrompts, prompt)
                }</span>
        }

        <span class="cov4" title="6">err = h.DataStore.WritePrompts(filteredPrompts)
        if err != nil </span><span class="cov3" title="3">{
                log.Printf("Error writing prompts: %v", err)
                http.Error(w, "Error writing prompts", http.StatusInternalServerError)
                return
        }</span>

        <span class="cov3" title="3">log.Println("Prompts deleted successfully")
        h.DataStore.BroadcastResults()
        w.WriteHeader(http.StatusOK)</span>
}

// DeletePrompt handles deleting a prompt
func (h *Handler) DeletePrompt(w http.ResponseWriter, r *http.Request) <span class="cov8" title="30">{
        log.Println("Handling delete prompt")
        switch r.Method </span>{
        case "GET":<span class="cov6" title="15">
                err := r.ParseForm()
                if err != nil </span><span class="cov3" title="3">{
                        log.Printf("Error parsing form: %v", err)
                        http.Error(w, "Error parsing form", http.StatusBadRequest)
                        return
                }</span>
                <span class="cov6" title="12">indexStr := r.Form.Get("index")
                index, err := strconv.Atoi(indexStr)
                if err != nil </span><span class="cov3" title="3">{
                        log.Printf("Invalid index: %v", err)
                        http.Error(w, "Invalid index", http.StatusBadRequest)
                        return
                }</span>
                <span class="cov5" title="9">prompts := h.DataStore.ReadPrompts()
                if index &gt;= 0 &amp;&amp; index &lt; len(prompts) </span><span class="cov4" title="6">{
                        funcMap := templates.FuncMap
                        err := h.Renderer.Render(w, "delete_prompt.html", funcMap, struct {
                                Index  int
                                Prompt middleware.Prompt
                        }{
                                Index:  index,
                                Prompt: prompts[index],
                        }, "templates/delete_prompt.html")
                        if err != nil </span><span class="cov3" title="3">{
                                log.Printf("Error rendering template: %v", err)
                                http.Error(w, "Error rendering template", http.StatusInternalServerError)
                                return
                        }</span>
                }
        case "POST":<span class="cov6" title="12">
                err := r.ParseForm()
                if err != nil </span><span class="cov3" title="3">{
                        log.Printf("Error parsing form: %v", err)
                        http.Error(w, "Error parsing form", http.StatusBadRequest)
                        return
                }</span>
                <span class="cov5" title="9">indexStr := r.Form.Get("index")
                index, err := strconv.Atoi(indexStr)
                if err != nil </span><span class="cov3" title="3">{
                        log.Printf("Invalid index: %v", err)
                        http.Error(w, "Invalid index", http.StatusBadRequest)
                        return
                }</span>
                <span class="cov4" title="6">prompts := h.DataStore.ReadPrompts()
                if index &gt;= 0 &amp;&amp; index &lt; len(prompts) </span><span class="cov4" title="6">{
                        prompts = append(prompts[:index], prompts[index+1:]...)
                }</span>
                <span class="cov4" title="6">err = h.DataStore.WritePrompts(prompts)
                if err != nil </span><span class="cov3" title="3">{
                        log.Printf("Error writing prompts: %v", err)
                        http.Error(w, "Error writing prompts", http.StatusInternalServerError)
                        return
                }</span>
                <span class="cov3" title="3">log.Println("Prompt deleted successfully")
                h.DataStore.BroadcastResults()
                http.Redirect(w, r, "/prompts", http.StatusSeeOther)</span>
        default:<span class="cov3" title="3">
                http.Error(w, "Method not allowed", http.StatusMethodNotAllowed)</span>
        }
}

// MovePrompt handles moving a prompt
func (h *Handler) MovePrompt(w http.ResponseWriter, r *http.Request) <span class="cov9" title="54">{
        log.Println("Handling move prompt")
        switch r.Method </span>{
        case "GET":<span class="cov6" title="12">
                err := r.ParseForm()
                if err != nil </span><span class="cov3" title="3">{
                        log.Printf("Error parsing form: %v", err)
                        http.Error(w, "Error parsing form", http.StatusBadRequest)
                        return
                }</span>
                <span class="cov5" title="9">indexStr := r.Form.Get("index")
                index, err := strconv.Atoi(indexStr)
                if err != nil </span><span class="cov3" title="3">{
                        log.Printf("Invalid index: %v", err)
                        http.Error(w, "Invalid index", http.StatusBadRequest)
                        return
                }</span>
                <span class="cov4" title="6">prompts := h.DataStore.ReadPrompts()
                if index &gt;= 0 &amp;&amp; index &lt; len(prompts) </span><span class="cov3" title="3">{
                        funcMap := templates.FuncMap
                        err := h.Renderer.Render(w, "move_prompt.html", funcMap, struct {
                                Index   int
                                Prompt  string
                                Prompts []middleware.Prompt
                        }{
                                Index:   index,
                                Prompt:  prompts[index].Text,
                                Prompts: prompts,
                        }, "templates/move_prompt.html")
                        if err != nil </span><span class="cov3" title="3">{
                                log.Printf("Error rendering template: %v", err)
                                http.Error(w, "Error rendering template", http.StatusInternalServerError)
                                return
                        }</span>
                }
        case "POST":<span class="cov8" title="39">
                err := r.ParseForm()
                if err != nil </span><span class="cov3" title="3">{
                        log.Printf("Error parsing form: %v", err)
                        http.Error(w, "Error parsing form", http.StatusBadRequest)
                        return
                }</span>
                <span class="cov8" title="36">indexStr := r.Form.Get("index")
                index, err := strconv.Atoi(indexStr)
                if err != nil </span><span class="cov7" title="18">{
                        log.Printf("Invalid index: %v", err)
                        http.Error(w, "Invalid index", http.StatusBadRequest)
                        return
                }</span>
                <span class="cov7" title="18">newIndexStr := r.Form.Get("new_index")
                newIndex, err := strconv.Atoi(newIndexStr)
                if err != nil </span><span class="cov3" title="3">{
                        log.Printf("Invalid new index: %v", err)
                        http.Error(w, "Invalid new index", http.StatusBadRequest)
                        return
                }</span>
                <span class="cov6" title="15">prompts := h.DataStore.ReadPrompts()
                if index &gt;= 0 &amp;&amp; index &lt; len(prompts) &amp;&amp; newIndex &gt;= 0 &amp;&amp; newIndex &lt;= len(prompts) </span><span class="cov6" title="12">{
                        prompt := prompts[index]
                        prompts = append(prompts[:index], prompts[index+1:]...)
                        if newIndex &gt; index </span><span class="cov4" title="6">{
                                newIndex--
                        }</span>
                        <span class="cov6" title="12">prompts = append(prompts[:newIndex], append([]middleware.Prompt{prompt}, prompts[newIndex:]...)...)</span>
                }
                <span class="cov6" title="15">err = h.DataStore.WritePrompts(prompts)
                if err != nil </span><span class="cov3" title="3">{
                        log.Printf("Error writing prompts: %v", err)
                        http.Error(w, "Error writing prompts", http.StatusInternalServerError)
                        return
                }</span>
                <span class="cov6" title="12">log.Println("Prompt moved successfully")
                h.DataStore.BroadcastResults()
                http.Redirect(w, r, "/prompts", http.StatusSeeOther)</span>
        default:<span class="cov3" title="3">
                http.Error(w, "Method not allowed", http.StatusMethodNotAllowed)</span>
        }
}

// ResetPrompts handles resetting prompts
func (h *Handler) ResetPrompts(w http.ResponseWriter, r *http.Request) <span class="cov7" title="18">{
        log.Println("Handling reset prompts")
        switch r.Method </span>{
        case "GET":<span class="cov5" title="9">
                if err := h.Renderer.RenderTemplateSimple(w, "reset_prompts.html", nil); err != nil </span><span class="cov3" title="3">{
                        log.Printf("Error rendering template: %v", err)
                        http.Error(w, "Error rendering template", http.StatusInternalServerError)
                }</span>
        case "POST":<span class="cov4" title="6">
                err := h.DataStore.WritePrompts([]middleware.Prompt{})
                if err != nil </span><span class="cov3" title="3">{
                        log.Printf("Error writing prompts: %v", err)
                        http.Error(w, "Error writing prompts", http.StatusInternalServerError)
                        return
                }</span>
                <span class="cov3" title="3">log.Println("Prompts reset successfully")
                h.DataStore.BroadcastResults()
                http.Redirect(w, r, "/prompts", http.StatusSeeOther)</span>
        default:<span class="cov3" title="3">
                http.Error(w, "Method not allowed", http.StatusMethodNotAllowed)</span>
        }
}
</pre>
		
		<pre class="file" id="file5" style="display: none">package handlers

import (
        "encoding/json"
        "io"
        "llm-tournament/middleware"
        "llm-tournament/templates"
        "log"
        "math/rand"
        "net/http"
        "sort"
        "strconv"
        "strings"
        "time"
)

// min returns the smaller of x or y
func min(x, y int) int <span class="cov8" title="12570">{
        if x &lt; y </span><span class="cov8" title="9209">{
                return x
        }</span>
        <span class="cov7" title="3361">return y</span>
}

// max returns the larger of x or y
func max(x, y int) int <span class="cov8" title="12519">{
        if x &gt; y </span><span class="cov8" title="9266">{
                return x
        }</span>
        <span class="cov7" title="3253">return y</span>
}

// initRand returns a new random number generator seeded with the current time
func initRand() *rand.Rand <span class="cov3" title="15">{
        source := rand.NewSource(time.Now().UnixNano())
        return rand.New(source)
}</span>

// GroupedPrompt represents a prompt with its profile information
type GroupedPrompt struct {
        Index       int
        Text        string
        ProfileID   string
        ProfileName string
}

// ResultsHandler handles the results page (backward compatible wrapper)
func ResultsHandler(w http.ResponseWriter, r *http.Request) <span class="cov3" title="18">{
        DefaultHandler.Results(w, r)
}</span>

// UpdateResultHandler handles updating results (backward compatible wrapper)
func UpdateResultHandler(w http.ResponseWriter, r *http.Request) <span class="cov3" title="18">{
        DefaultHandler.UpdateResult(w, r)
}</span>

// ResetResultsHandler handles resetting results (backward compatible wrapper)
func ResetResultsHandler(w http.ResponseWriter, r *http.Request) <span class="cov2" title="12">{
        DefaultHandler.ResetResults(w, r)
}</span>

// ConfirmRefreshResultsHandler handles confirm refresh results (backward compatible wrapper)
func ConfirmRefreshResultsHandler(w http.ResponseWriter, r *http.Request) <span class="cov2" title="12">{
        DefaultHandler.ConfirmRefreshResults(w, r)
}</span>

// RefreshResultsHandler handles refresh results (backward compatible wrapper)
func RefreshResultsHandler(w http.ResponseWriter, r *http.Request) <span class="cov2" title="12">{
        DefaultHandler.RefreshResults(w, r)
}</span>

// EvaluateResult handles evaluating individual results (backward compatible wrapper)
func EvaluateResult(w http.ResponseWriter, r *http.Request) <span class="cov3" title="24">{
        DefaultHandler.EvaluateResultHandler(w, r)
}</span>

// ExportResultsHandler handles exporting results (backward compatible wrapper)
func ExportResultsHandler(w http.ResponseWriter, r *http.Request) <span class="cov2" title="12">{
        DefaultHandler.ExportResults(w, r)
}</span>

// UpdateMockResultsHandler handles updating mock results (backward compatible wrapper)
func UpdateMockResultsHandler(w http.ResponseWriter, r *http.Request) <span class="cov3" title="18">{
        DefaultHandler.UpdateMockResults(w, r)
}</span>

// Results handles the results page
func (h *Handler) Results(w http.ResponseWriter, r *http.Request) <span class="cov3" title="33">{
        log.Println("Handling results page")
        prompts := h.DataStore.ReadPrompts()
        results := h.DataStore.ReadResults()

        // Group prompts by profile
        var orderedPrompts []GroupedPrompt

        // Get all profiles first (to include empty ones)
        profiles := h.DataStore.ReadProfiles()

        // Get profile groups using the utility function
        profileGroups, profileMap := middleware.GetProfileGroups(prompts, profiles)

        // Check if we have any uncategorized prompts
        hasUncategorized := false
        for _, prompt := range prompts </span><span class="cov4" title="48">{
                if prompt.Profile == "" </span><span class="cov3" title="21">{
                        hasUncategorized = true
                        break</span>
                }
        }

        // Add a group for prompts with no profile only if needed
        <span class="cov3" title="33">if hasUncategorized </span><span class="cov3" title="21">{
                noProfileGroup := &amp;middleware.ProfileGroup{
                        ID:       "none",
                        Name:     "Uncategorized",
                        Color:    "hsl(0, 0%, 50%)",
                        StartCol: -1,
                        EndCol:   -1,
                }
                profileGroups = append(profileGroups, noProfileGroup)
                profileMap[""] = noProfileGroup
        }</span>

        // Process prompts and assign them to profile groups
        <span class="cov3" title="33">currentCol := 0
        for i, prompt := range prompts </span><span class="cov4" title="54">{
                profileName := prompt.Profile

                group := profileMap[profileName]

                if group.StartCol == -1 </span><span class="cov3" title="39">{
                        group.StartCol = currentCol
                }</span>
                <span class="cov4" title="54">group.EndCol = currentCol

                orderedPrompts = append(orderedPrompts, GroupedPrompt{
                        Index:       i,
                        Text:        prompt.Text,
                        ProfileID:   group.ID,
                        ProfileName: profileName,
                })

                currentCol++</span>
        }

        <span class="cov3" title="33">log.Println("Calculating total scores for each model")
        // Calculate total scores for each model
        modelScores := make(map[string]int)
        for model, result := range results </span><span class="cov3" title="42">{
                totalScore := 0
                for _, score := range result.Scores </span><span class="cov4" title="66">{
                        totalScore += score
                }</span>
                <span class="cov3" title="42">modelScores[model] = totalScore</span>
        }

        <span class="cov3" title="33">log.Println("Sorting models by score in descending order")
        // Sort models by score in descending order
        models := make([]string, 0, len(results))
        for model := range results </span><span class="cov3" title="42">{
                models = append(models, model)
        }</span>
        <span class="cov3" title="33">sort.Slice(models, func(i, j int) bool </span><span class="cov2" title="12">{
                return modelScores[models[i]] &gt; modelScores[models[j]]
        }</span>)
        <span class="cov3" title="33">log.Printf("Sorted models: %v", models)

        modelFilter := r.FormValue("model_filter")
        searchQuery := strings.ToLower(r.FormValue("search"))

        filteredResults := make(map[string]middleware.Result)
        for model, result := range results </span><span class="cov3" title="42">{
                // Apply model filter if specified
                if modelFilter != "" &amp;&amp; model != modelFilter </span><span class="cov1" title="3">{
                        continue</span>
                }
                // Apply search filter if specified
                <span class="cov3" title="39">if searchQuery != "" &amp;&amp; !strings.Contains(strings.ToLower(model), searchQuery) </span><span class="cov1" title="3">{
                        continue</span>
                }
                <span class="cov3" title="36">filteredResults[model] = result</span>
        }

        <span class="cov3" title="33">pageName := templates.PageNameResults
        promptTexts := make([]string, len(prompts))
        for i, prompt := range prompts </span><span class="cov4" title="54">{
                promptTexts[i] = prompt.Text
        }</span>
        <span class="cov3" title="33">resultsForTemplate := make(map[string]middleware.Result)
        for model, result := range filteredResults </span><span class="cov3" title="36">{
                // Initialize scores array if nil
                if result.Scores == nil </span><span class="cov1" title="3">{
                        result.Scores = make([]int, len(prompts))
                }</span>

                // Ensure scores array matches prompts length
                <span class="cov3" title="36">if len(result.Scores) != len(prompts) </span><span class="cov1" title="3">{
                        newScores := make([]int, len(prompts))
                        copy(newScores, result.Scores)
                        result.Scores = newScores
                }</span>

                // Ensure all scores are valid (0-100)
                <span class="cov3" title="36">for i, score := range result.Scores </span><span class="cov4" title="69">{
                        if score &lt; 0 || score &gt; 100 </span><span class="cov1" title="3">{
                                result.Scores[i] = 0
                        }</span>
                }

                // Create a new Result struct to ensure proper initialization
                <span class="cov3" title="36">resultsForTemplate[model] = middleware.Result{
                        Scores: result.Scores,
                }</span>
        }
        <span class="cov3" title="33">modelPassPercentages := make(map[string]float64)
        modelTotalScores := make(map[string]int)
        promptIndices := make([]int, len(prompts))
        for i := range prompts </span><span class="cov4" title="54">{
                promptIndices[i] = i + 1
        }</span>
        <span class="cov3" title="33">for model, result := range filteredResults </span><span class="cov3" title="36">{
                totalScore := 0
                for _, score := range result.Scores </span><span class="cov4" title="60">{
                        totalScore += score
                }</span>
                // Avoid division by zero when there are no prompts
                <span class="cov3" title="36">if len(prompts) &gt; 0 </span><span class="cov3" title="33">{
                        modelPassPercentages[model] = float64(totalScore) / float64(len(prompts)*100) * 100
                }</span> else<span class="cov1" title="3"> {
                        modelPassPercentages[model] = 0
                }</span>
                <span class="cov3" title="36">modelTotalScores[model] = totalScore</span>
        }

        // Log the data we're about to send to the template for debugging
        <span class="cov3" title="33">if len(models) &gt; 0 &amp;&amp; len(promptTexts) &gt; 0 </span><span class="cov3" title="27">{
                log.Printf("First model: %s, scores: %v", models[0], resultsForTemplate[models[0]].Scores)
        }</span>

        <span class="cov3" title="33">templateData := struct {
                PageName        string
                Prompts         []string
                Results         map[string]middleware.Result
                Models          []string
                PassPercentages map[string]float64
                ModelFilter     string
                TotalScores     map[string]int
                PromptIndices   []int
                SearchQuery     string
                ProfileGroups   []*middleware.ProfileGroup
                OrderedPrompts  []GroupedPrompt
                CurrentPath     string
        }{
                PageName:        pageName,
                Prompts:         promptTexts,
                Results:         resultsForTemplate,
                Models:          models,
                PassPercentages: modelPassPercentages,
                ModelFilter:     modelFilter,
                TotalScores:     modelTotalScores,
                PromptIndices:   promptIndices,
                SearchQuery:     searchQuery,
                ProfileGroups:   profileGroups,
                OrderedPrompts:  orderedPrompts,
                CurrentPath:     "/results",
        }

        err := h.Renderer.Render(w, "results.html", templates.FuncMap, templateData, "templates/results.html", "templates/nav.html")
        if err != nil </span><span class="cov1" title="3">{
                log.Printf("Error rendering template: %v", err)
                http.Error(w, "Error rendering template", http.StatusInternalServerError)
                return
        }</span>
        <span class="cov3" title="30">log.Println("Results page rendered successfully")</span>
}

// UpdateResult handles AJAX requests to update results
func (h *Handler) UpdateResult(w http.ResponseWriter, r *http.Request) <span class="cov3" title="33">{
        log.Println("Handling update result")
        _ = r.ParseForm()
        model := r.Form.Get("model")
        promptIndexStr := r.Form.Get("promptIndex")
        passStr := r.Form.Get("pass")
        promptIndex, _ := strconv.Atoi(promptIndexStr)
        pass, err := strconv.ParseBool(passStr)
        if err != nil </span><span class="cov2" title="6">{
                log.Printf("Invalid pass value: %v", err)
                http.Error(w, "Invalid pass value", http.StatusBadRequest)
                return
        }</span>

        <span class="cov3" title="27">suiteName := h.DataStore.GetCurrentSuiteName()
        results := h.DataStore.ReadResults()
        if results == nil </span><span class="cov1" title="3">{
                results = make(map[string]middleware.Result)
        }</span>
        <span class="cov3" title="27">if _, ok := results[model]; !ok </span><span class="cov2" title="9">{
                results[model] = middleware.Result{
                        Scores: make([]int, len(h.DataStore.ReadPrompts())),
                }
        }</span>

        <span class="cov3" title="27">prompts := h.DataStore.ReadPrompts()
        result := results[model]
        if len(result.Scores) &lt; len(prompts) </span><span class="cov1" title="3">{
                result.Scores = append(result.Scores, make([]int, len(prompts)-len(result.Scores))...)
        }</span>
        <span class="cov3" title="27">if promptIndex &gt;= 0 &amp;&amp; promptIndex &lt; len(result.Scores) </span><span class="cov3" title="21">{
                if pass </span><span class="cov3" title="18">{
                        result.Scores[promptIndex] = 100
                }</span> else<span class="cov1" title="3"> {
                        result.Scores[promptIndex] = 0
                }</span>
        }
        <span class="cov3" title="27">results[model] = result
        err = h.DataStore.WriteResults(suiteName, results)
        if err != nil </span><span class="cov1" title="3">{
                log.Printf("Error writing results: %v", err)
                http.Error(w, "Error writing results", http.StatusInternalServerError)
                return
        }</span>

        <span class="cov3" title="24">h.DataStore.BroadcastResults()

        _, err = w.Write([]byte("OK"))
        if err != nil </span><span class="cov1" title="3">{
                log.Printf("Error writing response: %v", err)
                http.Error(w, "Error writing response", http.StatusInternalServerError)
                return
        }</span>
        <span class="cov3" title="21">log.Println("protocols.Result updated successfully")</span>
}

// ResetResults handles resetting results
func (h *Handler) ResetResults(w http.ResponseWriter, r *http.Request) <span class="cov3" title="18">{
        log.Println("Handling reset results")
        switch r.Method </span>{
        case "GET":<span class="cov2" title="6">
                if err := h.Renderer.RenderTemplateSimple(w, "reset_results.html", nil); err != nil </span><span class="cov1" title="3">{
                        log.Printf("Error rendering template: %v", err)
                        http.Error(w, "Error rendering template", http.StatusInternalServerError)
                }</span>
        case "POST":<span class="cov2" title="9">
                emptyResults := make(map[string]middleware.Result)
                suiteName := h.DataStore.GetCurrentSuiteName()
                err := h.DataStore.WriteResults(suiteName, emptyResults)
                if err != nil </span><span class="cov1" title="3">{
                        log.Printf("Error writing results: %v", err)
                        http.Error(w, "Error writing results", http.StatusInternalServerError)
                        return
                }</span>
                <span class="cov2" title="6">log.Println("Results reset successfully")
                h.DataStore.BroadcastResults()
                http.Redirect(w, r, "/results", http.StatusSeeOther)</span>
        default:<span class="cov1" title="3">
                http.Error(w, "Method not allowed", http.StatusMethodNotAllowed)</span>
        }
}

// ConfirmRefreshResults handles confirm refresh results
func (h *Handler) ConfirmRefreshResults(w http.ResponseWriter, r *http.Request) <span class="cov3" title="18">{
        log.Println("Handling confirm refresh results")
        switch r.Method </span>{
        case "GET":<span class="cov2" title="9">
                if err := h.Renderer.RenderTemplateSimple(w, "confirm_refresh_results.html", nil); err != nil </span><span class="cov1" title="3">{
                        log.Printf("Error rendering template: %v", err)
                        http.Error(w, "Error rendering template", http.StatusInternalServerError)
                }</span>
        case "POST":<span class="cov2" title="6">
                results := h.DataStore.ReadResults()
                for model := range results </span><span class="cov2" title="6">{
                        results[model] = middleware.Result{
                                Scores: make([]int, len(h.DataStore.ReadPrompts())),
                        }
                }</span>
                <span class="cov2" title="6">suiteName := h.DataStore.GetCurrentSuiteName()
                err := h.DataStore.WriteResults(suiteName, results)
                if err != nil </span><span class="cov1" title="3">{
                        log.Printf("Error writing results: %v", err)
                        http.Error(w, "Error writing results", http.StatusInternalServerError)
                        return
                }</span>
                <span class="cov1" title="3">log.Println("Results refreshed successfully")
                h.DataStore.BroadcastResults()
                http.Redirect(w, r, "/results", http.StatusSeeOther)</span>
        default:<span class="cov1" title="3">
                http.Error(w, "Method not allowed", http.StatusMethodNotAllowed)</span>
        }
}

// RefreshResults handles refresh results
func (h *Handler) RefreshResults(w http.ResponseWriter, r *http.Request) <span class="cov3" title="21">{
        log.Println("Handling refresh results")
        switch r.Method </span>{
        case "GET":<span class="cov2" title="6">
                if err := h.Renderer.RenderTemplateSimple(w, "confirm_refresh_results.html", nil); err != nil </span><span class="cov1" title="3">{
                        log.Printf("Error rendering template: %v", err)
                        http.Error(w, "Error rendering template", http.StatusInternalServerError)
                }</span>
        case "POST":<span class="cov2" title="12">
                results := h.DataStore.ReadResults()
                for model := range results </span><span class="cov2" title="9">{
                        results[model] = middleware.Result{Scores: make([]int, len(h.DataStore.ReadPrompts()))}
                }</span>
                <span class="cov2" title="12">suiteName := h.DataStore.GetCurrentSuiteName()
                err := h.DataStore.WriteResults(suiteName, results)
                if err != nil </span><span class="cov1" title="3">{
                        log.Printf("Error writing results: %v", err)
                        http.Error(w, "Error writing results", http.StatusInternalServerError)
                        return
                }</span>
                <span class="cov2" title="9">log.Println("Results refreshed successfully")
                h.DataStore.BroadcastResults()
                http.Redirect(w, r, "/results", http.StatusSeeOther)</span>
        default:<span class="cov1" title="3">
                http.Error(w, "Method not allowed", http.StatusMethodNotAllowed)</span>
        }
}

// EvaluateResultHandler handles evaluation of individual results
func (h *Handler) EvaluateResultHandler(w http.ResponseWriter, r *http.Request) <span class="cov4" title="48">{
        model := r.URL.Query().Get("model")
        promptIndexStr := r.URL.Query().Get("prompt")

        // Validate required query parameters
        if model == "" || promptIndexStr == "" </span><span class="cov3" title="15">{
                http.Redirect(w, r, "/results", http.StatusSeeOther)
                return
        }</span>
        <span class="cov3" title="33">if r.Method == "POST" </span><span class="cov3" title="24">{
                scoreStr := r.FormValue("score")
                score, err := strconv.Atoi(scoreStr)
                if err != nil </span><span class="cov1" title="3">{
                        http.Error(w, "Invalid score value", http.StatusBadRequest)
                        return
                }</span>

                <span class="cov3" title="21">results := h.DataStore.ReadResults()
                if results == nil </span><span class="cov1" title="3">{
                        results = make(map[string]middleware.Result)
                }</span>

                <span class="cov3" title="21">result, exists := results[model]
                if !exists </span><span class="cov2" title="6">{
                        // Initialize new result with scores array matching prompts length
                        prompts := h.DataStore.ReadPrompts()
                        result = middleware.Result{
                                Scores: make([]int, len(prompts)),
                        }
                }</span>

                <span class="cov3" title="21">index, err := strconv.Atoi(promptIndexStr)
                if err != nil || index &lt; 0 || index &gt;= len(result.Scores) </span><span class="cov1" title="3">{
                        http.Error(w, "Invalid prompt index", http.StatusBadRequest)
                        return
                }</span>

                // Update the score (ensure it's within 0-100 range)
                <span class="cov3" title="18">if score &lt; 0 </span><span class="cov1" title="3">{
                        score = 0
                }</span> else<span class="cov3" title="15"> if score &gt; 100 </span><span class="cov1" title="3">{
                        score = 100
                }</span>
                <span class="cov3" title="18">result.Scores[index] = score
                results[model] = result

                // Write updated results
                err = h.DataStore.WriteResults(h.DataStore.GetCurrentSuiteName(), results)
                if err != nil </span><span class="cov1" title="3">{
                        http.Error(w, "Failed to save results", http.StatusInternalServerError)
                        return
                }</span>

                // Broadcast updated results to all clients
                <span class="cov3" title="15">h.DataStore.BroadcastResults()

                // Add debug logging
                log.Printf("Updated score for model %s, prompt %d: %d", model, index, score)
                log.Printf("Current results for model %s: %v", model, result.Scores)

                // Redirect back to results page
                http.Redirect(w, r, "/results", http.StatusSeeOther)
                return</span>
        }

        // Get current score for this model/prompt
        <span class="cov2" title="9">results := h.DataStore.ReadResults()
        currentScore := 0
        if result, exists := results[model]; exists </span><span class="cov2" title="9">{
                if index, err := strconv.Atoi(promptIndexStr); err == nil &amp;&amp; index &lt; len(result.Scores) </span><span class="cov2" title="9">{
                        currentScore = result.Scores[index]
                }</span>
        }

        // Get the prompt text and solution for display
        <span class="cov2" title="9">prompts := h.DataStore.ReadPrompts()
        var promptText, solution string
        promptIndex, err := strconv.Atoi(promptIndexStr)
        if err == nil &amp;&amp; promptIndex &gt;= 0 &amp;&amp; promptIndex &lt; len(prompts) </span><span class="cov2" title="9">{
                promptText = prompts[promptIndex].Text
                solution = prompts[promptIndex].Solution
        }</span>

        // Get model response if available
        <span class="cov2" title="9">var modelResponse string
        db := middleware.GetDB()
        var modelID int
        var promptID int

        // Get model_id from model name
        err = db.QueryRow("SELECT id FROM models WHERE name = ?", model).Scan(&amp;modelID)
        if err == nil </span><span class="cov2" title="6">{
                // Get prompt_id from database using prompt index (1-indexed)
                err = db.QueryRow("SELECT id FROM prompts WHERE suite_id = 1 ORDER BY display_order LIMIT 1 OFFSET ?", promptIndex).Scan(&amp;promptID)
                if err == nil </span><span class="cov2" title="6">{
                        // Get the response for this model/prompt pair
                        err = db.QueryRow("SELECT response_text FROM model_responses WHERE model_id = ? AND prompt_id = ?", modelID, promptID).Scan(&amp;modelResponse)
                        if err != nil </span><span class="cov2" title="6">{
                                // No response found, leave empty
                                modelResponse = ""
                        }</span>
                }
        }

        <span class="cov2" title="9">data := struct {
                PageName      string
                Model         string
                PromptIndex   string
                ScoreOptions  map[string]int
                CurrentScore  int
                PromptText    string
                Solution      string
                TotalPrompts  int
                ModelResponse string
                ModelID       int
                PromptID      int
                CurrentPath   string
        }{
                PageName:      templates.PageNameEvaluate,
                Model:         model,
                PromptIndex:   promptIndexStr,
                ScoreOptions:  templates.ScoreOptions,
                CurrentScore:  currentScore,
                PromptText:    promptText,
                Solution:      solution,
                TotalPrompts:  len(prompts),
                ModelResponse: modelResponse,
                ModelID:       modelID,
                PromptID:      promptID,
                CurrentPath:   "/evaluate",
        }

        err = h.Renderer.Render(w, "evaluate.html", templates.FuncMap, data, "templates/evaluate.html", "templates/nav.html")
        if err != nil </span><span class="cov2" title="6">{
                log.Printf("Error rendering template: %v", err)
                http.Error(w, "Error rendering template", http.StatusInternalServerError)
                return
        }</span>
}

// ExportResults handles export results
func (h *Handler) ExportResults(w http.ResponseWriter, r *http.Request) <span class="cov3" title="15">{
        log.Println("Handling export results")
        results := h.DataStore.ReadResults()

        // Convert results to JSON
        jsonData, _ := json.MarshalIndent(results, "", "  ")

        // Set headers for JSON download
        w.Header().Set("Content-Type", "application/json")
        w.Header().Set("Content-Disposition", "attachment;filename=results.json")

        // Write JSON to response
        _, err := w.Write(jsonData)
        if err != nil </span><span class="cov1" title="3">{
                log.Printf("Error writing response: %v", err)
                http.Error(w, "Error writing response", http.StatusInternalServerError)
                return
        }</span>
        <span class="cov2" title="12">log.Println("Results exported successfully as JSON")</span>
}

// UpdateMockResults handles updating results with randomly generated mock data
// that ensures even distribution across all tier levels
func (h *Handler) UpdateMockResults(w http.ResponseWriter, r *http.Request) <span class="cov4" title="69">{
        log.Println("Handling update mock results")

        if r.Method != "POST" </span><span class="cov1" title="3">{
                http.Error(w, "Method not allowed", http.StatusMethodNotAllowed)
                return
        }</span>

        // Parse the JSON request body
        <span class="cov4" title="66">var mockData struct {
                Results         map[string]middleware.Result `json:"results"`
                Models          []string                     `json:"models"`
                PassPercentages map[string]float64           `json:"passPercentages"`
                TotalScores     map[string]int               `json:"totalScores"`
        }

        log.Println("Received mock data request")

        body, err := io.ReadAll(r.Body)
        if err != nil </span><span class="cov1" title="3">{
                log.Printf("Error reading request body: %v", err)
                http.Error(w, "Error reading request body", http.StatusBadRequest)
                return
        }</span>

        <span class="cov4" title="63">err = json.Unmarshal(body, &amp;mockData)
        if err != nil </span><span class="cov1" title="3">{
                log.Printf("Error decoding mock data: %v", err)
                http.Error(w, "Invalid JSON data", http.StatusBadRequest)
                return
        }</span>

        // Use client-provided scores instead of generating new ones
        <span class="cov4" title="60">log.Println("Using client-provided scores for mock data")

        prompts := h.DataStore.ReadPrompts()

        // If no prompts exist, create mock prompts with profiles
        if len(prompts) == 0 </span><span class="cov3" title="27">{
                db := middleware.GetDB()
                suiteID, err := middleware.GetCurrentSuiteID()
                if err != nil || suiteID == 0 </span><span class="cov1" title="3">{
                        suiteID = 1
                }</span>

                // First create the 5 profiles
                <span class="cov3" title="27">profileNames := []string{"Math", "Philosophy", "Programming", "Science", "Writing"}
                profileDescriptions := map[string]string{
                        "Math":        "Mathematics and logic problems",
                        "Philosophy":  "Philosophical and ethical questions",
                        "Programming": "Programming and software development",
                        "Science":     "Scientific and natural world questions",
                        "Writing":     "Creative and technical writing",
                }
                profileIDs := make(map[string]int64)
                for _, name := range profileNames </span><span class="cov4" title="135">{
                        result, err := db.Exec("INSERT INTO profiles (name, description, suite_id) VALUES (?, ?, ?)",
                                name, profileDescriptions[name], suiteID)
                        if err != nil </span><span class="cov3" title="30">{
                                log.Printf("Error inserting mock profile: %v", err)
                                continue</span>
                        }
                        <span class="cov4" title="105">profileID, err := result.LastInsertId()
                        if err != nil </span><span class="cov0" title="0">{
                                log.Printf("Error getting profile ID: %v", err)
                                continue</span>
                        }
                        <span class="cov4" title="105">profileIDs[name] = profileID</span>
                }
                <span class="cov3" title="27">log.Printf("Created %d mock profiles", len(profileNames))

                // Define 10 prompts with solutions for each profile
                type PromptWithSolution struct {
                        Text     string
                        Solution string
                }
                profilePrompts := map[string][]PromptWithSolution{
                        "Math": {
                                {"What is 2 + 2?", "The answer is **4**."},
                                {"Solve for x: 2x = 10", "Divide both sides by 2: x = **5**"},
                                {"What is the derivative of x^2?", "Using the power rule: **2x**"},
                                {"Calculate the area of a circle with radius 5", "Area = πr² = π × 5² = **25π** or approximately **78.54** square units"},
                                {"What is the square root of 144?", "**12**"},
                                {"If f(x) = 3x + 1, what is f(5)?", "f(5) = 3(5) + 1 = **16**"},
                                {"What is the Pythagorean theorem?", "a² + b² = c², where c is the hypotenuse of a right triangle"},
                                {"Simplify: (x + 2)(x - 3)", "x² - 3x + 2x - 6 = **x² - x - 6**"},
                                {"What is 15% of 200?", "0.15 × 200 = **30**"},
                                {"What is the sum of angles in a triangle?", "**180 degrees**"},
                        },
                        "Philosophy": {
                                {"What is the meaning of life?", "A profound philosophical question with many perspectives including: finding purpose, creating meaning, seeking happiness, or serving others."},
                                {"Explain Plato's allegory of the cave", "Plato's allegory describes prisoners chained in a cave seeing only shadows. One escapes to see reality (the sun), representing enlightenment and the philosopher's journey from ignorance to knowledge."},
                                {"Is free will compatible with determinism?", "A central debate in philosophy. Compatibilists argue free will and determinism can coexist, while incompatibilists believe they cannot."},
                                {"What is ethics?", "The branch of philosophy studying morality, including principles of right and wrong conduct, moral values, and how we should live."},
                                {"Describe utilitarianism", "An ethical theory stating the best action maximizes overall happiness or utility - 'the greatest good for the greatest number.'"},
                                {"What is consciousness?", "The subjective experience of awareness, qualia, and self-reflective thought - one of philosophy's 'hard problems.'"},
                                {"Does objective morality exist?", "Moral realists argue yes; moral relativists disagree. This debate examines whether moral truths are independent of human opinion."},
                                {"Explain the trolley problem", "A thought experiment: do you pull a lever to kill one person and save five? Explores utilitarianism vs. deontological ethics."},
                                {"What is epistemology?", "The philosophical study of knowledge - its nature, origin, limits, and justification."},
                                {"Can we truly know anything?", "Skeptical questioning that challenges certainty. Responses range from radical skepticism to pragmatic acceptance of justified true belief."},
                        },
                        "Programming": {
                                {"Write a function to reverse a string", "```python\ndef reverse_string(s):\n    return s[::-1]\n```"},
                                {"What is the time complexity of binary search?", "**O(log n)** - the search space is halved each iteration."},
                                {"Explain recursion", "A function that calls itself to solve smaller instances of the same problem. Requires base case(s) and recursive case(s)."},
                                {"What is a closure in JavaScript?", "A function bundled with its lexical environment. Closures remember variables from their outer scope even after the outer function returns."},
                                {"Write a function to check if a number is prime", "```python\ndef is_prime(n):\n    if n &lt; 2:\n        return False\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            return False\n    return True\n```"},
                                {"What is the difference between == and ===?", "In JavaScript, `==` checks equality with type coercion, while `===` checks strict equality without type coercion."},
                                {"Explain the concept of Big O notation", "A mathematical notation describing algorithm efficiency as input size grows, focusing on worst-case time and space complexity."},
                                {"What is a race condition?", "A bug where output depends on the timing of uncontrollable events, often occurring in concurrent programming when multiple threads access shared data."},
                                {"Write a function to merge two sorted arrays", "```python\ndef merge_sorted_arrays(arr1, arr2):\n    result = []\n    i = j = 0\n    while i &lt; len(arr1) and j &lt; len(arr2):\n        if arr1[i] &lt;= arr2[j]:\n            result.append(arr1[i])\n            i += 1\n        else:\n            result.append(arr2[j])\n            j += 1\n    result.extend(arr1[i:])\n    result.extend(arr2[j:])\n    return result\n```"},
                                {"What is dependency injection?", "A design pattern where dependencies are provided to a class rather than created within it, improving testability and loose coupling."},
                        },
                        "Science": {
                                {"What is photosynthesis?", "The process by which plants convert light energy (sunlight), CO₂, and water into glucose and oxygen. Equation: 6CO₂ + 6H₂O + light → C₆H₁₂O₆ + 6O₂"},
                                {"Explain the theory of evolution", "The scientific theory that species change over time through natural selection, where organisms with advantageous traits are more likely to survive and reproduce."},
                                {"What is the speed of light?", "**299,792,458 meters per second** in a vacuum, denoted as **c**."},
                                {"Describe the structure of an atom", "An atom consists of a nucleus containing protons and neutrons, surrounded by electrons in electron shells/orbitals."},
                                {"What is Newton's first law of motion?", "An object at rest stays at rest, and an object in motion stays in motion at constant velocity, unless acted upon by an external force (law of inertia)."},
                                {"Explain the water cycle", "The continuous cycle of water evaporation, condensation (forming clouds), precipitation (rain/snow), and collection (oceans, lakes, groundwater)."},
                                {"What is DNA?", "Deoxyribonucleic acid - the molecule carrying genetic instructions. A double helix of nucleotides (A, T, C, G) that encodes genetic information."},
                                {"Describe the process of mitosis", "Cell division producing two genetically identical daughter cells. Phases: prophase, metaphase, anaphase, telophase, followed by cytokinesis."},
                                {"What is the greenhouse effect?", "Gases in Earth's atmosphere trap heat from the sun, warming the planet. Key greenhouse gases include CO₂, methane, and water vapor."},
                                {"Explain the concept of entropy", "A measure of disorder or randomness in a system. The second law of thermodynamics states entropy in an isolated system always increases."},
                        },
                        "Writing": {
                                {"Write a haiku about nature", "Morning dew glistens,\nLeaves dance in gentle breeze,\nLife awakes anew."},
                                {"Describe your perfect day", "Waking to golden sunlight, a warm cup of coffee, meaningful conversations with loved ones, time for creativity, and ending with gratitude under starlight."},
                                {"Write a short story about adventure", "The ancient map crinkled in her hands. X marked the hidden temple. She stepped into the jungle, heart racing, ready for whatever lay beyond the veil of leaves."},
                                {"What makes a good character?", "Depth, flaws, clear motivation, growth arc, authentic voice, and relatable struggles that resonate with readers."},
                                {"Write a persuasive paragraph about climate change", "Climate change is an urgent crisis demanding immediate action. Rising temperatures, extreme weather, and ecosystem collapse threaten our future. We must transition to renewable energy, reduce emissions, and protect our planet for generations to come."},
                                {"Describe the taste of chocolate", "Rich, velvety sweetness melting across the tongue - hints of vanilla, earthy cocoa, and a lingering embrace of comfort."},
                                {"Write a metaphor for time", "Time is a river - always flowing, never stopping, carving memories into the canyon of our lives."},
                                {"What is the difference between fiction and non-fiction?", "Fiction presents invented stories, characters, and events. Non-fiction presents factual information about real people, places, and events."},
                                {"Write a dialogue between two strangers", "\\\"Excuse me, is this seat taken?\\\" \\\"No, please.\\\" \\\"Thanks. Long day?\\\" \\\"The longest. You?\\\" \\\"Same. At least we're in this together.\\\" A small smile, shared understanding."},
                                {"Describe the feeling of nostalgia", "A bittersweet ache - warm memories gilded by time's golden filter, yet tinged with longing for moments that can never return."},
                        },
                }

                // Create all prompts with their associated profile_id
                displayOrder := 0
                for _, profileName := range profileNames </span><span class="cov4" title="135">{
                        profileID, exists := profileIDs[profileName]
                        if !exists </span><span class="cov3" title="30">{
                                log.Printf("Profile ID not found for %s", profileName)
                                continue</span>
                        }

                        <span class="cov4" title="105">promptsForProfile := profilePrompts[profileName]
                        for _, prompt := range promptsForProfile </span><span class="cov6" title="1050">{
                                _, err = db.Exec("INSERT INTO prompts (text, solution, suite_id, display_order, type, profile_id) VALUES (?, ?, ?, ?, 'objective', ?)",
                                        prompt.Text, prompt.Solution, suiteID, displayOrder, profileID)
                                if err != nil </span><span class="cov4" title="150">{
                                        log.Printf("Error inserting mock prompt for profile %s: %v", profileName, err)
                                }</span>
                                <span class="cov6" title="1050">displayOrder++</span>
                        }
                }

                <span class="cov3" title="27">prompts = h.DataStore.ReadPrompts()
                log.Printf("Created %d mock prompts with profiles", len(prompts))

                // Create a second suite with 4 profiles and 5 prompts each
                secondSuiteName := "Alternative Suite"
                result, err := db.Exec("INSERT INTO suites (name, is_current) VALUES (?, 0)", secondSuiteName)
                if err != nil </span><span class="cov1" title="3">{
                        log.Printf("Error creating second suite: %v", err)
                }</span> else<span class="cov3" title="24"> {
                        secondSuiteID, err := result.LastInsertId()
                        if err != nil </span><span class="cov0" title="0">{
                                log.Printf("Error getting second suite ID: %v", err)
                        }</span> else<span class="cov3" title="24"> {
                                log.Printf("Created second suite: %s (ID: %d)", secondSuiteName, secondSuiteID)

                                // Create 4 profiles for the second suite
                                secondSuiteProfileNames := []string{"History", "Geography", "Literature", "Art"}
                                secondSuiteProfileDescriptions := map[string]string{
                                        "History":    "Historical events and figures",
                                        "Geography":  "Geographical and environmental topics",
                                        "Literature": "Literary analysis and creative writing",
                                        "Art":        "Visual arts, music, and aesthetics",
                                }
                                secondSuiteProfileIDs := make(map[string]int64)
                                for _, name := range secondSuiteProfileNames </span><span class="cov4" title="96">{
                                        result, err := db.Exec("INSERT INTO profiles (name, description, suite_id) VALUES (?, ?, ?)",
                                                name, secondSuiteProfileDescriptions[name], secondSuiteID)
                                        if err != nil </span><span class="cov2" title="12">{
                                                log.Printf("Error inserting second suite profile: %v", err)
                                                continue</span>
                                        }
                                        <span class="cov4" title="84">profileID, err := result.LastInsertId()
                                        if err != nil </span><span class="cov0" title="0">{
                                                log.Printf("Error getting second suite profile ID: %v", err)
                                                continue</span>
                                        }
                                        <span class="cov4" title="84">secondSuiteProfileIDs[name] = profileID</span>
                                }
                                <span class="cov3" title="24">log.Printf("Created %d mock profiles for second suite", len(secondSuiteProfileNames))

                                // Define 5 prompts with solutions for each profile in the second suite
                                secondSuitePrompts := map[string][]PromptWithSolution{
                                        "History": {
                                                {"When did World War II end?", "World War II ended in **1945**, with Germany surrendering in May and Japan in September."},
                                                {"Who was the first President of the United States?", "**George Washington** served as the first U.S. President from 1789 to 1797."},
                                                {"What was the Renaissance?", "A cultural movement (14th-17th century) marking the transition from medieval to modern times, characterized by renewed interest in classical art, literature, and learning."},
                                                {"Explain the causes of the French Revolution", "Key causes included: social inequality (three estates), financial crisis from wars, Enlightenment ideas, food shortages, and resentment toward the monarchy."},
                                                {"What was the Silk Road?", "A network of trade routes connecting East Asia to the Mediterranean, facilitating exchange of goods, ideas, and cultures from around 130 BCE to 1453 CE."},
                                        },
                                        "Geography": {
                                                {"What is the capital of Australia?", "**Canberra** is the capital of Australia, not Sydney or Melbourne as commonly assumed."},
                                                {"What is the longest river in the world?", "The **Nile River** in Africa is generally considered the longest at approximately 6,650 km (4,130 miles)."},
                                                {"Explain the water cycle", "The continuous movement of water: evaporation from surfaces, condensation into clouds, precipitation as rain/snow, and collection in bodies of water."},
                                                {"What are the seven continents?", "Africa, Antarctica, Asia, Australia/Oceania, Europe, North America, and South America."},
                                                {"What is a tectonic plate?", "A large, rigid slab of Earth's lithosphere that moves and interacts with other plates, causing earthquakes, volcanic activity, and mountain formation."},
                                        },
                                        "Literature": {
                                                {"Who wrote 'Romeo and Juliet'?", "**William Shakespeare** wrote this tragic play around 1595-1597."},
                                                {"What is a haiku?", "A Japanese poetic form with three lines and a 5-7-5 syllable structure, traditionally focusing on nature and seasonal imagery."},
                                                {"Explain the concept of foreshadowing", "A literary device where hints or clues suggest future events, building anticipation and creating dramatic tension."},
                                                {"Who wrote '1984'?", "**George Orwell** published this dystopian novel in 1949, exploring themes of totalitarianism and surveillance."},
                                                {"What is magical realism?", "A literary genre where magical elements blend realistically into ordinary settings, common in Latin American literature (e.g., Gabriel García Márquez)."},
                                        },
                                        "Art": {
                                                {"Who painted the Mona Lisa?", "**Leonardo da Vinci** painted this masterpiece between 1503 and 1519."},
                                                {"What is Impressionism?", "A 19th-century art movement characterized by visible brush strokes, emphasis on light, and ordinary subject matter (e.g., Monet, Renoir)."},
                                                {"Explain the golden ratio in art", "A mathematical proportion (approximately 1.618) believed to create aesthetically pleasing compositions, used by artists like da Vinci and architects throughout history."},
                                                {"Who sculpted David?", "**Michelangelo** carved this marble statue of the biblical hero between 1501 and 1504."},
                                                {"What is abstract art?", "Art that doesn't represent visual reality accurately, using colors, forms, and gestures to achieve its effect (e.g., Kandinsky, Pollock)."},
                                        },
                                }

                                // Create all prompts for the second suite with their associated profile_id
                                displayOrder := 0
                                for _, profileName := range secondSuiteProfileNames </span><span class="cov4" title="96">{
                                        profileID, exists := secondSuiteProfileIDs[profileName]
                                        if !exists </span><span class="cov2" title="12">{
                                                log.Printf("Profile ID not found for %s in second suite", profileName)
                                                continue</span>
                                        }

                                        <span class="cov4" title="84">promptsForProfile := secondSuitePrompts[profileName]
                                        for _, prompt := range promptsForProfile </span><span class="cov5" title="420">{
                                                _, err = db.Exec("INSERT INTO prompts (text, solution, suite_id, display_order, type, profile_id) VALUES (?, ?, ?, ?, 'objective', ?)",
                                                        prompt.Text, prompt.Solution, secondSuiteID, displayOrder, profileID)
                                                if err != nil </span><span class="cov4" title="60">{
                                                        log.Printf("Error inserting second suite prompt for profile %s: %v", profileName, err)
                                                }</span>
                                                <span class="cov5" title="420">displayOrder++</span>
                                        }
                                }
                                <span class="cov3" title="24">log.Printf("Created %d mock prompts for second suite", displayOrder)

                                // Create mock models for the second suite (same tiers as first suite)
                                secondSuiteTiers := []string{
                                        "Cosmic", "Transcendent", "Ethereal", "Celestial", "Infinite",
                                        "Quantum", "Nebular", "Stellar", "Galactic", "Universal", "Dimensional",
                                }
                                var secondSuiteModels []string
                                for i := 0; i &lt; 12; i++ </span><span class="cov5" title="288">{
                                        tier := secondSuiteTiers[i%len(secondSuiteTiers)]
                                        num := i/len(secondSuiteTiers) + 1
                                        modelName := tier + "-" + strconv.Itoa(num)
                                        _, err = db.Exec("INSERT INTO models (name, suite_id) VALUES (?, ?)",
                                                modelName, secondSuiteID)
                                        if err != nil </span><span class="cov3" title="36">{
                                                log.Printf("Error inserting second suite model: %v", err)
                                                continue</span>
                                        }
                                        <span class="cov5" title="252">secondSuiteModels = append(secondSuiteModels, modelName)</span>
                                }
                                <span class="cov3" title="24">log.Printf("Created %d mock models for second suite", len(secondSuiteModels))

                                // Create mock scores for the second suite models
                                // Get all prompts for the second suite
                                promptRows, err := db.Query("SELECT id FROM prompts WHERE suite_id = ? ORDER BY display_order", secondSuiteID)
                                if err != nil </span><span class="cov1" title="3">{
                                        log.Printf("Error querying second suite prompts: %v", err)
                                }</span> else<span class="cov3" title="21"> {
                                        defer func() </span><span class="cov3" title="21">{
                                                if err := promptRows.Close(); err != nil </span><span class="cov0" title="0">{
                                                        log.Printf("Error closing prompt rows: %v", err)
                                                }</span>
                                        }()
                                        <span class="cov3" title="21">var promptIDs []int
                                        for promptRows.Next() </span><span class="cov5" title="360">{
                                                var promptID int
                                                if err := promptRows.Scan(&amp;promptID); err != nil </span><span class="cov0" title="0">{
                                                        log.Printf("Error scanning prompt ID: %v", err)
                                                        continue</span>
                                                }
                                                <span class="cov5" title="360">promptIDs = append(promptIDs, promptID)</span>
                                        }

                                        // Get model IDs and create scores
                                        <span class="cov3" title="21">for _, modelName := range secondSuiteModels </span><span class="cov5" title="216">{
                                                var modelID int
                                                err = db.QueryRow("SELECT id FROM models WHERE name = ? AND suite_id = ?", modelName, secondSuiteID).Scan(&amp;modelID)
                                                if err != nil </span><span class="cov0" title="0">{
                                                        log.Printf("Error getting model ID for %s: %v", modelName, err)
                                                        continue</span>
                                                }

                                                // Create scores with tier-based distribution (similar to first suite)
                                                <span class="cov5" title="216">tierIndex := (len(secondSuiteModels) - 1) / len(secondSuiteTiers)
                                                for _, promptID := range promptIDs </span><span class="cov7" title="3600">{
                                                        score := getRandomScoreForTierWrapper(tierIndex)
                                                        _, err = db.Exec("INSERT INTO scores (model_id, prompt_id, score) VALUES (?, ?, ?)",
                                                                modelID, promptID, score)
                                                        if err != nil </span><span class="cov0" title="0">{
                                                                log.Printf("Error inserting score for model %s prompt %d: %v", modelName, promptID, err)
                                                        }</span>
                                                }
                                        }
                                        <span class="cov3" title="21">log.Printf("Created mock scores for second suite models")</span>
                                }
                        }
                }
        }

        // Get all model names
        <span class="cov4" title="60">models := mockData.Models
        if len(models) == 0 </span><span class="cov3" title="39">{
                // If no models passed, use models from existing results
                for model := range mockData.Results </span><span class="cov1" title="3">{
                        models = append(models, model)
                }</span>
        }

        // Use the client's results directly
        <span class="cov4" title="60">results := mockData.Results

        // Generate mock models if both models and results are empty
        if len(models) == 0 &amp;&amp; len(results) == 0 </span><span class="cov3" title="36">{
                results = make(map[string]middleware.Result)
                tiers := []string{
                        "Cosmic", "Transcendent", "Ethereal", "Celestial", "Infinite",
                        "Quantum", "Nebular", "Stellar", "Galactic", "Universal", "Dimensional",
                }
                for i := 0; i &lt; 24; i++ </span><span class="cov6" title="864">{
                        tier := tiers[i%len(tiers)]
                        num := i/len(tiers) + 1
                        modelName := tier + "-" + strconv.Itoa(num)
                        models = append(models, modelName)
                        results[modelName] = middleware.Result{Scores: make([]int, len(prompts))}
                }</span>
        }

        // Validate that all scores are legitimate values: 0, 20, 40, 60, 80, 100
        <span class="cov4" title="60">for model, result := range results </span><span class="cov6" title="891">{
                for i, score := range result.Scores </span><span class="cov8" title="18333">{
                        // Only allow valid score values
                        switch score </span>{
                        case 0, 20, 40, 60, 80, 100:<span class="cov8" title="18321"></span>
                                // Valid score, keep it
                        default:<span class="cov2" title="12">
                                // Invalid score, set to 0
                                log.Printf("Correcting invalid score %d for model %s prompt %d", score, model, i)
                                result.Scores[i] = 0</span>
                        }
                }
                <span class="cov6" title="891">results[model] = result</span>
        }

        // Skip the evenly distributed tier generation since we're using client scores

        // Save the evenly distributed mock results
        <span class="cov4" title="60">suiteName := h.DataStore.GetCurrentSuiteName()
        err = h.DataStore.WriteResults(suiteName, results)
        if err != nil </span><span class="cov2" title="12">{
                log.Printf("Error writing mock results: %v", err)
                http.Error(w, "Error saving mock results", http.StatusInternalServerError)
                return
        }</span>

        // Generate mock responses for each model and prompt combination
        // Get database for inserting mock responses
        <span class="cov4" title="48">db := middleware.GetDB()
        suiteID, err := middleware.GetCurrentSuiteID()
        if err != nil </span><span class="cov2" title="6">{
                suiteID = 1 // fallback to default suite
        }</span>

        // Get all prompts for response generation
        <span class="cov4" title="48">for _, modelName := range models </span><span class="cov6" title="672">{
                // Get model ID
                var modelID int
                err = db.QueryRow("SELECT id FROM models WHERE name = ? AND suite_id = ?", modelName, suiteID).Scan(&amp;modelID)
                if err != nil </span><span class="cov2" title="9">{
                        continue</span> // model might not exist yet
                }

                // Generate mock response for each prompt
                <span class="cov6" title="663">for promptIdx := range prompts </span><span class="cov8" title="14700">{
                        var promptID int
                        err = db.QueryRow("SELECT id FROM prompts WHERE suite_id = ? ORDER BY display_order LIMIT 1 OFFSET ?",
                                suiteID, promptIdx).Scan(&amp;promptID)
                        if err != nil </span><span class="cov0" title="0">{
                                continue</span>
                        }

                        // Generate Lorem ipsum mock response
                        <span class="cov8" title="14700">loremPhrases := []string{
                                "Lorem ipsum dolor sit amet, consectetur adipiscing elit.",
                                "Sed do eiusmod tempor incididunt ut labore et dolore magna aliqua.",
                                "Ut enim ad minim veniam, quis nostrud exercitation ullamco.",
                                "Duis aute irure dolor in reprehenderit in voluptate velit esse.",
                                "Excepteur sint occaecat cupidatat non proident sunt in culpa.",
                        }

                        // Build 3-5 random sentences
                        numSentences := 3 + rand.Intn(3)
                        var responseParts []string
                        for i := 0; i &lt; numSentences; i++ </span><span class="cov9" title="58581">{
                                responseParts = append(responseParts, loremPhrases[rand.Intn(len(loremPhrases))])
                        }</span>
                        <span class="cov8" title="14700">mockResponse := strings.Join(responseParts, " ")

                        // Insert or update mock response
                        _, err = db.Exec(
                                "INSERT INTO model_responses (model_id, prompt_id, response_text, response_source) "+
                                        "VALUES (?, ?, ?, 'mock') "+
                                        "ON CONFLICT(model_id, prompt_id) DO UPDATE SET "+
                                        "response_text = excluded.response_text, response_source = 'mock', updated_at = CURRENT_TIMESTAMP",
                                modelID, promptID, mockResponse)
                        if err != nil </span><span class="cov0" title="0">{
                                log.Printf("Error inserting mock response for model %s prompt %d: %v", modelName, promptIdx, err)
                        }</span>
                }
        }

        // Broadcast the updated results to all connected clients
        <span class="cov4" title="48">h.DataStore.BroadcastResults()

        // Calculate totalScores and passPercentages for the response
        totalScores := make(map[string]int)
        passPercentages := make(map[string]float64)

        log.Println("Calculating total scores for each model:")
        for model, result := range results </span><span class="cov6" title="672">{
                totalScore := 0
                for _, score := range result.Scores </span><span class="cov8" title="14730">{
                        totalScore += score
                }</span>
                <span class="cov6" title="672">totalScores[model] = totalScore
                // Avoid division by zero when there are no prompts
                if len(prompts) &gt; 0 </span><span class="cov6" title="597">{
                        passPercentages[model] = float64(totalScore) / float64(len(prompts)*100) * 100
                }</span> else<span class="cov4" title="75"> {
                        passPercentages[model] = 0
                }</span>

                <span class="cov6" title="672">log.Printf("Model %s: total score = %d, pass percentage = %.2f%%",
                        model, totalScore, passPercentages[model])</span>
        }

        // Sort models by total score in descending order
        <span class="cov4" title="48">sort.Slice(models, func(i, j int) bool </span><span class="cov6" title="705">{
                return totalScores[models[i]] &gt; totalScores[models[j]]
        }</span>)

        <span class="cov4" title="48">log.Printf("Sorted models after mock generation: %v", models[:min(5, len(models))])

        // Return success response with the generated data
        w.Header().Set("Content-Type", "application/json")
        response := map[string]interface{}{
                "status":          "success",
                "results":         results,
                "models":          models, // Now sorted by score
                "totalScores":     totalScores,
                "passPercentages": passPercentages,
        }

        err = json.NewEncoder(w).Encode(response)
        if err != nil </span><span class="cov1" title="3">{
                log.Printf("Error encoding response: %v", err)
        }</span>

        <span class="cov4" title="48">log.Println("Mock results with even tier distribution updated successfully")</span>
}

// getRandomScoreForTierWrapper wraps the score generation for the second suite
func getRandomScoreForTierWrapper(tierIndex int) int <span class="cov7" title="3600">{
        // Use the same logic as getRandomScoreForTier but accessible outside UpdateMockResults
        tierWeights := []map[int]int{
                {0: 1, 20: 1, 40: 8, 60: 15, 80: 25, 100: 50},   // cosmic (highest tier)
                {0: 1, 20: 2, 40: 10, 60: 20, 80: 40, 100: 27},  // divine
                {0: 2, 20: 5, 40: 15, 60: 30, 80: 35, 100: 13},  // celestial
                {0: 5, 20: 10, 40: 25, 60: 30, 80: 20, 100: 10}, // ascendant
                {0: 7, 20: 15, 40: 33, 60: 25, 80: 15, 100: 5},  // ethereal
                {0: 10, 20: 20, 40: 35, 60: 20, 80: 10, 100: 5}, // mystic
                {0: 15, 20: 30, 40: 30, 60: 15, 80: 8, 100: 2},  // astral
                {0: 20, 20: 35, 40: 25, 60: 15, 80: 4, 100: 1},  // spiritual
                {0: 30, 20: 35, 40: 20, 60: 12, 80: 2, 100: 1},  // primal
                {0: 40, 20: 35, 40: 15, 60: 8, 80: 2, 100: 0},   // mortal
                {0: 55, 20: 30, 40: 10, 60: 5, 80: 0, 100: 0},   // primordial (lowest tier)
        }

        if tierIndex &gt;= len(tierWeights) </span><span class="cov0" title="0">{
                tierIndex = len(tierWeights) - 1
        }</span>

        <span class="cov7" title="3600">weightsMap := tierWeights[tierIndex]
        weightValues := []int{0, 20, 40, 60, 80, 100}
        weights := []int{
                weightsMap[0],
                weightsMap[20],
                weightsMap[40],
                weightsMap[60],
                weightsMap[80],
                weightsMap[100],
        }

        // Simple weighted random selection
        totalWeight := 0
        for _, w := range weights </span><span class="cov8" title="21600">{
                totalWeight += w
        }</span>

        <span class="cov7" title="3600">random := rand.Intn(totalWeight)
        runningTotal := 0
        for i, w := range weights </span><span class="cov8" title="17186">{
                runningTotal += w
                if random &lt; runningTotal </span><span class="cov7" title="3600">{
                        return weightValues[i]
                }</span>
        }

        <span class="cov0" title="0">return 0</span> // fallback
}

// RandomizeScoresHandler handles randomizing scores (backward compatible wrapper)
func RandomizeScoresHandler(w http.ResponseWriter, r *http.Request) <span class="cov2" title="9">{
        DefaultHandler.RandomizeScores(w, r)
}</span>

// RandomizeScores randomizes existing scores in the database without creating new models or prompts
func (h *Handler) RandomizeScores(w http.ResponseWriter, r *http.Request) <span class="cov3" title="24">{
        log.Println("Handling randomize scores")

        if r.Method != "POST" </span><span class="cov2" title="6">{
                http.Error(w, "Method not allowed", http.StatusMethodNotAllowed)
                return
        }</span>

        <span class="cov3" title="18">db := middleware.GetDB()
        suiteID, err := middleware.GetCurrentSuiteID()
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("Error getting suite ID: %v", err)
                http.Error(w, "Error getting suite ID", http.StatusInternalServerError)
                return
        }</span>

        <span class="cov3" title="18">modelRows, err := db.Query("SELECT id, name FROM models WHERE suite_id = ?", suiteID)
        if err != nil </span><span class="cov1" title="3">{
                log.Printf("Error querying models: %v", err)
                http.Error(w, "Error querying models", http.StatusInternalServerError)
                return
        }</span>
        <span class="cov3" title="15">defer func() </span><span class="cov3" title="15">{ _ = modelRows.Close() }</span>()

        <span class="cov3" title="15">var models []struct {
                ID   int
                Name string
        }

        for modelRows.Next() </span><span class="cov4" title="153">{
                var m struct {
                        ID   int
                        Name string
                }
                if err := modelRows.Scan(&amp;m.ID, &amp;m.Name); err != nil </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov4" title="153">models = append(models, m)</span>
        }

        <span class="cov3" title="15">promptRows, err := db.Query("SELECT id FROM prompts WHERE suite_id = ? ORDER BY display_order", suiteID)
        if err != nil </span><span class="cov1" title="3">{
                http.Error(w, "Error querying prompts", http.StatusInternalServerError)
                return
        }</span>
        <span class="cov2" title="12">defer func() </span><span class="cov2" title="12">{ _ = promptRows.Close() }</span>()

        <span class="cov2" title="12">var promptIDs []int
        for promptRows.Next() </span><span class="cov5" title="468">{
                var id int
                if err := promptRows.Scan(&amp;id); err != nil </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov5" title="468">promptIDs = append(promptIDs, id)</span>
        }

        <span class="cov2" title="12">rng := initRand()
        numPrompts := len(promptIDs)
        maxScore := numPrompts * 100
        numTiers := 12

        for i, model := range models </span><span class="cov4" title="150">{
                tierIndex := (i * numTiers) / len(models)
                if tierIndex &gt;= numTiers </span><span class="cov0" title="0">{
                        tierIndex = numTiers - 1
                }</span>

                <span class="cov4" title="150">tierMinPercent := float64(tierIndex) / float64(numTiers)
                tierMaxPercent := float64(tierIndex+1) / float64(numTiers)
                tierMidPercent := (tierMinPercent + tierMaxPercent) / 2
                targetTotal := int(float64(maxScore) * tierMidPercent)

                remaining := targetTotal
                for j, promptID := range promptIDs </span><span class="cov8" title="7368">{
                        var score int
                        if j == len(promptIDs)-1 </span><span class="cov4" title="150">{
                                score = clampToValidScore(remaining)
                        }</span> else<span class="cov8" title="7218"> {
                                promptsRemaining := len(promptIDs) - j - 1
                                minScore := max(0, remaining-promptsRemaining*100)
                                maxScoreVal := min(100, remaining)

                                midScore := (minScore + maxScoreVal) / 2
                                randomOffset := rng.Intn(21) - 10
                                score = clampToValidScore(midScore + randomOffset)

                                if score &gt; maxScoreVal </span><span class="cov5" title="475">{
                                        score = clampToValidScore(maxScoreVal)
                                }</span>
                                <span class="cov8" title="7218">if score &lt; minScore </span><span class="cov6" title="667">{
                                        score = clampToValidScore(minScore)
                                }</span>
                        }

                        <span class="cov8" title="7368">_, _ = db.Exec(
                                "INSERT INTO scores (model_id, prompt_id, score) VALUES (?, ?, ?) "+
                                        "ON CONFLICT(model_id, prompt_id) DO UPDATE SET score = excluded.score",
                                model.ID, promptID, score)
                        remaining -= score</span>
                }
        }

        <span class="cov2" title="12">h.DataStore.BroadcastResults()

        w.Header().Set("Content-Type", "application/json")
        w.WriteHeader(http.StatusOK)
        _ = json.NewEncoder(w).Encode(map[string]string{"status": "success"})</span>
}

func clampToValidScore(score int) int <span class="cov8" title="14795">{
        minDiff := 1000
        result := 0
        for _, vs := range []int{0, 20, 40, 60, 80, 100} </span><span class="cov10" title="88770">{
                diff := score - vs
                if diff &lt; 0 </span><span class="cov9" title="43470">{
                        diff = -diff
                }</span>
                <span class="cov10" title="88770">if diff &lt; minDiff </span><span class="cov9" title="51977">{
                        minDiff = diff
                        result = vs
                }</span>
        }
        <span class="cov8" title="14795">return result</span>
}
</pre>
		
		<pre class="file" id="file6" style="display: none">package handlers

import (
        "llm-tournament/middleware"
        "log"
        "net/http"
        "strconv"
)

// SettingsHandler displays the settings page (backward compatible wrapper)
func SettingsHandler(w http.ResponseWriter, r *http.Request) <span class="cov6" title="12">{
        DefaultHandler.Settings(w, r)
}</span>

// UpdateSettingsHandler updates settings from form submission (backward compatible wrapper)
func UpdateSettingsHandler(w http.ResponseWriter, r *http.Request) <span class="cov7" title="21">{
        DefaultHandler.UpdateSettings(w, r)
}</span>

// TestAPIKeyHandler tests an API key (backward compatible wrapper)
func TestAPIKeyHandler(w http.ResponseWriter, r *http.Request) <span class="cov6" title="12">{
        DefaultHandler.TestAPIKey(w, r)
}</span>

// Settings displays the settings page
func (h *Handler) Settings(w http.ResponseWriter, r *http.Request) <span class="cov6" title="15">{
        log.Println("Handling settings page")

        // Get masked API keys for display
        maskedKeys, err := h.DataStore.GetMaskedAPIKeys()
        if err != nil </span><span class="cov3" title="3">{
                log.Printf("Error getting masked API keys: %v", err)
                http.Error(w, "Failed to load settings", http.StatusInternalServerError)
                return
        }</span>

        // Get other settings
        <span class="cov6" title="12">threshold, _ := h.DataStore.GetSetting("cost_alert_threshold_usd")
        autoEval, _ := h.DataStore.GetSetting("auto_evaluate_new_models")
        pythonURL, _ := h.DataStore.GetSetting("python_service_url")

        // Parse threshold as float
        thresholdFloat, _ := strconv.ParseFloat(threshold, 64)
        if thresholdFloat == 0 </span><span class="cov3" title="3">{
                thresholdFloat = 100.0
        }</span>

        <span class="cov6" title="12">data := struct {
                PageName      string
                MaskedAPIKeys map[string]string
                Threshold     float64
                AutoEvaluate  bool
                PythonURL     string
                CurrentPath   string
        }{
                PageName:      "Settings",
                MaskedAPIKeys: maskedKeys,
                Threshold:     thresholdFloat,
                AutoEvaluate:  autoEval == "true",
                PythonURL:     pythonURL,
                CurrentPath:   "/settings",
        }

        middleware.RenderTemplate(w, "settings.html", data)</span>
}

// UpdateSettings updates settings from form submission
func (h *Handler) UpdateSettings(w http.ResponseWriter, r *http.Request) <span class="cov8" title="30">{
        if r.Method != http.MethodPost </span><span class="cov3" title="3">{
                http.Error(w, "Method not allowed", http.StatusMethodNotAllowed)
                return
        }</span>

        <span class="cov8" title="27">log.Println("Updating settings")

        // Parse form
        if err := r.ParseForm(); err != nil </span><span class="cov3" title="3">{
                log.Printf("Error parsing form: %v", err)
                http.Error(w, "Failed to parse form", http.StatusBadRequest)
                return
        }</span>

        // Update API keys (only if not empty)
        <span class="cov7" title="24">apiKeys := map[string]string{
                "anthropic": r.FormValue("api_key_anthropic"),
                "openai":    r.FormValue("api_key_openai"),
                "google":    r.FormValue("api_key_google"),
        }

        for provider, key := range apiKeys </span><span class="cov10" title="66">{
                if key != "" &amp;&amp; key != "********" </span><span class="cov6" title="12">{ // Don't update if placeholder
                        if err := h.DataStore.SetAPIKey(provider, key); err != nil </span><span class="cov3" title="3">{
                                log.Printf("Error setting API key for %s: %v", provider, err)
                                http.Error(w, "Failed to save API key", http.StatusInternalServerError)
                                return
                        }</span>
                }
        }

        // Update other settings
        <span class="cov7" title="21">threshold := r.FormValue("cost_alert_threshold_usd")
        if threshold != "" </span><span class="cov6" title="12">{
                if err := h.DataStore.SetSetting("cost_alert_threshold_usd", threshold); err != nil </span><span class="cov3" title="3">{
                        log.Printf("Error setting threshold: %v", err)
                }</span>
        }

        <span class="cov7" title="21">autoEval := r.FormValue("auto_evaluate_new_models")
        autoEvalValue := "false"
        if autoEval == "on" </span><span class="cov4" title="6">{
                autoEvalValue = "true"
        }</span>
        <span class="cov7" title="21">if err := h.DataStore.SetSetting("auto_evaluate_new_models", autoEvalValue); err != nil </span><span class="cov3" title="3">{
                log.Printf("Error setting auto_evaluate: %v", err)
        }</span>

        <span class="cov7" title="21">pythonURL := r.FormValue("python_service_url")
        if pythonURL != "" </span><span class="cov4" title="6">{
                if err := h.DataStore.SetSetting("python_service_url", pythonURL); err != nil </span><span class="cov3" title="3">{
                        log.Printf("Error setting Python URL: %v", err)
                }</span>
        }

        <span class="cov7" title="21">log.Println("Settings updated successfully")

        // Redirect back to settings page
        http.Redirect(w, r, "/settings", http.StatusSeeOther)</span>
}

// TestAPIKey tests an API key by making a health check to Python service
func (h *Handler) TestAPIKey(w http.ResponseWriter, r *http.Request) <span class="cov6" title="12">{
        if r.Method != http.MethodPost </span><span class="cov3" title="3">{
                http.Error(w, "Method not allowed", http.StatusMethodNotAllowed)
                return
        }</span>

        <span class="cov5" title="9">provider := r.FormValue("provider")
        if provider == "" </span><span class="cov3" title="3">{
                http.Error(w, "Provider required", http.StatusBadRequest)
                return
        }</span>

        // Get API key
        <span class="cov4" title="6">apiKey, err := h.DataStore.GetAPIKey(provider)
        if err != nil || apiKey == "" </span><span class="cov3" title="3">{
                middleware.RespondJSON(w, map[string]interface{}{
                        "success": false,
                        "message": "API key not configured",
                })
                return
        }</span>

        // TODO: Make actual test call to respective API
        // For now, just return success
        <span class="cov3" title="3">middleware.RespondJSON(w, map[string]interface{}{
                "success": true,
                "message": "API key appears valid (test not fully implemented)",
        })</span>
}
</pre>
		
		<pre class="file" id="file7" style="display: none">package handlers

import (
        "encoding/json"
        "fmt"
        "html/template"
        "llm-tournament/middleware"
        "log"
        "net/http"
        "strings"

        "golang.org/x/text/cases"
        "golang.org/x/text/language"
)

// Calculate tiers based on total scores
func calculateTiers(totalScores map[string]int) (map[string][]string, map[string]string) <span class="cov9" title="162">{
        tiers := map[string][]string{
                "transcendental": {},
                "cosmic":         {},
                "divine":         {},
                "celestial":      {},
                "ascendant":      {},
                "ethereal":       {},
                "mystic":         {},
                "astral":         {},
                "spiritual":      {},
                "primal":         {},
                "mortal":         {},
                "primordial":     {},
        }

        tierRanges := map[string]string{
                "transcendental": "3780+",
                "cosmic":         "3360-3779",
                "divine":         "2700-3359",
                "celestial":      "2400-2699",
                "ascendant":      "2100-2399",
                "ethereal":       "1800-2099",
                "mystic":         "1500-1799",
                "astral":         "1200-1499",
                "spiritual":      "900-1199",
                "primal":         "600-899",
                "mortal":         "300-599",
                "primordial":     "0-299",
        }

        for model, score := range totalScores </span><span class="cov10" title="207">{
                switch </span>{
                case score &gt;= 3780:<span class="cov6" title="24">
                        tiers["transcendental"] = append(tiers["transcendental"], model)</span>
                case score &gt;= 3360:<span class="cov5" title="18">
                        tiers["cosmic"] = append(tiers["cosmic"], model)</span>
                case score &gt;= 2700:<span class="cov5" title="18">
                        tiers["divine"] = append(tiers["divine"], model)</span>
                case score &gt;= 2400:<span class="cov5" title="15">
                        tiers["celestial"] = append(tiers["celestial"], model)</span>
                case score &gt;= 2100:<span class="cov5" title="15">
                        tiers["ascendant"] = append(tiers["ascendant"], model)</span>
                case score &gt;= 1800:<span class="cov5" title="15">
                        tiers["ethereal"] = append(tiers["ethereal"], model)</span>
                case score &gt;= 1500:<span class="cov5" title="15">
                        tiers["mystic"] = append(tiers["mystic"], model)</span>
                case score &gt;= 1200:<span class="cov5" title="18">
                        tiers["astral"] = append(tiers["astral"], model)</span>
                case score &gt;= 900:<span class="cov5" title="15">
                        tiers["spiritual"] = append(tiers["spiritual"], model)</span>
                case score &gt;= 600:<span class="cov5" title="15">
                        tiers["primal"] = append(tiers["primal"], model)</span>
                case score &gt;= 300:<span class="cov5" title="15">
                        tiers["mortal"] = append(tiers["mortal"], model)</span>
                default:<span class="cov6" title="24">
                        tiers["primordial"] = append(tiers["primordial"], model)</span>
                }
        }

        <span class="cov9" title="162">return tiers, tierRanges</span>
}

// StatsHandler handles the stats page (backward compatible wrapper)
func StatsHandler(w http.ResponseWriter, r *http.Request) <span class="cov5" title="15">{
        DefaultHandler.Stats(w, r)
}</span>

// Stats handles the stats page
func (h *Handler) Stats(w http.ResponseWriter, r *http.Request) <span class="cov5" title="18">{
        log.Println("Handling stats page")
        results := h.DataStore.ReadResults()

        // Calculate score breakdowns
        type ScoreStats struct {
                TotalScore int `json:"TotalScore"`
                Count20    int `json:"Count20"`
                Count40    int `json:"Count40"`
                Count60    int `json:"Count60"`
                Count80    int `json:"Count80"`
                Count100   int `json:"Count100"`
        }

        scoreStats := make(map[string]ScoreStats)
        for model, result := range results </span><span class="cov5" title="18">{
                stats := ScoreStats{}
                for _, score := range result.Scores </span><span class="cov7" title="36">{
                        stats.TotalScore += score
                        switch score </span>{
                        case 20:<span class="cov4" title="6">
                                stats.Count20++</span>
                        case 40:<span class="cov2" title="3">
                                stats.Count40++</span>
                        case 60:<span class="cov4" title="6">
                                stats.Count60++</span>
                        case 80:<span class="cov4" title="9">
                                stats.Count80++</span>
                        case 100:<span class="cov4" title="9">
                                stats.Count100++</span>
                        }
                }

                // Double-check total score calculation to ensure consistency
                <span class="cov5" title="18">calculatedTotal := stats.Count20*20 + stats.Count40*40 + stats.Count60*60 + stats.Count80*80 + stats.Count100*100
                if calculatedTotal != stats.TotalScore </span><span class="cov2" title="3">{
                        log.Printf("Warning: Score mismatch for %s: calculated=%d, summed=%d", model, calculatedTotal, stats.TotalScore)
                        // Fix the total score if there's a discrepancy
                        stats.TotalScore = calculatedTotal
                }</span>
                <span class="cov5" title="18">scoreStats[model] = stats</span>
        }

        // Create total scores map for tier calculations
        <span class="cov5" title="18">totalScores := make(map[string]int)
        for model, stats := range scoreStats </span><span class="cov5" title="18">{
                totalScores[model] = stats.TotalScore
        }</span>

        // Get prompt count to calculate dynamic max score
        <span class="cov5" title="18">db := middleware.GetDB()
        var promptCount int
        err := db.QueryRow("SELECT COUNT(*) FROM prompts").Scan(&amp;promptCount)
        if err != nil </span><span class="cov2" title="3">{
                log.Printf("Warning: failed to get prompt count: %v, using default 50", err)
                promptCount = 50
        }</span>
        <span class="cov5" title="18">maxScore := promptCount * 100

        // Calculate tiers with dynamic max score
        tiers, tierRanges := calculateTiersWithMaxScore(totalScores, maxScore)

        // Prepare template data
        templateData := struct {
                PageName     string
                MaxScore     int
                TotalScores  map[string]ScoreStats
                Tiers        map[string][]string
                TierRanges   map[string]string
                OrderedTiers []string
                CurrentPath  string
        }{
                PageName:    "Statistics",
                MaxScore:    maxScore,
                TotalScores: scoreStats,
                Tiers:       tiers,
                TierRanges:  tierRanges,
                OrderedTiers: []string{
                        "transcendental",
                        "cosmic",
                        "divine",
                        "celestial",
                        "ascendant",
                        "ethereal",
                        "mystic",
                        "astral",
                        "spiritual",
                        "primal",
                        "mortal",
                        "primordial",
                },
                CurrentPath: "/stats",
        }

        funcMap := template.FuncMap{
                "json": func(v interface{}) template.JS </span><span class="cov5" title="12">{
                        a, _ := json.Marshal(v)
                        return template.JS(a)
                }</span>,
                "eqs": func(a, b string) bool <span class="cov8" title="72">{
                        return a == b
                }</span>,
                "tierClass": func(tier string) string <span class="cov5" title="15">{
                        return tier
                }</span>,
                "formatTierName": func(tier string) string <span class="cov5" title="15">{
                        return cases.Title(language.English).String(strings.ReplaceAll(tier, "-", " "))
                }</span>,
                "join": strings.Join,
        }

        <span class="cov5" title="18">err = h.Renderer.Render(w, "stats.html", funcMap, templateData, "templates/stats.html", "templates/nav.html")
        if err != nil </span><span class="cov2" title="3">{
                log.Printf("Error rendering template: %v", err)
                http.Error(w, "Error rendering template", http.StatusInternalServerError)
                return
        }</span>
}

// calculateTiersWithMaxScore calculates tiers based on total scores with dynamic max score
func calculateTiersWithMaxScore(totalScores map[string]int, maxScore int) (map[string][]string, map[string]string) <span class="cov7" title="45">{
        tiers := map[string][]string{
                "transcendental": {},
                "cosmic":         {},
                "divine":         {},
                "celestial":      {},
                "ascendant":      {},
                "ethereal":       {},
                "mystic":         {},
                "astral":         {},
                "spiritual":      {},
                "primal":         {},
                "mortal":         {},
                "primordial":     {},
        }

        // Calculate even distribution across 12 tiers
        thresholds := map[string]int{
                "transcendental": (maxScore * 11) / 12,
                "cosmic":         (maxScore * 10) / 12,
                "divine":         (maxScore * 9) / 12,
                "celestial":      (maxScore * 8) / 12,
                "ascendant":      (maxScore * 7) / 12,
                "ethereal":       (maxScore * 6) / 12,
                "mystic":         (maxScore * 5) / 12,
                "astral":         (maxScore * 4) / 12,
                "spiritual":      (maxScore * 3) / 12,
                "primal":         (maxScore * 2) / 12,
                "mortal":         (maxScore * 1) / 12,
        }

        // Calculate percentages for display
        percentages := map[string]float64{
                "transcendental": float64(thresholds["transcendental"]) * 100 / float64(maxScore),
                "cosmic":         float64(thresholds["cosmic"]) * 100 / float64(maxScore),
                "divine":         float64(thresholds["divine"]) * 100 / float64(maxScore),
                "celestial":      float64(thresholds["celestial"]) * 100 / float64(maxScore),
                "ascendant":      float64(thresholds["ascendant"]) * 100 / float64(maxScore),
                "ethereal":       float64(thresholds["ethereal"]) * 100 / float64(maxScore),
                "mystic":         float64(thresholds["mystic"]) * 100 / float64(maxScore),
                "astral":         float64(thresholds["astral"]) * 100 / float64(maxScore),
                "spiritual":      float64(thresholds["spiritual"]) * 100 / float64(maxScore),
                "primal":         float64(thresholds["primal"]) * 100 / float64(maxScore),
                "mortal":         float64(thresholds["mortal"]) * 100 / float64(maxScore),
                "primordial":     0.0,
        }

        tierRanges := map[string]string{
                "transcendental": fmt.Sprintf("%d+ (%.1f%%+)", thresholds["transcendental"], percentages["transcendental"]),
                "cosmic":         fmt.Sprintf("%d-%d (%.1f%%-%.1f%%)", thresholds["cosmic"], thresholds["transcendental"]-1, percentages["cosmic"], percentages["transcendental"]),
                "divine":         fmt.Sprintf("%d-%d (%.1f%%-%.1f%%)", thresholds["divine"], thresholds["cosmic"]-1, percentages["divine"], percentages["cosmic"]),
                "celestial":      fmt.Sprintf("%d-%d (%.1f%%-%.1f%%)", thresholds["celestial"], thresholds["divine"]-1, percentages["celestial"], percentages["divine"]),
                "ascendant":      fmt.Sprintf("%d-%d (%.1f%%-%.1f%%)", thresholds["ascendant"], thresholds["celestial"]-1, percentages["ascendant"], percentages["celestial"]),
                "ethereal":       fmt.Sprintf("%d-%d (%.1f%%-%.1f%%)", thresholds["ethereal"], thresholds["ascendant"]-1, percentages["ethereal"], percentages["ascendant"]),
                "mystic":         fmt.Sprintf("%d-%d (%.1f%%-%.1f%%)", thresholds["mystic"], thresholds["ethereal"]-1, percentages["mystic"], percentages["ethereal"]),
                "astral":         fmt.Sprintf("%d-%d (%.1f%%-%.1f%%)", thresholds["astral"], thresholds["mystic"]-1, percentages["astral"], percentages["mystic"]),
                "spiritual":      fmt.Sprintf("%d-%d (%.1f%%-%.1f%%)", thresholds["spiritual"], thresholds["astral"]-1, percentages["spiritual"], percentages["astral"]),
                "primal":         fmt.Sprintf("%d-%d (%.1f%%-%.1f%%)", thresholds["primal"], thresholds["spiritual"]-1, percentages["primal"], percentages["spiritual"]),
                "mortal":         fmt.Sprintf("%d-%d (%.1f%%-%.1f%%)", thresholds["mortal"], thresholds["primal"]-1, percentages["mortal"], percentages["primal"]),
                "primordial":     fmt.Sprintf("0-%d (0-%.1f%%)", thresholds["mortal"]-1, percentages["mortal"]),
        }

        for model, score := range totalScores </span><span class="cov8" title="75">{
                switch </span>{
                case score &gt;= thresholds["transcendental"]:<span class="cov5" title="15">
                        tiers["transcendental"] = append(tiers["transcendental"], model)</span>
                case score &gt;= thresholds["cosmic"]:<span class="cov4" title="6">
                        tiers["cosmic"] = append(tiers["cosmic"], model)</span>
                case score &gt;= thresholds["divine"]:<span class="cov4" title="6">
                        tiers["divine"] = append(tiers["divine"], model)</span>
                case score &gt;= thresholds["celestial"]:<span class="cov2" title="3">
                        tiers["celestial"] = append(tiers["celestial"], model)</span>
                case score &gt;= thresholds["ascendant"]:<span class="cov4" title="9">
                        tiers["ascendant"] = append(tiers["ascendant"], model)</span>
                case score &gt;= thresholds["ethereal"]:<span class="cov2" title="3">
                        tiers["ethereal"] = append(tiers["ethereal"], model)</span>
                case score &gt;= thresholds["mystic"]:<span class="cov2" title="3">
                        tiers["mystic"] = append(tiers["mystic"], model)</span>
                case score &gt;= thresholds["astral"]:<span class="cov2" title="3">
                        tiers["astral"] = append(tiers["astral"], model)</span>
                case score &gt;= thresholds["spiritual"]:<span class="cov2" title="3">
                        tiers["spiritual"] = append(tiers["spiritual"], model)</span>
                case score &gt;= thresholds["primal"]:<span class="cov2" title="3">
                        tiers["primal"] = append(tiers["primal"], model)</span>
                case score &gt;= thresholds["mortal"]:<span class="cov2" title="3">
                        tiers["mortal"] = append(tiers["mortal"], model)</span>
                default:<span class="cov5" title="18">
                        tiers["primordial"] = append(tiers["primordial"], model)</span>
                }
        }

        <span class="cov7" title="45">return tiers, tierRanges</span>
}
</pre>
		
		<pre class="file" id="file8" style="display: none">package handlers

import (
        "fmt"
        "llm-tournament/middleware"
        "log"
        "net/http"
)

// DeletePromptSuiteHandler handles delete prompt suite (backward compatible wrapper)
func DeletePromptSuiteHandler(w http.ResponseWriter, r *http.Request) <span class="cov8" title="18">{
        DefaultHandler.DeletePromptSuite(w, r)
}</span>

// SelectPromptSuiteHandler handles select prompt suite (backward compatible wrapper)
func SelectPromptSuiteHandler(w http.ResponseWriter, r *http.Request) <span class="cov7" title="12">{
        DefaultHandler.SelectPromptSuite(w, r)
}</span>

// NewPromptSuiteHandler handles new prompt suite (backward compatible wrapper)
func NewPromptSuiteHandler(w http.ResponseWriter, r *http.Request) <span class="cov9" title="30">{
        DefaultHandler.NewPromptSuite(w, r)
}</span>

// EditPromptSuiteHandler handles edit prompt suite (backward compatible wrapper)
func EditPromptSuiteHandler(w http.ResponseWriter, r *http.Request) <span class="cov8" title="24">{
        DefaultHandler.EditPromptSuite(w, r)
}</span>

// DeletePromptSuite handles delete prompt suite page
func (h *Handler) DeletePromptSuite(w http.ResponseWriter, r *http.Request) <span class="cov8" title="24">{
        log.Println("Handling delete prompt suite page")
        switch r.Method </span>{
        case "GET":<span class="cov5" title="6">
                suiteName := r.URL.Query().Get("suite_name")
                returnTo := r.URL.Query().Get("return_to")
                if returnTo == "" </span><span class="cov5" title="6">{
                        returnTo = r.URL.Path
                }</span>
                <span class="cov5" title="6">if err := h.Renderer.Render(w, "delete_prompt_suite.html", nil, map[string]string{"SuiteName": suiteName, "CurrentPath": returnTo}, "templates/delete_prompt_suite.html"); err != nil </span><span class="cov3" title="3">{
                        log.Printf("Error rendering template: %v", err)
                        http.Error(w, "Error rendering template", http.StatusInternalServerError)
                        return
                }</span>
                <span class="cov3" title="3">log.Println("Delete prompt suite page rendered successfully")</span>
        case "POST":<span class="cov7" title="15">
                suiteName := r.FormValue("suite_name")
                if suiteName == "" </span><span class="cov3" title="3">{
                        http.Error(w, "Suite name is required", http.StatusBadRequest)
                        return
                }</span>

                <span class="cov7" title="12">currentSuite := h.DataStore.GetCurrentSuiteName()
                if suiteName == currentSuite </span><span class="cov5" title="6">{
                        if err := h.DataStore.SetCurrentSuite("default"); err != nil </span><span class="cov3" title="3">{
                                log.Printf("Error updating current suite: %v", err)
                                http.Error(w, "Error updating current suite", http.StatusInternalServerError)
                                return
                        }</span>
                }

                <span class="cov6" title="9">err := middleware.DeletePromptSuite(suiteName)
                if err != nil </span><span class="cov3" title="3">{
                        log.Printf("Error deleting prompt suite: %v", err)
                        http.Error(w, "Error deleting prompt suite", http.StatusInternalServerError)
                        return
                }</span>

                <span class="cov5" title="6">log.Printf("Prompt suite '%s' deleted successfully", suiteName)
                h.DataStore.BroadcastResults()
                returnTo := r.Form.Get("return_to")
                if returnTo == "" </span><span class="cov5" title="6">{
                        returnTo = "/prompts"
                }</span>
                <span class="cov5" title="6">http.Redirect(w, r, returnTo, http.StatusSeeOther)</span>
        default:<span class="cov3" title="3">
                http.Error(w, "Method not allowed", http.StatusMethodNotAllowed)</span>
        }
}

// SelectPromptSuite handles select prompt suite
func (h *Handler) SelectPromptSuite(w http.ResponseWriter, r *http.Request) <span class="cov7" title="15">{
        log.Println("Handling select prompt suite")
        if r.Method != http.MethodPost </span><span class="cov3" title="3">{
                http.Error(w, "Method not allowed", http.StatusMethodNotAllowed)
                return
        }</span>
        <span class="cov7" title="12">err := r.ParseForm()
        if err != nil </span><span class="cov3" title="3">{
                log.Printf("Error parsing form: %v", err)
                http.Error(w, "Error parsing form", http.StatusBadRequest)
                return
        }</span>
        <span class="cov6" title="9">suiteName := r.Form.Get("suite_name")
        if suiteName == "" </span><span class="cov3" title="3">{
                log.Println("Suite name cannot be empty")
                http.Error(w, "Suite name cannot be empty", http.StatusBadRequest)
                return
        }</span>

        <span class="cov5" title="6">if err = h.DataStore.SetCurrentSuite(suiteName); err != nil </span><span class="cov3" title="3">{
                log.Printf("Error setting current suite: %v", err)
                http.Error(w, "Error setting current suite", http.StatusInternalServerError)
                return
        }</span>

        <span class="cov3" title="3">log.Printf("Prompt suite '%s' selected successfully", suiteName)
        h.DataStore.BroadcastResults()
        returnTo := r.Form.Get("return_to")
        if returnTo == "" </span><span class="cov3" title="3">{
                returnTo = "/prompts"
        }</span>
        <span class="cov3" title="3">http.Redirect(w, r, returnTo, http.StatusSeeOther)</span>
}

// NewPromptSuite handles new prompt suite
func (h *Handler) NewPromptSuite(w http.ResponseWriter, r *http.Request) <span class="cov10" title="36">{
        log.Println("Handling new prompt suite")
        switch r.Method </span>{
        case "GET":<span class="cov5" title="6">
                returnTo := r.URL.Query().Get("return_to")
                if returnTo == "" </span><span class="cov5" title="6">{
                        returnTo = r.URL.Path
                }</span>
                <span class="cov5" title="6">if err := h.Renderer.Render(w, "new_prompt_suite.html", nil, map[string]string{"CurrentPath": returnTo}, "templates/new_prompt_suite.html"); err != nil </span><span class="cov3" title="3">{
                        log.Printf("Error rendering template: %v", err)
                        http.Error(w, "Error rendering template", http.StatusInternalServerError)
                        return
                }</span>
                <span class="cov3" title="3">log.Println("New prompt suite page rendered successfully")</span>
        case "POST":<span class="cov9" title="27">
                err := r.ParseForm()
                if err != nil </span><span class="cov3" title="3">{
                        log.Printf("Error parsing form: %v", err)
                        http.Error(w, "Error parsing form", http.StatusBadRequest)
                        return
                }</span>
                <span class="cov8" title="24">suiteName := r.Form.Get("suite_name")
                if suiteName == "" </span><span class="cov3" title="3">{
                        log.Println("Suite name cannot be empty")
                        http.Error(w, "Suite name cannot be empty", http.StatusBadRequest)
                        return
                }</span>
                <span class="cov8" title="21">err = h.DataStore.WritePromptSuite(suiteName, []middleware.Prompt{})
                if err != nil </span><span class="cov3" title="3">{
                        log.Printf("Error creating prompt suite: %v", err)
                        http.Error(w, "Error creating prompt suite", http.StatusInternalServerError)
                        return
                }</span>
                <span class="cov8" title="18">log.Printf("Prompt suite '%s' created successfully", suiteName)
                h.DataStore.BroadcastResults()
                returnTo := r.Form.Get("return_to")
                if returnTo == "" </span><span class="cov8" title="18">{
                        returnTo = "/prompts"
                }</span>
                <span class="cov8" title="18">http.Redirect(w, r, returnTo, http.StatusSeeOther)</span>
        default:<span class="cov3" title="3">
                http.Error(w, "Method not allowed", http.StatusMethodNotAllowed)</span>
        }
}

// EditPromptSuite handles edit prompt suite
func (h *Handler) EditPromptSuite(w http.ResponseWriter, r *http.Request) <span class="cov9" title="27">{
        log.Println("Handling edit prompt suite")
        switch r.Method </span>{
        case "GET":<span class="cov5" title="6">
                suiteName := r.URL.Query().Get("suite_name")
                returnTo := r.URL.Query().Get("return_to")
                if returnTo == "" </span><span class="cov5" title="6">{
                        returnTo = r.URL.Path
                }</span>
                <span class="cov5" title="6">if err := h.Renderer.Render(w, "edit_prompt_suite.html", nil, map[string]string{"SuiteName": suiteName, "CurrentPath": returnTo}, "templates/edit_prompt_suite.html"); err != nil </span><span class="cov3" title="3">{
                        log.Printf("Error rendering template: %v", err)
                        http.Error(w, "Error rendering template", http.StatusInternalServerError)
                        return
                }</span>
                <span class="cov3" title="3">log.Println("Edit prompt suite page rendered successfully")</span>
        case "POST":<span class="cov8" title="18">
                err := r.ParseForm()
                if err != nil </span><span class="cov3" title="3">{
                        log.Printf("Error parsing form: %v", err)
                        http.Error(w, "Error parsing form", http.StatusBadRequest)
                        return
                }</span>
                <span class="cov7" title="15">oldSuiteName := r.Form.Get("suite_name")
                newSuiteName := r.Form.Get("new_suite_name")

                if oldSuiteName == "" || newSuiteName == "" </span><span class="cov6" title="9">{
                        log.Println("Both old and new names required")
                        http.Error(w, "Both original and new suite names are required", http.StatusBadRequest)
                        return
                }</span>

                <span class="cov5" title="6">if err := middleware.RenameSuiteFiles(oldSuiteName, newSuiteName); err != nil </span><span class="cov3" title="3">{
                        log.Printf("Error renaming suite: %v", err)
                        http.Error(w, fmt.Sprintf("Error renaming suite: %v", err), http.StatusBadRequest)
                        return
                }</span>
                <span class="cov3" title="3">log.Printf("Prompt suite '%s' edited successfully to '%s'", oldSuiteName, newSuiteName)
                h.DataStore.BroadcastResults()
                returnTo := r.Form.Get("return_to")
                if returnTo == "" </span><span class="cov3" title="3">{
                        returnTo = "/prompts"
                }</span>
                <span class="cov3" title="3">http.Redirect(w, r, returnTo, http.StatusSeeOther)</span>
        default:<span class="cov3" title="3">
                http.Error(w, "Method not allowed", http.StatusMethodNotAllowed)</span>
        }
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
