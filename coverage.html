
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>llm-tournament: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">llm-tournament/app.go (100.0%)</option>
				
				<option value="file1">llm-tournament/evaluator/consensus.go (100.0%)</option>
				
				<option value="file2">llm-tournament/evaluator/evaluator.go (100.0%)</option>
				
				<option value="file3">llm-tournament/evaluator/job_queue.go (100.0%)</option>
				
				<option value="file4">llm-tournament/evaluator/litellm_client.go (100.0%)</option>
				
				<option value="file5">llm-tournament/handlers/evaluation.go (100.0%)</option>
				
				<option value="file6">llm-tournament/handlers/handler.go (100.0%)</option>
				
				<option value="file7">llm-tournament/handlers/models.go (100.0%)</option>
				
				<option value="file8">llm-tournament/handlers/profiles.go (100.0%)</option>
				
				<option value="file9">llm-tournament/handlers/prompt.go (100.0%)</option>
				
				<option value="file10">llm-tournament/handlers/results.go (100.0%)</option>
				
				<option value="file11">llm-tournament/handlers/settings.go (100.0%)</option>
				
				<option value="file12">llm-tournament/handlers/stats.go (100.0%)</option>
				
				<option value="file13">llm-tournament/handlers/suites.go (100.0%)</option>
				
				<option value="file14">llm-tournament/main.go (100.0%)</option>
				
				<option value="file15">llm-tournament/middleware/database.go (100.0%)</option>
				
				<option value="file16">llm-tournament/middleware/datastore.go (100.0%)</option>
				
				<option value="file17">llm-tournament/middleware/encryption.go (100.0%)</option>
				
				<option value="file18">llm-tournament/middleware/handler_utils.go (100.0%)</option>
				
				<option value="file19">llm-tournament/middleware/import_error.go (100.0%)</option>
				
				<option value="file20">llm-tournament/middleware/renderer.go (100.0%)</option>
				
				<option value="file21">llm-tournament/middleware/settings.go (100.0%)</option>
				
				<option value="file22">llm-tournament/middleware/socket.go (100.0%)</option>
				
				<option value="file23">llm-tournament/middleware/state.go (100.0%)</option>
				
				<option value="file24">llm-tournament/middleware/utils.go (100.0%)</option>
				
				<option value="file25">llm-tournament/run.go (100.0%)</option>
				
				<option value="file26">llm-tournament/templates/shared.go (100.0%)</option>
				
				<option value="file27">llm-tournament/testutil/testutil.go (99.6%)</option>
				
				<option value="file28">llm-tournament/tools/screenshots/cmd/demo-server/main.go (100.0%)</option>
				
				<option value="file29">llm-tournament/tools/screenshots/cmd/demo-server/routes.go (100.0%)</option>
				
				<option value="file30">llm-tournament/tools/screenshots/cmd/demo-server/run.go (100.0%)</option>
				
				<option value="file31">llm-tournament/tools/screenshots/cmd/demo-server/seed.go (100.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package main

import (
        "database/sql"
        "flag"
        "net/http"

        "llm-tournament/handlers"
        "llm-tournament/middleware"
)

// Config holds application configuration
type Config struct {
        DBPath         string
        Port           string
        MigrateResults bool
}

// DefaultConfig returns default configuration values
func DefaultConfig() *Config <span class="cov8" title="1">{
        return &amp;Config{
                DBPath: "data/tournament.db",
                Port:   ":8080",
        }
}</span>

// ParseFlags parses command line flags into Config
// Note: This modifies flag.CommandLine state
func ParseFlags(args []string) (*Config, error) <span class="cov8" title="1">{
        cfg := DefaultConfig()

        fs := flag.NewFlagSet("llm-tournament", flag.ContinueOnError)
        fs.BoolVar(&amp;cfg.MigrateResults, "migrate-results", false, "Migrate existing results to new scoring system")
        fs.StringVar(&amp;cfg.DBPath, "db", cfg.DBPath, "SQLite database path")

        if err := fs.Parse(args); err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">return cfg, nil</span>
}

// InitDB initializes the database connection
func InitDB(dbPath string) error <span class="cov8" title="1">{
        return middleware.InitDB(dbPath)
}</span>

// CloseDB closes the database connection
func CloseDB() <span class="cov8" title="1">{
        middleware.CloseDB()
}</span>

// GetDB returns the database instance
func GetDB() *sql.DB <span class="cov8" title="1">{
        return middleware.GetDB()
}</span>

// InitEvaluator initializes the evaluator with the given database
func InitEvaluator(db *sql.DB) <span class="cov8" title="1">{
        handlers.InitEvaluator(db)
}</span>

// RunMigration performs the results migration
func RunMigration() error <span class="cov8" title="1">{
        results := middleware.ReadResults()
        middleware.MigrateResults(results)
        suiteName := middleware.GetCurrentSuiteName()
        return middleware.WriteResults(suiteName, results)
}</span>

// Routes returns the application routes map
func Routes() map[string]http.HandlerFunc <span class="cov8" title="1">{
        return routes
}</span>

// SetupRoutes registers all routes on the given ServeMux
func SetupRoutes(mux *http.ServeMux) <span class="cov8" title="1">{
        for path, handler := range routes </span><span class="cov8" title="1">{
                mux.HandleFunc(path, handler)
        }</span>
        <span class="cov8" title="1">mux.HandleFunc("/", router)
        mux.HandleFunc("/ws", middleware.HandleWebSocket)
        mux.Handle("/templates/", http.StripPrefix("/templates/", http.FileServer(http.Dir("templates"))))
        mux.Handle("/assets/", http.StripPrefix("/assets/", http.FileServer(http.Dir("assets"))))</span>
}

// NewServeMux creates and configures a new ServeMux with all routes
func NewServeMux() *http.ServeMux <span class="cov8" title="1">{
        mux := http.NewServeMux()
        SetupRoutes(mux)
        return mux
}</span>

// Router handles routing for unknown paths
func Router(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        router(w, r)
}</span>
</pre>
		
		<pre class="file" id="file1" style="display: none">package evaluator

import "math"

// CalculateConsensusScore calculates weighted average score by confidence
func CalculateConsensusScore(results []JudgeResult) int <span class="cov8" title="1">{
        if len(results) == 0 </span><span class="cov8" title="1">{
                return 0
        }</span>

        // Filter out invalid results
        <span class="cov8" title="1">validResults := make([]JudgeResult, 0)
        for _, r := range results </span><span class="cov8" title="1">{
                if r.Confidence &gt; 0 &amp;&amp; r.Score &gt;= 0 &amp;&amp; r.Score &lt;= 100 </span><span class="cov8" title="1">{
                        validResults = append(validResults, r)
                }</span>
        }

        <span class="cov8" title="1">if len(validResults) == 0 </span><span class="cov8" title="1">{
                return 0
        }</span>

        // Calculate weighted average
        // Note: totalWeight is always &gt; 0 since validResults only contains items with Confidence &gt; 0
        <span class="cov8" title="1">weightedSum := 0.0
        totalWeight := 0.0

        for _, result := range validResults </span><span class="cov8" title="1">{
                weightedSum += float64(result.Score) * result.Confidence
                totalWeight += result.Confidence
        }</span>

        <span class="cov8" title="1">return int(math.Round(weightedSum / totalWeight))</span>
}

// RoundToValidScore rounds score to nearest valid value [0, 20, 40, 60, 80, 100]
func RoundToValidScore(score int) int <span class="cov8" title="1">{
        validScores := []int{0, 20, 40, 60, 80, 100}

        // Find nearest valid score
        minDiff := 100
        nearest := 0

        for _, validScore := range validScores </span><span class="cov8" title="1">{
                diff := abs(score - validScore)
                if diff &lt; minDiff </span><span class="cov8" title="1">{
                        minDiff = diff
                        nearest = validScore
                }</span>
        }

        <span class="cov8" title="1">return nearest</span>
}

func abs(x int) int <span class="cov8" title="1">{
        if x &lt; 0 </span><span class="cov8" title="1">{
                return -x
        }</span>
        <span class="cov8" title="1">return x</span>
}
</pre>
		
		<pre class="file" id="file2" style="display: none">package evaluator

import (
        "database/sql"
        "fmt"
        "log"
)

// Evaluator orchestrates LLM evaluations
type Evaluator struct {
        db            *sql.DB
        litellmClient *LiteLLMClient
        jobQueue      *JobQueue
        judges        []string
}

// NewEvaluator creates a new evaluator instance
func NewEvaluator(db *sql.DB, pythonServiceURL string) *Evaluator <span class="cov8" title="1">{
        evaluator := &amp;Evaluator{
                db:            db,
                litellmClient: NewLiteLLMClient(pythonServiceURL),
                judges:        []string{"claude_opus_4.5", "gpt_5.2", "gemini_3_pro"},
        }

        // Initialize job queue with 3 concurrent workers
        evaluator.jobQueue = NewJobQueue(db, 3, evaluator)

        return evaluator
}</span>

// EvaluateAll evaluates all models against all prompts in a suite
func (e *Evaluator) EvaluateAll(suiteID int) (int, error) <span class="cov8" title="1">{
        // Get prompt and model counts
        var promptCount, modelCount int
        err := e.db.QueryRow("SELECT COUNT(*) FROM prompts WHERE suite_id = ?", suiteID).Scan(&amp;promptCount)
        if err != nil </span><span class="cov8" title="1">{
                return 0, fmt.Errorf("failed to count prompts: %w", err)
        }</span>

        <span class="cov8" title="1">err = e.db.QueryRow("SELECT COUNT(*) FROM models WHERE suite_id = ?", suiteID).Scan(&amp;modelCount)
        if err != nil </span><span class="cov8" title="1">{
                return 0, fmt.Errorf("failed to count models: %w", err)
        }</span>

        <span class="cov8" title="1">total := promptCount * modelCount

        // Estimate cost
        estimatedCost := float64(total) * 0.05 // ~$0.05 per evaluation

        // Create job
        job := &amp;EvaluationJob{
                SuiteID:       suiteID,
                JobType:       "all",
                ProgressTotal: total,
                EstimatedCost: estimatedCost,
        }

        if err := e.jobQueue.Enqueue(job); err != nil </span><span class="cov8" title="1">{
                return 0, fmt.Errorf("failed to enqueue job: %w", err)
        }</span>

        <span class="cov8" title="1">return job.ID, nil</span>
}

// EvaluateModel evaluates one model against all prompts
func (e *Evaluator) EvaluateModel(modelID int) (int, error) <span class="cov8" title="1">{
        // Get suite ID and prompt count
        var suiteID, promptCount int
        err := e.db.QueryRow("SELECT suite_id FROM models WHERE id = ?", modelID).Scan(&amp;suiteID)
        if err != nil </span><span class="cov8" title="1">{
                return 0, fmt.Errorf("failed to get model suite: %w", err)
        }</span>

        <span class="cov8" title="1">err = e.db.QueryRow("SELECT COUNT(*) FROM prompts WHERE suite_id = ?", suiteID).Scan(&amp;promptCount)
        if err != nil </span><span class="cov8" title="1">{
                return 0, fmt.Errorf("failed to count prompts: %w", err)
        }</span>

        <span class="cov8" title="1">estimatedCost := float64(promptCount) * 0.05

        job := &amp;EvaluationJob{
                SuiteID:       suiteID,
                JobType:       "model",
                TargetID:      modelID,
                ProgressTotal: promptCount,
                EstimatedCost: estimatedCost,
        }

        if err := e.jobQueue.Enqueue(job); err != nil </span><span class="cov8" title="1">{
                return 0, fmt.Errorf("failed to enqueue job: %w", err)
        }</span>

        <span class="cov8" title="1">return job.ID, nil</span>
}

// EvaluatePrompt evaluates all models for one prompt
func (e *Evaluator) EvaluatePrompt(promptID int) (int, error) <span class="cov8" title="1">{
        // Get suite ID and model count
        var suiteID, modelCount int
        err := e.db.QueryRow("SELECT suite_id FROM prompts WHERE id = ?", promptID).Scan(&amp;suiteID)
        if err != nil </span><span class="cov8" title="1">{
                return 0, fmt.Errorf("failed to get prompt suite: %w", err)
        }</span>

        <span class="cov8" title="1">err = e.db.QueryRow("SELECT COUNT(*) FROM models WHERE suite_id = ?", suiteID).Scan(&amp;modelCount)
        if err != nil </span><span class="cov8" title="1">{
                return 0, fmt.Errorf("failed to count models: %w", err)
        }</span>

        <span class="cov8" title="1">estimatedCost := float64(modelCount) * 0.05

        job := &amp;EvaluationJob{
                SuiteID:       suiteID,
                JobType:       "prompt",
                TargetID:      promptID,
                ProgressTotal: modelCount,
                EstimatedCost: estimatedCost,
        }

        if err := e.jobQueue.Enqueue(job); err != nil </span><span class="cov8" title="1">{
                return 0, fmt.Errorf("failed to enqueue job: %w", err)
        }</span>

        <span class="cov8" title="1">return job.ID, nil</span>
}

// processJob processes an evaluation job (called by worker)
func (e *Evaluator) processJob(job *EvaluationJob, cancelChan chan bool) error <span class="cov8" title="1">{
        log.Printf("Processing job %d (type: %s)", job.ID, job.JobType)

        switch job.JobType </span>{
        case "all":<span class="cov8" title="1">
                return e.processAllJob(job, cancelChan)</span>
        case "model":<span class="cov8" title="1">
                return e.processModelJob(job, cancelChan)</span>
        case "prompt":<span class="cov8" title="1">
                return e.processPromptJob(job, cancelChan)</span>
        default:<span class="cov8" title="1">
                return fmt.Errorf("unknown job type: %s", job.JobType)</span>
        }
}

// processAllJob evaluates all models × all prompts
func (e *Evaluator) processAllJob(job *EvaluationJob, cancelChan chan bool) error <span class="cov8" title="1">{
        // Get all models
        modelRows, err := e.db.Query("SELECT id FROM models WHERE suite_id = ?", job.SuiteID)
        if err != nil </span><span class="cov8" title="1">{
                return fmt.Errorf("failed to query models: %w", err)
        }</span>
        <span class="cov8" title="1">defer modelRows.Close()

        var modelIDs []int
        for modelRows.Next() </span><span class="cov8" title="1">{
                var modelID int
                if err := modelRows.Scan(&amp;modelID); err != nil </span><span class="cov8" title="1">{
                        return err
                }</span>
                <span class="cov8" title="1">modelIDs = append(modelIDs, modelID)</span>
        }

        // Get all prompts
        <span class="cov8" title="1">promptRows, err := e.db.Query("SELECT id FROM prompts WHERE suite_id = ?", job.SuiteID)
        if err != nil </span><span class="cov8" title="1">{
                return fmt.Errorf("failed to query prompts: %w", err)
        }</span>
        <span class="cov8" title="1">defer promptRows.Close()

        var promptIDs []int
        for promptRows.Next() </span><span class="cov8" title="1">{
                var promptID int
                if err := promptRows.Scan(&amp;promptID); err != nil </span><span class="cov8" title="1">{
                        return err
                }</span>
                <span class="cov8" title="1">promptIDs = append(promptIDs, promptID)</span>
        }

        // Process each combination
        <span class="cov8" title="1">current := 0
        totalCost := 0.0

        for _, modelID := range modelIDs </span><span class="cov8" title="1">{
                for _, promptID := range promptIDs </span><span class="cov8" title="1">{
                        // Check for cancellation
                        select </span>{
                        case &lt;-cancelChan:<span class="cov8" title="1">
                                return fmt.Errorf("job cancelled")</span>
                        default:<span class="cov8" title="1"></span>
                        }

                        <span class="cov8" title="1">cost, err := e.evaluateModelPromptPair(job.ID, modelID, promptID)
                        if err != nil </span><span class="cov8" title="1">{
                                log.Printf("Failed to evaluate model %d, prompt %d: %v", modelID, promptID, err)
                                // Continue with next evaluation
                        }</span>

                        <span class="cov8" title="1">totalCost += cost
                        current++

                        // Update progress
                        if err := e.jobQueue.UpdateJobProgress(job.ID, current, job.ProgressTotal, totalCost); err != nil </span><span class="cov8" title="1">{
                                log.Printf("Failed to update progress: %v", err)
                        }</span>
                }
        }

        <span class="cov8" title="1">return nil</span>
}

// processModelJob evaluates one model × all prompts
func (e *Evaluator) processModelJob(job *EvaluationJob, cancelChan chan bool) error <span class="cov8" title="1">{
        // Get all prompts
        promptRows, err := e.db.Query("SELECT id FROM prompts WHERE suite_id = ?", job.SuiteID)
        if err != nil </span><span class="cov8" title="1">{
                return fmt.Errorf("failed to query prompts: %w", err)
        }</span>
        <span class="cov8" title="1">defer promptRows.Close()

        var promptIDs []int
        for promptRows.Next() </span><span class="cov8" title="1">{
                var promptID int
                if err := promptRows.Scan(&amp;promptID); err != nil </span><span class="cov8" title="1">{
                        return err
                }</span>
                <span class="cov8" title="1">promptIDs = append(promptIDs, promptID)</span>
        }

        <span class="cov8" title="1">current := 0
        totalCost := 0.0

        for _, promptID := range promptIDs </span><span class="cov8" title="1">{
                select </span>{
                case &lt;-cancelChan:<span class="cov8" title="1">
                        return fmt.Errorf("job cancelled")</span>
                default:<span class="cov8" title="1"></span>
                }

                <span class="cov8" title="1">cost, err := e.evaluateModelPromptPair(job.ID, job.TargetID, promptID)
                if err != nil </span><span class="cov8" title="1">{
                        log.Printf("Failed to evaluate prompt %d: %v", promptID, err)
                }</span>

                <span class="cov8" title="1">totalCost += cost
                current++

                if err := e.jobQueue.UpdateJobProgress(job.ID, current, job.ProgressTotal, totalCost); err != nil </span><span class="cov8" title="1">{
                        log.Printf("Failed to update progress: %v", err)
                }</span>
        }

        <span class="cov8" title="1">return nil</span>
}

// processPromptJob evaluates all models × one prompt
func (e *Evaluator) processPromptJob(job *EvaluationJob, cancelChan chan bool) error <span class="cov8" title="1">{
        // Get all models
        modelRows, err := e.db.Query("SELECT id FROM models WHERE suite_id = ?", job.SuiteID)
        if err != nil </span><span class="cov8" title="1">{
                return fmt.Errorf("failed to query models: %w", err)
        }</span>
        <span class="cov8" title="1">defer modelRows.Close()

        var modelIDs []int
        for modelRows.Next() </span><span class="cov8" title="1">{
                var modelID int
                if err := modelRows.Scan(&amp;modelID); err != nil </span><span class="cov8" title="1">{
                        return err
                }</span>
                <span class="cov8" title="1">modelIDs = append(modelIDs, modelID)</span>
        }

        <span class="cov8" title="1">current := 0
        totalCost := 0.0

        for _, modelID := range modelIDs </span><span class="cov8" title="1">{
                select </span>{
                case &lt;-cancelChan:<span class="cov8" title="1">
                        return fmt.Errorf("job cancelled")</span>
                default:<span class="cov8" title="1"></span>
                }

                <span class="cov8" title="1">cost, err := e.evaluateModelPromptPair(job.ID, modelID, job.TargetID)
                if err != nil </span><span class="cov8" title="1">{
                        log.Printf("Failed to evaluate model %d: %v", modelID, err)
                }</span>

                <span class="cov8" title="1">totalCost += cost
                current++

                if err := e.jobQueue.UpdateJobProgress(job.ID, current, job.ProgressTotal, totalCost); err != nil </span><span class="cov8" title="1">{
                        log.Printf("Failed to update progress: %v", err)
                }</span>
        }

        <span class="cov8" title="1">return nil</span>
}

// evaluateModelPromptPair evaluates a single model-prompt pair
func (e *Evaluator) evaluateModelPromptPair(jobID, modelID, promptID int) (float64, error) <span class="cov8" title="1">{
        // Get prompt data
        var promptText, solution, promptType string
        var solutionNull sql.NullString
        err := e.db.QueryRow(`
                SELECT text, solution, type
                FROM prompts
                WHERE id = ?
        `, promptID).Scan(&amp;promptText, &amp;solutionNull, &amp;promptType)

        if err != nil </span><span class="cov8" title="1">{
                return 0, fmt.Errorf("failed to get prompt: %w", err)
        }</span>

        <span class="cov8" title="1">if solutionNull.Valid </span><span class="cov8" title="1">{
                solution = solutionNull.String
        }</span>

        // Get model response (from model_responses table or generate placeholder)
        <span class="cov8" title="1">var response string
        err = e.db.QueryRow(`
                SELECT response_text
                FROM model_responses
                WHERE model_id = ? AND prompt_id = ?
        `, modelID, promptID).Scan(&amp;response)

        if err == sql.ErrNoRows </span><span class="cov8" title="1">{
                // No response stored - skip evaluation
                log.Printf("No response for model %d, prompt %d - skipping", modelID, promptID)
                return 0, nil
        }</span> else<span class="cov8" title="1"> if err != nil </span><span class="cov8" title="1">{
                return 0, fmt.Errorf("failed to get model response: %w", err)
        }</span>

        // Get API keys from settings
        <span class="cov8" title="1">apiKeys, err := e.getAPIKeys()
        if err != nil </span><span class="cov8" title="1">{
                return 0, fmt.Errorf("failed to get API keys: %w", err)
        }</span>

        // Call Python evaluation service
        <span class="cov8" title="1">evalReq := EvaluationRequest{
                Prompt:   promptText,
                Response: response,
                Solution: solution,
                Type:     promptType,
                Judges:   e.judges,
                APIKeys:  apiKeys,
        }

        evalResp, err := e.litellmClient.Evaluate(evalReq)
        if err != nil </span><span class="cov8" title="1">{
                return 0, fmt.Errorf("evaluation failed: %w", err)
        }</span>

        // Calculate consensus score
        <span class="cov8" title="1">consensusScore := RoundToValidScore(evalResp.ConsensusScore)

        // Update score in database
        _, err = e.db.Exec(`
                INSERT OR REPLACE INTO scores (model_id, prompt_id, score)
                VALUES (?, ?, ?)
        `, modelID, promptID, consensusScore)

        if err != nil </span><span class="cov8" title="1">{
                return 0, fmt.Errorf("failed to update score: %w", err)
        }</span>

        // Save evaluation history
        <span class="cov8" title="1">for _, result := range evalResp.Results </span><span class="cov8" title="1">{
                _, err = e.db.Exec(`
                        INSERT INTO evaluation_history (job_id, model_id, prompt_id, judge_name, judge_score, judge_confidence, judge_reasoning, cost_usd)
                        VALUES (?, ?, ?, ?, ?, ?, ?, ?)
                `, jobID, modelID, promptID, result.Judge, result.Score, result.Confidence, result.Reasoning, result.CostUSD)

                if err != nil </span><span class="cov8" title="1">{
                        log.Printf("Failed to save evaluation history: %v", err)
                }</span>
        }

        <span class="cov8" title="1">return evalResp.TotalCostUSD, nil</span>
}

// getAPIKeys retrieves API keys from settings
func (e *Evaluator) getAPIKeys() (map[string]string, error) <span class="cov8" title="1">{
        rows, err := e.db.Query(`
                SELECT key, value
                FROM settings
                WHERE key LIKE 'api_key_%'
        `)

        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>
        <span class="cov8" title="1">defer rows.Close()

        apiKeys := make(map[string]string)
        for rows.Next() </span><span class="cov8" title="1">{
                var key, value string
                if err := rows.Scan(&amp;key, &amp;value); err != nil </span><span class="cov8" title="1">{
                        return nil, err
                }</span>
                // TODO: Decrypt value using encryption module (Phase 4)
                <span class="cov8" title="1">apiKeys[key] = value</span>
        }

        <span class="cov8" title="1">return apiKeys, nil</span>
}

// GetJobStatus retrieves job status
func (e *Evaluator) GetJobStatus(jobID int) (*EvaluationJob, error) <span class="cov8" title="1">{
        return e.jobQueue.GetJob(jobID)
}</span>

// CancelJob cancels a running job
func (e *Evaluator) CancelJob(jobID int) error <span class="cov8" title="1">{
        return e.jobQueue.CancelJob(jobID)
}</span>
</pre>
		
		<pre class="file" id="file3" style="display: none">package evaluator

import (
        "database/sql"
        "fmt"
        "log"
        "sync"
        "time"
)

// JobQueue manages evaluation jobs with concurrent workers
type JobQueue struct {
        db          *sql.DB
        jobs        chan *EvaluationJob
        workers     int
        mu          sync.Mutex
        running     map[int]bool // Track running jobs
        cancel      map[int]chan bool
        evaluator   *Evaluator
        resumeDelay time.Duration // Delay before resuming pending jobs (configurable for testing)
}

var lastInsertID = func(result sql.Result) (int64, error) <span class="cov8" title="1">{ return result.LastInsertId() }</span>

// NewJobQueue creates a new job queue with the specified number of workers
func NewJobQueue(db *sql.DB, workers int, evaluator *Evaluator) *JobQueue <span class="cov8" title="1">{
        return NewJobQueueWithDelay(db, workers, evaluator, 5*time.Second)
}</span>

// NewJobQueueWithDelay creates a new job queue with a configurable resume delay (for testing)
func NewJobQueueWithDelay(db *sql.DB, workers int, evaluator *Evaluator, resumeDelay time.Duration) *JobQueue <span class="cov8" title="1">{
        jq := &amp;JobQueue{
                db:          db,
                jobs:        make(chan *EvaluationJob, 100),
                workers:     workers,
                running:     make(map[int]bool),
                cancel:      make(map[int]chan bool),
                evaluator:   evaluator,
                resumeDelay: resumeDelay,
        }

        // Start worker goroutines
        for i := 0; i &lt; workers; i++ </span><span class="cov8" title="1">{
                go jq.worker(i)
        }</span>

        // Resume pending jobs on startup
        <span class="cov8" title="1">go jq.resumePendingJobs()

        return jq</span>
}

// worker processes jobs from the queue
func (jq *JobQueue) worker(id int) <span class="cov8" title="1">{
        log.Printf("Worker %d started", id)
        for job := range jq.jobs </span><span class="cov8" title="1">{
                log.Printf("Worker %d processing job %d", id, job.ID)

                // Mark job as running
                jq.mu.Lock()
                jq.running[job.ID] = true
                cancelChan := make(chan bool, 1)
                jq.cancel[job.ID] = cancelChan
                jq.mu.Unlock()

                // Update job status to running
                now := time.Now()
                job.StartedAt = &amp;now
                job.Status = "running"
                if err := jq.updateJob(job); err != nil </span><span class="cov8" title="1">{
                        log.Printf("Failed to update job status: %v", err)
                }</span>

                // Process the job
                <span class="cov8" title="1">err := jq.evaluator.processJob(job, cancelChan)

                // Update job status
                completedAt := time.Now()
                job.CompletedAt = &amp;completedAt

                if err != nil </span><span class="cov8" title="1">{
                        job.Status = "failed"
                        job.ErrorMessage = err.Error()
                        log.Printf("Job %d failed: %v", job.ID, err)
                }</span> else<span class="cov8" title="1"> {
                        job.Status = "completed"
                        log.Printf("Job %d completed successfully", job.ID)
                }</span>

                <span class="cov8" title="1">if err := jq.updateJob(job); err != nil </span><span class="cov8" title="1">{
                        log.Printf("Failed to update job completion: %v", err)
                }</span>

                // Clean up
                <span class="cov8" title="1">jq.mu.Lock()
                delete(jq.running, job.ID)
                delete(jq.cancel, job.ID)
                jq.mu.Unlock()</span>
        }
}

// Enqueue adds a job to the queue
func (jq *JobQueue) Enqueue(job *EvaluationJob) error <span class="cov8" title="1">{
        // Insert job into database
        result, err := jq.db.Exec(`
                INSERT INTO evaluation_jobs (suite_id, job_type, target_id, status, progress_total, estimated_cost_usd)
                VALUES (?, ?, ?, 'pending', ?, ?)
        `, job.SuiteID, job.JobType, job.TargetID, job.ProgressTotal, job.EstimatedCost)

        if err != nil </span><span class="cov8" title="1">{
                return fmt.Errorf("failed to insert job: %w", err)
        }</span>

        <span class="cov8" title="1">jobID, err := lastInsertID(result)
        if err != nil </span><span class="cov8" title="1">{
                return fmt.Errorf("failed to get job ID: %w", err)
        }</span>

        <span class="cov8" title="1">job.ID = int(jobID)
        job.Status = "pending"
        job.CreatedAt = time.Now()

        // Add to queue
        jq.jobs &lt;- job

        return nil</span>
}

// CancelJob cancels a running job
func (jq *JobQueue) CancelJob(jobID int) error <span class="cov8" title="1">{
        jq.mu.Lock()
        defer jq.mu.Unlock()

        if cancelChan, ok := jq.cancel[jobID]; ok </span><span class="cov8" title="1">{
                cancelChan &lt;- true
                _, err := jq.db.Exec(`UPDATE evaluation_jobs SET status = 'cancelled' WHERE id = ?`, jobID)
                return err
        }</span>

        <span class="cov8" title="1">return fmt.Errorf("job %d not running", jobID)</span>
}

// GetJob retrieves a job by ID
func (jq *JobQueue) GetJob(jobID int) (*EvaluationJob, error) <span class="cov8" title="1">{
        job := &amp;EvaluationJob{}
        var startedAt, completedAt sql.NullTime

        err := jq.db.QueryRow(`
                SELECT id, suite_id, job_type, target_id, status, progress_current, progress_total,
                       estimated_cost_usd, actual_cost_usd, error_message, created_at, started_at, completed_at
                FROM evaluation_jobs
                WHERE id = ?
        `, jobID).Scan(
                &amp;job.ID, &amp;job.SuiteID, &amp;job.JobType, &amp;job.TargetID, &amp;job.Status,
                &amp;job.ProgressCurrent, &amp;job.ProgressTotal, &amp;job.EstimatedCost, &amp;job.ActualCost,
                &amp;job.ErrorMessage, &amp;job.CreatedAt, &amp;startedAt, &amp;completedAt,
        )

        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">if startedAt.Valid </span><span class="cov8" title="1">{
                job.StartedAt = &amp;startedAt.Time
        }</span>
        <span class="cov8" title="1">if completedAt.Valid </span><span class="cov8" title="1">{
                job.CompletedAt = &amp;completedAt.Time
        }</span>

        <span class="cov8" title="1">return job, nil</span>
}

// UpdateJobProgress updates job progress
func (jq *JobQueue) UpdateJobProgress(jobID, current, total int, cost float64) error <span class="cov8" title="1">{
        _, err := jq.db.Exec(`
                UPDATE evaluation_jobs
                SET progress_current = ?, progress_total = ?, actual_cost_usd = ?
                WHERE id = ?
        `, current, total, cost, jobID)

        return err
}</span>

// updateJob updates a job in the database
func (jq *JobQueue) updateJob(job *EvaluationJob) error <span class="cov8" title="1">{
        _, err := jq.db.Exec(`
                UPDATE evaluation_jobs
                SET status = ?, progress_current = ?, progress_total = ?,
                    estimated_cost_usd = ?, actual_cost_usd = ?, error_message = ?,
                    started_at = ?, completed_at = ?
                WHERE id = ?
        `, job.Status, job.ProgressCurrent, job.ProgressTotal,
                job.EstimatedCost, job.ActualCost, job.ErrorMessage,
                job.StartedAt, job.CompletedAt, job.ID)

        return err
}</span>

// resumePendingJobs resumes jobs that were interrupted
func (jq *JobQueue) resumePendingJobs() <span class="cov8" title="1">{
        if jq.resumeDelay &gt; 0 </span><span class="cov8" title="1">{
                time.Sleep(jq.resumeDelay) // Wait for initialization
        }</span>

        <span class="cov8" title="1">rows, err := jq.db.Query(`
                SELECT id, suite_id, job_type, target_id, progress_total, estimated_cost_usd
                FROM evaluation_jobs
                WHERE status = 'pending' OR status = 'running'
                ORDER BY created_at
        `)

        if err != nil </span><span class="cov8" title="1">{
                log.Printf("Failed to query pending jobs: %v", err)
                return
        }</span>
        <span class="cov8" title="1">defer rows.Close()

        count := 0
        for rows.Next() </span><span class="cov8" title="1">{
                job := &amp;EvaluationJob{}
                if err := rows.Scan(&amp;job.ID, &amp;job.SuiteID, &amp;job.JobType, &amp;job.TargetID,
                        &amp;job.ProgressTotal, &amp;job.EstimatedCost); err != nil </span><span class="cov8" title="1">{
                        log.Printf("Failed to scan job: %v", err)
                        continue</span>
                }

                <span class="cov8" title="1">job.Status = "pending"
                jq.jobs &lt;- job
                count++</span>
        }

        <span class="cov8" title="1">if count &gt; 0 </span><span class="cov8" title="1">{
                log.Printf("Resumed %d pending jobs", count)
        }</span>
}
</pre>
		
		<pre class="file" id="file4" style="display: none">package evaluator

import (
        "bytes"
        "encoding/json"
        "fmt"
        "io"
        "net/http"
        "time"
)

// LiteLLMClient handles communication with Python evaluation service
type LiteLLMClient struct {
        baseURL    string
        httpClient *http.Client
}

// NewLiteLLMClient creates a new LiteLLM client
func NewLiteLLMClient(baseURL string) *LiteLLMClient <span class="cov8" title="1">{
        return &amp;LiteLLMClient{
                baseURL: baseURL,
                httpClient: &amp;http.Client{
                        Timeout: 180 * time.Second, // 3 minutes for thinking models
                },
        }
}</span>

// Evaluate sends an evaluation request to the Python service
func (c *LiteLLMClient) Evaluate(req EvaluationRequest) (*EvaluationResponse, error) <span class="cov8" title="1">{
        jsonData, _ := json.Marshal(req)

        resp, err := c.httpClient.Post(
                c.baseURL+"/evaluate",
                "application/json",
                bytes.NewBuffer(jsonData),
        )
        if err != nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("failed to send request: %w", err)
        }</span>
        <span class="cov8" title="1">defer resp.Body.Close()

        if resp.StatusCode != http.StatusOK </span><span class="cov8" title="1">{
                body, _ := io.ReadAll(resp.Body)
                return nil, fmt.Errorf("evaluation failed with status %d: %s", resp.StatusCode, string(body))
        }</span>

        <span class="cov8" title="1">var evalResp EvaluationResponse
        if err := json.NewDecoder(resp.Body).Decode(&amp;evalResp); err != nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("failed to decode response: %w", err)
        }</span>

        <span class="cov8" title="1">return &amp;evalResp, nil</span>
}

// EstimateCost estimates the cost of an evaluation
func (c *LiteLLMClient) EstimateCost(req CostEstimateRequest) (*CostEstimateResponse, error) <span class="cov8" title="1">{
        jsonData, _ := json.Marshal(req)

        resp, err := c.httpClient.Post(
                c.baseURL+"/estimate_cost",
                "application/json",
                bytes.NewBuffer(jsonData),
        )
        if err != nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("failed to send request: %w", err)
        }</span>
        <span class="cov8" title="1">defer resp.Body.Close()

        if resp.StatusCode != http.StatusOK </span><span class="cov8" title="1">{
                body, _ := io.ReadAll(resp.Body)
                return nil, fmt.Errorf("cost estimation failed with status %d: %s", resp.StatusCode, string(body))
        }</span>

        <span class="cov8" title="1">var costResp CostEstimateResponse
        if err := json.NewDecoder(resp.Body).Decode(&amp;costResp); err != nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("failed to decode response: %w", err)
        }</span>

        <span class="cov8" title="1">return &amp;costResp, nil</span>
}

// HealthCheck checks if the Python service is healthy
func (c *LiteLLMClient) HealthCheck() error <span class="cov8" title="1">{
        resp, err := c.httpClient.Get(c.baseURL + "/health")
        if err != nil </span><span class="cov8" title="1">{
                return fmt.Errorf("health check failed: %w", err)
        }</span>
        <span class="cov8" title="1">defer resp.Body.Close()

        if resp.StatusCode != http.StatusOK </span><span class="cov8" title="1">{
                return fmt.Errorf("service unhealthy, status: %d", resp.StatusCode)
        }</span>

        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file5" style="display: none">package handlers

import (
        "database/sql"
        "fmt"
        "llm-tournament/evaluator"
        "llm-tournament/middleware"
        "log"
        "net/http"
        "strconv"
)

var globalEvaluator *evaluator.Evaluator

// InitEvaluator initializes the global evaluator instance
func InitEvaluator(db *sql.DB) <span class="cov8" title="1">{
        pythonURL, _ := middleware.GetSetting("python_service_url")
        if pythonURL == "" </span><span class="cov8" title="1">{
                pythonURL = "http://localhost:8001"
        }</span>
        <span class="cov8" title="1">globalEvaluator = evaluator.NewEvaluator(db, pythonURL)
        log.Printf("Evaluator initialized with Python service URL: %s", pythonURL)</span>
}

// EvaluateAllHandler triggers evaluation of all models × all prompts
func EvaluateAllHandler(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        if r.Method != http.MethodPost </span><span class="cov8" title="1">{
                http.Error(w, "Method not allowed", http.StatusMethodNotAllowed)
                return
        }</span>

        <span class="cov8" title="1">suiteID, err := middleware.GetCurrentSuiteID()
        if err != nil </span><span class="cov8" title="1">{
                log.Printf("Error getting current suite: %v", err)
                http.Error(w, "Failed to get current suite", http.StatusInternalServerError)
                return
        }</span>

        <span class="cov8" title="1">jobID, err := globalEvaluator.EvaluateAll(suiteID)
        if err != nil </span><span class="cov8" title="1">{
                log.Printf("Error starting evaluation: %v", err)
                http.Error(w, fmt.Sprintf("Failed to start evaluation: %v", err), http.StatusInternalServerError)
                return
        }</span>

        <span class="cov8" title="1">middleware.RespondJSON(w, map[string]interface{}{
                "success": true,
                "job_id":  jobID,
                "message": "Evaluation started",
        })</span>
}

// EvaluateModelHandler triggers evaluation of one model × all prompts
func EvaluateModelHandler(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        if r.Method != http.MethodPost </span><span class="cov8" title="1">{
                http.Error(w, "Method not allowed", http.StatusMethodNotAllowed)
                return
        }</span>

        <span class="cov8" title="1">modelIDStr := r.URL.Query().Get("id")
        if modelIDStr == "" </span><span class="cov8" title="1">{
                http.Error(w, "Model ID required", http.StatusBadRequest)
                return
        }</span>

        <span class="cov8" title="1">modelID, err := strconv.Atoi(modelIDStr)
        if err != nil </span><span class="cov8" title="1">{
                http.Error(w, "Invalid model ID", http.StatusBadRequest)
                return
        }</span>

        <span class="cov8" title="1">jobID, err := globalEvaluator.EvaluateModel(modelID)
        if err != nil </span><span class="cov8" title="1">{
                log.Printf("Error starting model evaluation: %v", err)
                http.Error(w, fmt.Sprintf("Failed to start evaluation: %v", err), http.StatusInternalServerError)
                return
        }</span>

        <span class="cov8" title="1">middleware.RespondJSON(w, map[string]interface{}{
                "success": true,
                "job_id":  jobID,
                "message": "Model evaluation started",
        })</span>
}

// EvaluatePromptHandler triggers evaluation of all models × one prompt
func EvaluatePromptHandler(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        if r.Method != http.MethodPost </span><span class="cov8" title="1">{
                http.Error(w, "Method not allowed", http.StatusMethodNotAllowed)
                return
        }</span>

        <span class="cov8" title="1">promptIDStr := r.URL.Query().Get("id")
        if promptIDStr == "" </span><span class="cov8" title="1">{
                http.Error(w, "Prompt ID required", http.StatusBadRequest)
                return
        }</span>

        <span class="cov8" title="1">promptID, err := strconv.Atoi(promptIDStr)
        if err != nil </span><span class="cov8" title="1">{
                http.Error(w, "Invalid prompt ID", http.StatusBadRequest)
                return
        }</span>

        <span class="cov8" title="1">jobID, err := globalEvaluator.EvaluatePrompt(promptID)
        if err != nil </span><span class="cov8" title="1">{
                log.Printf("Error starting prompt evaluation: %v", err)
                http.Error(w, fmt.Sprintf("Failed to start evaluation: %v", err), http.StatusInternalServerError)
                return
        }</span>

        <span class="cov8" title="1">middleware.RespondJSON(w, map[string]interface{}{
                "success": true,
                "job_id":  jobID,
                "message": "Prompt evaluation started",
        })</span>
}

// EvaluationProgressHandler returns the status of an evaluation job
func EvaluationProgressHandler(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        jobIDStr := r.URL.Query().Get("id")
        if jobIDStr == "" </span><span class="cov8" title="1">{
                http.Error(w, "Job ID required", http.StatusBadRequest)
                return
        }</span>

        <span class="cov8" title="1">jobID, err := strconv.Atoi(jobIDStr)
        if err != nil </span><span class="cov8" title="1">{
                http.Error(w, "Invalid job ID", http.StatusBadRequest)
                return
        }</span>

        <span class="cov8" title="1">job, err := globalEvaluator.GetJobStatus(jobID)
        if err != nil </span><span class="cov8" title="1">{
                log.Printf("Error getting job status: %v", err)
                http.Error(w, "Failed to get job status", http.StatusInternalServerError)
                return
        }</span>

        <span class="cov8" title="1">middleware.RespondJSON(w, map[string]interface{}{
                "job_id":           job.ID,
                "status":           job.Status,
                "progress_current": job.ProgressCurrent,
                "progress_total":   job.ProgressTotal,
                "estimated_cost":   job.EstimatedCost,
                "actual_cost":      job.ActualCost,
                "error":            job.ErrorMessage,
        })</span>
}

// CancelEvaluationHandler cancels a running evaluation job
func CancelEvaluationHandler(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        if r.Method != http.MethodPost </span><span class="cov8" title="1">{
                http.Error(w, "Method not allowed", http.StatusMethodNotAllowed)
                return
        }</span>

        <span class="cov8" title="1">jobIDStr := r.URL.Query().Get("id")
        if jobIDStr == "" </span><span class="cov8" title="1">{
                http.Error(w, "Job ID required", http.StatusBadRequest)
                return
        }</span>

        <span class="cov8" title="1">jobID, err := strconv.Atoi(jobIDStr)
        if err != nil </span><span class="cov8" title="1">{
                http.Error(w, "Invalid job ID", http.StatusBadRequest)
                return
        }</span>

        <span class="cov8" title="1">if err := globalEvaluator.CancelJob(jobID); err != nil </span><span class="cov8" title="1">{
                log.Printf("Error cancelling job: %v", err)
                http.Error(w, fmt.Sprintf("Failed to cancel job: %v", err), http.StatusInternalServerError)
                return
        }</span>

        <span class="cov8" title="1">middleware.RespondJSON(w, map[string]interface{}{
                "success": true,
                "message": "Job cancelled",
        })</span>
}
</pre>
		
		<pre class="file" id="file6" style="display: none">package handlers

import (
        "llm-tournament/middleware"
)

// Handler holds dependencies for HTTP handlers
type Handler struct {
        DataStore middleware.DataStore
        Renderer  middleware.TemplateRenderer
}

// NewHandler creates a new Handler with default dependencies
func NewHandler() *Handler <span class="cov8" title="1">{
        return &amp;Handler{
                DataStore: middleware.DefaultDataStore,
                Renderer:  middleware.DefaultRenderer,
        }
}</span>

// NewHandlerWithDeps creates a new Handler with custom dependencies (for testing)
func NewHandlerWithDeps(ds middleware.DataStore, r middleware.TemplateRenderer) *Handler <span class="cov8" title="1">{
        return &amp;Handler{
                DataStore: ds,
                Renderer:  r,
        }
}</span>

// DefaultHandler is the default handler instance used by HTTP routes
var DefaultHandler = NewHandler()
</pre>
		
		<pre class="file" id="file7" style="display: none">package handlers

import (
        "log"
        "net/http"

        "llm-tournament/middleware"
)

// AddModelHandler handles adding a model (backward compatible wrapper)
func AddModelHandler(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        DefaultHandler.AddModel(w, r)
}</span>

// EditModelHandler handles editing a model (backward compatible wrapper)
func EditModelHandler(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        DefaultHandler.EditModel(w, r)
}</span>

// DeleteModelHandler handles deleting a model (backward compatible wrapper)
func DeleteModelHandler(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        DefaultHandler.DeleteModel(w, r)
}</span>

// AddModel handles adding a model
func (h *Handler) AddModel(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        log.Println("Handling add model")
        if r.Method != http.MethodPost </span><span class="cov8" title="1">{
                http.Error(w, "Method not allowed", http.StatusMethodNotAllowed)
                return
        }</span>
        <span class="cov8" title="1">err := r.ParseForm()
        if err != nil </span><span class="cov8" title="1">{
                log.Printf("Error parsing form: %v", err)
                http.Error(w, "Error parsing form", http.StatusBadRequest)
                return
        }</span>
        <span class="cov8" title="1">modelName := r.Form.Get("model")
        if modelName == "" </span><span class="cov8" title="1">{
                log.Println("Model name cannot be empty")
                http.Error(w, "Model name cannot be empty", http.StatusBadRequest)
                return
        }</span>
        <span class="cov8" title="1">results := h.DataStore.ReadResults()
        if results == nil </span><span class="cov8" title="1">{
                results = make(map[string]middleware.Result)
        }</span>
        <span class="cov8" title="1">if _, ok := results[modelName]; !ok </span><span class="cov8" title="1">{
                results[modelName] = middleware.Result{Scores: make([]int, len(h.DataStore.ReadPrompts()))}
        }</span>
        <span class="cov8" title="1">suiteName := h.DataStore.GetCurrentSuiteName()
        err = h.DataStore.WriteResults(suiteName, results)
        if err != nil </span><span class="cov8" title="1">{
                log.Printf("Error writing results: %v", err)
                http.Error(w, "Error writing results", http.StatusInternalServerError)
                return
        }</span>
        <span class="cov8" title="1">log.Println("Model added successfully")
        h.DataStore.BroadcastResults()
        http.Redirect(w, r, "/results", http.StatusSeeOther)</span>
}

// EditModel handles editing a model
func (h *Handler) EditModel(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        log.Println("Handling edit model")
        modelName := r.URL.Query().Get("model")
        if modelName == "" </span><span class="cov8" title="1">{
                http.Error(w, "Model name is required", http.StatusBadRequest)
                return
        }</span>

        <span class="cov8" title="1">if r.Method == "POST" </span><span class="cov8" title="1">{
                newModelName := r.FormValue("new_model_name")
                if newModelName == "" </span><span class="cov8" title="1">{
                        http.Error(w, "New model name cannot be empty", http.StatusBadRequest)
                        return
                }</span>

                <span class="cov8" title="1">results := h.DataStore.ReadResults()
                if _, exists := results[newModelName]; exists </span><span class="cov8" title="1">{
                        http.Error(w, "Model with this name already exists", http.StatusBadRequest)
                        return
                }</span>

                <span class="cov8" title="1">results[newModelName] = results[modelName]
                delete(results, modelName)
                suiteName := h.DataStore.GetCurrentSuiteName()
                if err := h.DataStore.WriteResults(suiteName, results); err != nil </span><span class="cov8" title="1">{
                        log.Printf("Error writing results: %v", err)
                        http.Error(w, "Error writing results", http.StatusInternalServerError)
                        return
                }</span>

                <span class="cov8" title="1">h.DataStore.BroadcastResults()
                http.Redirect(w, r, "/results", http.StatusSeeOther)
                return</span>
        }

        <span class="cov8" title="1">if r.Method != "GET" </span><span class="cov8" title="1">{
                http.Error(w, "Method not allowed", http.StatusMethodNotAllowed)
                return
        }</span>

        // Render the edit model form
        <span class="cov8" title="1">if err := h.Renderer.RenderTemplateSimple(w, "edit_model.html", map[string]string{"Model": modelName}); err != nil </span><span class="cov8" title="1">{
                log.Printf("Error rendering template: %v", err)
                http.Error(w, "Error rendering template", http.StatusInternalServerError)
        }</span>
}

// DeleteModel handles deleting a model
func (h *Handler) DeleteModel(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        log.Println("Handling delete model")
        if r.Method == "GET" </span><span class="cov8" title="1">{
                modelName := r.URL.Query().Get("model")
                if modelName == "" </span><span class="cov8" title="1">{
                        http.Error(w, "Model name is required", http.StatusBadRequest)
                        return
                }</span>
                <span class="cov8" title="1">if err := h.Renderer.RenderTemplateSimple(w, "delete_model.html", map[string]string{"Model": modelName}); err != nil </span><span class="cov8" title="1">{
                        log.Printf("Error rendering template: %v", err)
                        http.Error(w, "Error rendering template", http.StatusInternalServerError)
                }</span>
        } else<span class="cov8" title="1"> if r.Method == "POST" </span><span class="cov8" title="1">{
                modelName := r.FormValue("model")
                if modelName == "" </span><span class="cov8" title="1">{
                        http.Error(w, "Model name is required", http.StatusBadRequest)
                        return
                }</span>

                <span class="cov8" title="1">results := h.DataStore.ReadResults()
                delete(results, modelName)
                suiteName := h.DataStore.GetCurrentSuiteName()
                if err := h.DataStore.WriteResults(suiteName, results); err != nil </span><span class="cov8" title="1">{
                        log.Printf("Error writing results: %v", err)
                        http.Error(w, "Error writing results", http.StatusInternalServerError)
                        return
                }</span>

                <span class="cov8" title="1">h.DataStore.BroadcastResults()
                http.Redirect(w, r, "/results", http.StatusSeeOther)</span>
        } else<span class="cov8" title="1"> {
                http.Error(w, "Method not allowed", http.StatusMethodNotAllowed)
        }</span>
}
</pre>
		
		<pre class="file" id="file8" style="display: none">package handlers

import (
        "log"
        "net/http"
        "strconv"

        "llm-tournament/middleware"
        "llm-tournament/templates"
)

// ProfilesHandler handles the profiles page (backward compatible wrapper)
func ProfilesHandler(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        DefaultHandler.Profiles(w, r)
}</span>

// AddProfileHandler handles adding a profile (backward compatible wrapper)
func AddProfileHandler(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        DefaultHandler.AddProfile(w, r)
}</span>

// EditProfileHandler handles editing a profile (backward compatible wrapper)
func EditProfileHandler(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        DefaultHandler.EditProfile(w, r)
}</span>

// DeleteProfileHandler handles deleting a profile (backward compatible wrapper)
func DeleteProfileHandler(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        DefaultHandler.DeleteProfile(w, r)
}</span>

// ResetProfilesHandler handles resetting profiles (backward compatible wrapper)
func ResetProfilesHandler(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        DefaultHandler.ResetProfiles(w, r)
}</span>

// Profiles handles the profiles page
func (h *Handler) Profiles(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        log.Println("Handling profiles page")
        searchQuery := r.FormValue("search_query")

        funcMap := templates.FuncMap

        pageName := "Profiles"
        profiles := h.DataStore.ReadProfiles()

        err := h.Renderer.Render(w, "profiles.html", funcMap, struct {
                PageName    string
                Profiles    []middleware.Profile
                SearchQuery string
        }{
                PageName:    pageName,
                Profiles:    profiles,
                SearchQuery: searchQuery,
        }, "templates/profiles.html", "templates/nav.html")
        if err != nil </span><span class="cov8" title="1">{
                log.Printf("Error rendering template: %v", err)
                http.Error(w, "Error rendering template", http.StatusInternalServerError)
                return
        }</span>
        <span class="cov8" title="1">log.Println("Profiles page rendered successfully")</span>
}

// AddProfile handles adding a profile
func (h *Handler) AddProfile(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        log.Println("Handling add profile")
        if r.Method != http.MethodPost </span><span class="cov8" title="1">{
                http.Error(w, "Method not allowed", http.StatusMethodNotAllowed)
                return
        }</span>
        <span class="cov8" title="1">err := r.ParseForm()
        if err != nil </span><span class="cov8" title="1">{
                log.Printf("Error parsing form: %v", err)
                http.Error(w, "Error parsing form", http.StatusBadRequest)
                return
        }</span>
        <span class="cov8" title="1">profileName := r.Form.Get("profile_name")
        profileDescription := r.Form.Get("profile_description")
        if profileName == "" </span><span class="cov8" title="1">{
                log.Println("Profile name cannot be empty")
                http.Error(w, "Profile name cannot be empty", http.StatusBadRequest)
                return
        }</span>

        <span class="cov8" title="1">profiles := h.DataStore.ReadProfiles()
        profiles = append(profiles, middleware.Profile{Name: profileName, Description: profileDescription})
        err = h.DataStore.WriteProfiles(profiles)
        if err != nil </span><span class="cov8" title="1">{
                log.Printf("Error writing profiles: %v", err)
                http.Error(w, "Error writing profiles", http.StatusInternalServerError)
                return
        }</span>
        <span class="cov8" title="1">log.Println("Profile added successfully")
        http.Redirect(w, r, "/profiles", http.StatusSeeOther)</span>
}

// EditProfile handles editing a profile
func (h *Handler) EditProfile(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        log.Println("Handling edit profile")
        if r.Method == "GET" </span><span class="cov8" title="1">{
                err := r.ParseForm()
                if err != nil </span><span class="cov8" title="1">{
                        log.Printf("Error parsing form: %v", err)
                        http.Error(w, "Error parsing form", http.StatusBadRequest)
                        return
                }</span>
                <span class="cov8" title="1">indexStr := r.Form.Get("index")
                index, err := strconv.Atoi(indexStr)
                if err != nil </span><span class="cov8" title="1">{
                        log.Printf("Invalid index: %v", err)
                        http.Error(w, "Invalid index", http.StatusBadRequest)
                        return
                }</span>
                <span class="cov8" title="1">profiles := h.DataStore.ReadProfiles()
                if index &gt;= 0 &amp;&amp; index &lt; len(profiles) </span><span class="cov8" title="1">{
                        funcMap := templates.FuncMap
                        err := h.Renderer.Render(w, "edit_profile.html", funcMap, struct {
                                Index   int
                                Profile middleware.Profile
                        }{
                                Index:   index,
                                Profile: profiles[index],
                        }, "templates/edit_profile.html")
                        if err != nil </span><span class="cov8" title="1">{
                                log.Printf("Error rendering template: %v", err)
                                http.Error(w, "Error rendering template", http.StatusInternalServerError)
                                return
                        }</span>
                }
        } else<span class="cov8" title="1"> if r.Method == "POST" </span><span class="cov8" title="1">{
                err := r.ParseForm()
                if err != nil </span><span class="cov8" title="1">{
                        log.Printf("Error parsing form: %v", err)
                        http.Error(w, "Error parsing form", http.StatusBadRequest)
                        return
                }</span>
                <span class="cov8" title="1">indexStr := r.Form.Get("index")
                index, err := strconv.Atoi(indexStr)
                if err != nil </span><span class="cov8" title="1">{
                        log.Printf("Invalid index: %v", err)
                        http.Error(w, "Invalid index", http.StatusBadRequest)
                        return
                }</span>
                <span class="cov8" title="1">editedProfileName := r.Form.Get("profile_name")
                editedProfileDescription := r.Form.Get("profile_description")
                if editedProfileName == "" </span><span class="cov8" title="1">{
                        log.Println("Profile name cannot be empty")
                        http.Error(w, "Profile name cannot be empty", http.StatusBadRequest)
                        return
                }</span>
                <span class="cov8" title="1">profiles := h.DataStore.ReadProfiles()
                if index &gt;= 0 &amp;&amp; index &lt; len(profiles) </span><span class="cov8" title="1">{
                        oldProfileName := profiles[index].Name
                        profiles[index].Name = editedProfileName
                        profiles[index].Description = editedProfileDescription

                        // Update prompts that reference this profile
                        prompts := h.DataStore.ReadPrompts()
                        for i := range prompts </span><span class="cov8" title="1">{
                                if prompts[i].Profile == oldProfileName </span><span class="cov8" title="1">{
                                        prompts[i].Profile = editedProfileName
                                }</span>
                        }
                        <span class="cov8" title="1">err = h.DataStore.WritePrompts(prompts)
                        if err != nil </span><span class="cov8" title="1">{
                                log.Printf("Error updating prompts: %v", err)
                                http.Error(w, "Error updating prompts", http.StatusInternalServerError)
                                return
                        }</span>
                }
                <span class="cov8" title="1">err = h.DataStore.WriteProfiles(profiles)
                if err != nil </span><span class="cov8" title="1">{
                        log.Printf("Error writing profiles: %v", err)
                        http.Error(w, "Error writing profiles", http.StatusInternalServerError)
                        return
                }</span>
                <span class="cov8" title="1">log.Println("Profile edited successfully")
                http.Redirect(w, r, "/profiles", http.StatusSeeOther)</span>
        } else<span class="cov8" title="1"> {
                http.Error(w, "Method not allowed", http.StatusMethodNotAllowed)
        }</span>
}

// DeleteProfile handles deleting a profile
func (h *Handler) DeleteProfile(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        log.Println("Handling delete profile")
        if r.Method == "GET" </span><span class="cov8" title="1">{
                err := r.ParseForm()
                if err != nil </span><span class="cov8" title="1">{
                        log.Printf("Error parsing form: %v", err)
                        http.Error(w, "Error parsing form", http.StatusBadRequest)
                        return
                }</span>
                <span class="cov8" title="1">indexStr := r.Form.Get("index")
                index, err := strconv.Atoi(indexStr)
                if err != nil </span><span class="cov8" title="1">{
                        log.Printf("Invalid index: %v", err)
                        http.Error(w, "Invalid index", http.StatusBadRequest)
                        return
                }</span>
                <span class="cov8" title="1">profiles := h.DataStore.ReadProfiles()
                if index &gt;= 0 &amp;&amp; index &lt; len(profiles) </span><span class="cov8" title="1">{
                        funcMap := templates.FuncMap
                        err := h.Renderer.Render(w, "delete_profile.html", funcMap, struct {
                                Index   int
                                Profile middleware.Profile
                        }{
                                Index:   index,
                                Profile: profiles[index],
                        }, "templates/delete_profile.html")
                        if err != nil </span><span class="cov8" title="1">{
                                log.Printf("Error rendering template: %v", err)
                                http.Error(w, "Error rendering template", http.StatusInternalServerError)
                                return
                        }</span>
                }
        } else<span class="cov8" title="1"> if r.Method == "POST" </span><span class="cov8" title="1">{
                err := r.ParseForm()
                if err != nil </span><span class="cov8" title="1">{
                        log.Printf("Error parsing form: %v", err)
                        http.Error(w, "Error parsing form", http.StatusBadRequest)
                        return
                }</span>
                <span class="cov8" title="1">indexStr := r.Form.Get("index")
                index, err := strconv.Atoi(indexStr)
                if err != nil </span><span class="cov8" title="1">{
                        log.Printf("Invalid index: %v", err)
                        http.Error(w, "Invalid index", http.StatusBadRequest)
                        return
                }</span>
                <span class="cov8" title="1">profiles := h.DataStore.ReadProfiles()
                if index &gt;= 0 &amp;&amp; index &lt; len(profiles) </span><span class="cov8" title="1">{
                        profiles = append(profiles[:index], profiles[index+1:]...)
                }</span>
                <span class="cov8" title="1">err = h.DataStore.WriteProfiles(profiles)
                if err != nil </span><span class="cov8" title="1">{
                        log.Printf("Error writing profiles: %v", err)
                        http.Error(w, "Error writing profiles", http.StatusInternalServerError)
                        return
                }</span>
                <span class="cov8" title="1">log.Println("Profile deleted successfully")
                http.Redirect(w, r, "/profiles", http.StatusSeeOther)</span>
        } else<span class="cov8" title="1"> {
                http.Error(w, "Method not allowed", http.StatusMethodNotAllowed)
        }</span>
}

// ResetProfiles handles resetting profiles
func (h *Handler) ResetProfiles(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        log.Println("Handling reset profiles")
        if r.Method == "GET" </span><span class="cov8" title="1">{
                if err := h.Renderer.RenderTemplateSimple(w, "reset_profiles.html", nil); err != nil </span><span class="cov8" title="1">{
                        log.Printf("Error rendering template: %v", err)
                        http.Error(w, "Error rendering template", http.StatusInternalServerError)
                }</span>
        } else<span class="cov8" title="1"> if r.Method == "POST" </span><span class="cov8" title="1">{
                err := h.DataStore.WriteProfiles([]middleware.Profile{})
                if err != nil </span><span class="cov8" title="1">{
                        log.Printf("Error writing profiles: %v", err)
                        http.Error(w, "Error writing profiles", http.StatusInternalServerError)
                        return
                }</span>
                <span class="cov8" title="1">log.Println("Profiles reset successfully")
                http.Redirect(w, r, "/profiles", http.StatusSeeOther)</span>
        } else<span class="cov8" title="1"> {
                http.Error(w, "Method not allowed", http.StatusMethodNotAllowed)
        }</span>
}
</pre>
		
		<pre class="file" id="file9" style="display: none">package handlers

import (
        "encoding/json"
        "io"
        "log"
        "net/http"
        "strconv"

        "llm-tournament/middleware"
        "llm-tournament/templates"
)

var readAll = io.ReadAll

// PromptListHandler handles the prompt list page (backward compatible wrapper)
func PromptListHandler(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        DefaultHandler.PromptList(w, r)
}</span>

// UpdatePromptsOrderHandler handles updating prompts order (backward compatible wrapper)
func UpdatePromptsOrderHandler(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        DefaultHandler.UpdatePromptsOrder(w, r)
}</span>

// AddPromptHandler handles adding a prompt (backward compatible wrapper)
func AddPromptHandler(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        DefaultHandler.AddPrompt(w, r)
}</span>

// ExportPromptsHandler handles exporting prompts (backward compatible wrapper)
func ExportPromptsHandler(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        DefaultHandler.ExportPrompts(w, r)
}</span>

// ImportPromptsHandler handles importing prompts (backward compatible wrapper)
func ImportPromptsHandler(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        DefaultHandler.ImportPrompts(w, r)
}</span>

// ImportResultsHandler handles importing results (backward compatible wrapper)
func ImportResultsHandler(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        DefaultHandler.ImportResults(w, r)
}</span>

// EditPromptHandler handles editing a prompt (backward compatible wrapper)
func EditPromptHandler(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        DefaultHandler.EditPrompt(w, r)
}</span>

// BulkDeletePromptsPageHandler handles bulk delete prompts page (backward compatible wrapper)
func BulkDeletePromptsPageHandler(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        DefaultHandler.BulkDeletePromptsPage(w, r)
}</span>

// BulkDeletePromptsHandler handles bulk delete prompts (backward compatible wrapper)
func BulkDeletePromptsHandler(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        DefaultHandler.BulkDeletePrompts(w, r)
}</span>

// DeletePromptHandler handles deleting a prompt (backward compatible wrapper)
func DeletePromptHandler(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        DefaultHandler.DeletePrompt(w, r)
}</span>

// MovePromptHandler handles moving a prompt (backward compatible wrapper)
func MovePromptHandler(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        DefaultHandler.MovePrompt(w, r)
}</span>

// ResetPromptsHandler handles resetting prompts (backward compatible wrapper)
func ResetPromptsHandler(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        DefaultHandler.ResetPrompts(w, r)
}</span>

// PromptList handles the prompt list page
func (h *Handler) PromptList(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        log.Println("Handling prompt list page")
        orderFilter := r.FormValue("order_filter")
        profileFilter := r.FormValue("profile_filter")
        searchQuery := r.FormValue("search_query")

        orderFilterInt := 0
        if orderFilter != "" </span><span class="cov8" title="1">{
                var err error
                orderFilterInt, err = strconv.Atoi(orderFilter)
                if err != nil </span><span class="cov8" title="1">{
                        log.Printf("Invalid order filter: %v", err)
                        http.Error(w, "Invalid order filter", http.StatusBadRequest)
                        return
                }</span>
        }

        <span class="cov8" title="1">funcMap := templates.FuncMap

        suites, err := h.DataStore.ListPromptSuites()
        if err != nil </span><span class="cov8" title="1">{
                log.Printf("Error listing prompt suites: %v", err)
                http.Error(w, "Error listing prompt suites", http.StatusInternalServerError)
                return
        }</span>

        <span class="cov8" title="1">currentSuite := h.DataStore.GetCurrentSuiteName()
        var prompts []middleware.Prompt
        if currentSuite == "" </span><span class="cov8" title="1">{
                currentSuite = "default"
        }</span>
        <span class="cov8" title="1">prompts, err = h.DataStore.ReadPromptSuite(currentSuite)
        if err != nil </span><span class="cov8" title="1">{
                log.Printf("Error reading prompt suite: %v", err)
                http.Error(w, "Error reading prompt suite", http.StatusInternalServerError)
                return
        }</span>
        <span class="cov8" title="1">if len(prompts) == 0 &amp;&amp; currentSuite == "default" </span><span class="cov8" title="1">{
                prompts, err = h.DataStore.ReadPromptSuite("default")
                if err != nil </span><span class="cov8" title="1">{
                        log.Printf("Error reading default prompt suite: %v", err)
                        http.Error(w, "Error reading default prompt suite", http.StatusInternalServerError)
                        return
                }</span>
        }
        <span class="cov8" title="1">promptTexts := make([]middleware.Prompt, len(prompts))
        promptIndices := make([]int, len(prompts))
        for i, prompt := range prompts </span><span class="cov8" title="1">{
                promptTexts[i] = prompt
                promptIndices[i] = i + 1
        }</span>

        <span class="cov8" title="1">profiles := h.DataStore.ReadProfiles()
        pageName := "Prompts"

        err = h.Renderer.Render(w, "prompt_list.html", funcMap, struct {
                PageName      string
                Prompts       []middleware.Prompt
                PromptIndices []int
                Profiles      []middleware.Profile
                OrderFilter   int
                ProfileFilter string
                SearchQuery   string
                Suites        []string
                CurrentSuite  string
        }{
                PageName:      pageName,
                Prompts:       promptTexts,
                PromptIndices: promptIndices,
                Profiles:      profiles,
                OrderFilter:   orderFilterInt,
                ProfileFilter: profileFilter,
                SearchQuery:   searchQuery,
                Suites:        suites,
                CurrentSuite:  currentSuite,
        }, "templates/prompt_list.html", "templates/nav.html")
        if err != nil </span><span class="cov8" title="1">{
                log.Printf("Error rendering template: %v", err)
                http.Error(w, "Error rendering template", http.StatusInternalServerError)
                return
        }</span>
        <span class="cov8" title="1">log.Println("Prompt list page rendered successfully")</span>
}

// UpdatePromptsOrder handles updating prompts order
func (h *Handler) UpdatePromptsOrder(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        log.Println("Handling update prompts order")
        if r.Method != http.MethodPost </span><span class="cov8" title="1">{
                http.Error(w, "Method not allowed", http.StatusMethodNotAllowed)
                return
        }</span>
        <span class="cov8" title="1">err := r.ParseForm()
        if err != nil </span><span class="cov8" title="1">{
                log.Printf("Error parsing form: %v", err)
                http.Error(w, "Error parsing form", http.StatusBadRequest)
                return
        }</span>
        <span class="cov8" title="1">orderStr := r.Form.Get("order")
        if orderStr == "" </span><span class="cov8" title="1">{
                log.Println("Order cannot be empty")
                http.Error(w, "Order cannot be empty", http.StatusBadRequest)
                return
        }</span>
        <span class="cov8" title="1">var order []int
        err = json.Unmarshal([]byte(orderStr), &amp;order)
        if err != nil </span><span class="cov8" title="1">{
                log.Printf("Error parsing order: %v", err)
                http.Error(w, "Error parsing order", http.StatusBadRequest)
                return
        }</span>
        <span class="cov8" title="1">h.DataStore.UpdatePromptsOrder(order)
        http.Redirect(w, r, "/prompts", http.StatusSeeOther)</span>
}

// AddPrompt handles adding a prompt
func (h *Handler) AddPrompt(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        log.Println("Handling add prompt")
        if r.Method != http.MethodPost </span><span class="cov8" title="1">{
                http.Error(w, "Method not allowed", http.StatusMethodNotAllowed)
                return
        }</span>
        <span class="cov8" title="1">err := r.ParseForm()
        if err != nil </span><span class="cov8" title="1">{
                log.Printf("Error parsing form: %v", err)
                http.Error(w, "Error parsing form", http.StatusBadRequest)
                return
        }</span>
        <span class="cov8" title="1">promptText := r.Form.Get("prompt")
        if promptText == "" </span><span class="cov8" title="1">{
                log.Println("Prompt text cannot be empty")
                http.Error(w, "Prompt text cannot be empty", http.StatusBadRequest)
                return
        }</span>
        <span class="cov8" title="1">solutionText := r.Form.Get("solution")
        profile := r.Form.Get("profile")

        currentSuite := h.DataStore.GetCurrentSuiteName()
        if currentSuite == "" </span><span class="cov8" title="1">{
                currentSuite = "default"
        }</span>

        <span class="cov8" title="1">prompts, err := h.DataStore.ReadPromptSuite(currentSuite)
        if err != nil </span><span class="cov8" title="1">{
                log.Printf("Error reading prompt suite: %v", err)
                http.Error(w, "Error reading prompt suite", http.StatusInternalServerError)
                return
        }</span>

        <span class="cov8" title="1">prompts = append(prompts, middleware.Prompt{Text: promptText, Solution: solutionText, Profile: profile})
        err = h.DataStore.WritePromptSuite(currentSuite, prompts)
        if err != nil </span><span class="cov8" title="1">{
                log.Printf("Error writing prompts: %v", err)
                http.Error(w, "Error writing prompts", http.StatusInternalServerError)
                return
        }</span>
        <span class="cov8" title="1">log.Println("Prompt added successfully")
        h.DataStore.BroadcastResults()
        http.Redirect(w, r, "/prompts", http.StatusSeeOther)</span>
}

// ExportPrompts handles exporting prompts
func (h *Handler) ExportPrompts(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        log.Println("Handling export prompts")
        if r.Method != http.MethodGet </span><span class="cov8" title="1">{
                http.Error(w, "Method not allowed", http.StatusMethodNotAllowed)
                return
        }</span>
        <span class="cov8" title="1">prompts := h.DataStore.ReadPrompts()

        // Convert prompts to JSON
        jsonData, _ := json.MarshalIndent(prompts, "", "  ")

        // Set headers for JSON download
        w.Header().Set("Content-Type", "application/json")
        w.Header().Set("Content-Disposition", "attachment;filename=prompts.json")

        // Write JSON to response
        _, err := w.Write(jsonData)
        if err != nil </span><span class="cov8" title="1">{
                log.Printf("Error writing response: %v", err)
                http.Error(w, "Error writing response", http.StatusInternalServerError)
                return
        }</span>
        <span class="cov8" title="1">log.Println("Prompts exported successfully as JSON")</span>
}

// ImportPrompts handles importing prompts
func (h *Handler) ImportPrompts(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        log.Println("Handling import prompts")
        if r.Method == "POST" </span><span class="cov8" title="1">{
                file, _, err := r.FormFile("prompts_file")
                if err != nil </span><span class="cov8" title="1">{
                        log.Printf("Error uploading file: %v", err)
                        http.Redirect(w, r, "/import_error", http.StatusSeeOther)
                        return
                }</span>
                <span class="cov8" title="1">defer file.Close()

                // Read the file content
                data, err := readAll(file)
                if err != nil </span><span class="cov8" title="1">{
                        log.Printf("Error reading file: %v", err)
                        http.Error(w, "Error reading file", http.StatusInternalServerError)
                        return
                }</span>

                // Parse JSON data
                <span class="cov8" title="1">var prompts []middleware.Prompt
                err = json.Unmarshal(data, &amp;prompts)
                if err != nil </span><span class="cov8" title="1">{
                        log.Printf("Error parsing JSON: %v", err)
                        http.Redirect(w, r, "/import_error", http.StatusSeeOther)
                        return
                }</span>

                // Validate imported prompts
                <span class="cov8" title="1">if len(prompts) == 0 </span><span class="cov8" title="1">{
                        log.Println("No prompts found in JSON file")
                        http.Redirect(w, r, "/import_error", http.StatusSeeOther)
                        return
                }</span>

                // Write the imported prompts
                <span class="cov8" title="1">err = h.DataStore.WritePrompts(prompts)
                if err != nil </span><span class="cov8" title="1">{
                        log.Printf("Error writing prompts: %v", err)
                        http.Error(w, "Error writing prompts", http.StatusInternalServerError)
                        return
                }</span>

                <span class="cov8" title="1">log.Println("Prompts imported successfully from JSON")
                h.DataStore.BroadcastResults()
                http.Redirect(w, r, "/prompts", http.StatusSeeOther)</span>
        } else<span class="cov8" title="1"> if r.Method == "GET" </span><span class="cov8" title="1">{
                if err := h.Renderer.RenderTemplateSimple(w, "import_prompts.html", nil); err != nil </span><span class="cov8" title="1">{
                        log.Printf("Error rendering template: %v", err)
                        http.Error(w, "Error rendering template", http.StatusInternalServerError)
                }</span>
        } else<span class="cov8" title="1"> {
                http.Error(w, "Method not allowed", http.StatusMethodNotAllowed)
        }</span>
}

// ImportResults handles importing results
func (h *Handler) ImportResults(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        log.Println("Handling import results")
        if r.Method == "POST" </span><span class="cov8" title="1">{
                file, _, err := r.FormFile("results_file")
                if err != nil </span><span class="cov8" title="1">{
                        log.Printf("Error uploading file: %v", err)
                        http.Redirect(w, r, "/import_error", http.StatusSeeOther)
                        return
                }</span>
                <span class="cov8" title="1">defer file.Close()

                // Read the file content
                data, err := readAll(file)
                if err != nil </span><span class="cov8" title="1">{
                        log.Printf("Error reading file: %v", err)
                        http.Error(w, "Error reading file", http.StatusInternalServerError)
                        return
                }</span>

                // Parse JSON data
                <span class="cov8" title="1">var results map[string]middleware.Result
                err = json.Unmarshal(data, &amp;results)
                if err != nil </span><span class="cov8" title="1">{
                        log.Printf("Error parsing JSON: %v", err)
                        http.Redirect(w, r, "/import_error", http.StatusSeeOther)
                        return
                }</span>

                // Validate imported results
                <span class="cov8" title="1">if len(results) == 0 </span><span class="cov8" title="1">{
                        log.Println("No results found in JSON file")
                        http.Redirect(w, r, "/import_error", http.StatusSeeOther)
                        return
                }</span>

                // Ensure scores arrays match prompts length
                <span class="cov8" title="1">prompts := h.DataStore.ReadPrompts()
                for model, result := range results </span><span class="cov8" title="1">{
                        if len(result.Scores) &lt; len(prompts) </span><span class="cov8" title="1">{
                                newScores := make([]int, len(prompts))
                                copy(newScores, result.Scores)
                                result.Scores = newScores
                                results[model] = result
                        }</span>
                }

                // Write the imported results
                <span class="cov8" title="1">suiteName := h.DataStore.GetCurrentSuiteName()
                err = h.DataStore.WriteResults(suiteName, results)
                if err != nil </span><span class="cov8" title="1">{
                        log.Printf("Error writing results: %v", err)
                        http.Error(w, "Error writing results", http.StatusInternalServerError)
                        return
                }</span>

                <span class="cov8" title="1">log.Println("Results imported successfully from JSON")
                h.DataStore.BroadcastResults()
                http.Redirect(w, r, "/results", http.StatusSeeOther)</span>
        } else<span class="cov8" title="1"> if r.Method == "GET" </span><span class="cov8" title="1">{
                if err := h.Renderer.RenderTemplateSimple(w, "import_results.html", nil); err != nil </span><span class="cov8" title="1">{
                        log.Printf("Error rendering template: %v", err)
                        http.Error(w, "Error rendering template", http.StatusInternalServerError)
                }</span>
        } else<span class="cov8" title="1"> {
                http.Error(w, "Method not allowed", http.StatusMethodNotAllowed)
        }</span>
}

// EditPrompt handles editing a prompt
func (h *Handler) EditPrompt(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        log.Println("Handling edit prompt")
        if r.Method == "GET" </span><span class="cov8" title="1">{
                err := r.ParseForm()
                if err != nil </span><span class="cov8" title="1">{
                        log.Printf("Error parsing form: %v", err)
                        http.Error(w, "Error parsing form", http.StatusBadRequest)
                        return
                }</span>
                <span class="cov8" title="1">indexStr := r.Form.Get("index")
                index, err := strconv.Atoi(indexStr)
                if err != nil </span><span class="cov8" title="1">{
                        log.Printf("Invalid index: %v", err)
                        http.Error(w, "Invalid index", http.StatusBadRequest)
                        return
                }</span>
                <span class="cov8" title="1">prompts := h.DataStore.ReadPrompts()
                if index &gt;= 0 &amp;&amp; index &lt; len(prompts) </span><span class="cov8" title="1">{
                        funcMap := templates.FuncMap
                        profiles := h.DataStore.ReadProfiles()
                        err := h.Renderer.Render(w, "edit_prompt.html", funcMap, struct {
                                Index    int
                                Prompt   middleware.Prompt
                                Profiles []middleware.Profile
                        }{
                                Index:    index,
                                Prompt:   prompts[index],
                                Profiles: profiles,
                        }, "templates/edit_prompt.html")
                        if err != nil </span><span class="cov8" title="1">{
                                log.Printf("Error rendering template: %v", err)
                                http.Error(w, "Error rendering template", http.StatusInternalServerError)
                                return
                        }</span>
                }
        } else<span class="cov8" title="1"> if r.Method == "POST" </span><span class="cov8" title="1">{
                err := r.ParseForm()
                if err != nil </span><span class="cov8" title="1">{
                        log.Printf("Error parsing form: %v", err)
                        http.Error(w, "Error parsing form", http.StatusBadRequest)
                        return
                }</span>
                <span class="cov8" title="1">indexStr := r.Form.Get("index")
                index, err := strconv.Atoi(indexStr)
                if err != nil </span><span class="cov8" title="1">{
                        log.Printf("Invalid index: %v", err)
                        http.Error(w, "Invalid index", http.StatusBadRequest)
                        return
                }</span>
                <span class="cov8" title="1">editedPrompt := r.Form.Get("prompt")
                editedSolution := r.Form.Get("solution")
                editedProfile := r.Form.Get("profile")
                if editedPrompt == "" </span><span class="cov8" title="1">{
                        log.Println("Prompt text cannot be empty")
                        http.Error(w, "Prompt text cannot be empty", http.StatusBadRequest)
                        return
                }</span>
                <span class="cov8" title="1">prompts := h.DataStore.ReadPrompts()
                if index &gt;= 0 &amp;&amp; index &lt; len(prompts) </span><span class="cov8" title="1">{
                        prompts[index].Text = editedPrompt
                        prompts[index].Solution = editedSolution
                        prompts[index].Profile = editedProfile
                }</span>
                <span class="cov8" title="1">err = h.DataStore.WritePrompts(prompts)
                if err != nil </span><span class="cov8" title="1">{
                        log.Printf("Error writing prompts: %v", err)
                        http.Error(w, "Error writing prompts", http.StatusInternalServerError)
                        return
                }</span>
                <span class="cov8" title="1">log.Println("Prompt edited successfully")
                h.DataStore.BroadcastResults()
                http.Redirect(w, r, "/prompts", http.StatusSeeOther)</span>
        } else<span class="cov8" title="1"> {
                http.Error(w, "Method not allowed", http.StatusMethodNotAllowed)
        }</span>
}

// BulkDeletePromptsPage handles bulk delete prompts page
func (h *Handler) BulkDeletePromptsPage(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        log.Println("Handling bulk delete prompts page")
        if r.Method != "GET" </span><span class="cov8" title="1">{
                http.Error(w, "Method not allowed", http.StatusMethodNotAllowed)
                return
        }</span>

        <span class="cov8" title="1">indicesStr := r.URL.Query().Get("indices")
        if indicesStr == "" </span><span class="cov8" title="1">{
                log.Println("No indices provided for deletion")
                http.Error(w, "No indices provided for deletion", http.StatusBadRequest)
                return
        }</span>

        <span class="cov8" title="1">var indices []int
        err := json.Unmarshal([]byte(indicesStr), &amp;indices)
        if err != nil </span><span class="cov8" title="1">{
                log.Printf("Error unmarshalling indices: %v", err)
                http.Error(w, "Error unmarshalling indices", http.StatusBadRequest)
                return
        }</span>

        <span class="cov8" title="1">prompts := h.DataStore.ReadPrompts()
        var selectedPrompts []middleware.Prompt
        for _, index := range indices </span><span class="cov8" title="1">{
                if index &gt;= 0 &amp;&amp; index &lt; len(prompts) </span><span class="cov8" title="1">{
                        selectedPrompts = append(selectedPrompts, prompts[index])
                }</span>
        }

        <span class="cov8" title="1">funcMap := templates.FuncMap

        err = h.Renderer.Render(w, "bulk_delete_prompts.html", funcMap, struct {
                Indices string
                Prompts []middleware.Prompt
        }{
                Indices: indicesStr,
                Prompts: selectedPrompts,
        }, "templates/bulk_delete_prompts.html")
        if err != nil </span><span class="cov8" title="1">{
                log.Printf("Error rendering template: %v", err)
                http.Error(w, "Error rendering template", http.StatusInternalServerError)
                return
        }</span>
}

// BulkDeletePrompts handles bulk delete prompts
func (h *Handler) BulkDeletePrompts(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        log.Println("Handling bulk delete prompts")
        if r.Method != "POST" </span><span class="cov8" title="1">{
                http.Error(w, "Method not allowed", http.StatusMethodNotAllowed)
                return
        }</span>

        <span class="cov8" title="1">var request struct {
                Indices []int `json:"indices"`
        }

        err := json.NewDecoder(r.Body).Decode(&amp;request)
        if err != nil </span><span class="cov8" title="1">{
                log.Printf("Error decoding request: %v", err)
                http.Error(w, "Error decoding request", http.StatusBadRequest)
                return
        }</span>

        <span class="cov8" title="1">indices := request.Indices

        prompts := h.DataStore.ReadPrompts()
        if len(prompts) == 0 </span><span class="cov8" title="1">{
                log.Println("No prompts to delete")
                http.Error(w, "No prompts to delete", http.StatusBadRequest)
                return
        }</span>

        <span class="cov8" title="1">if len(indices) == 0 </span><span class="cov8" title="1">{
                log.Println("No indices provided for deletion")
                http.Error(w, "No indices provided for deletion", http.StatusBadRequest)
                return
        }</span>

        <span class="cov8" title="1">var filteredPrompts []middleware.Prompt
        for i, prompt := range prompts </span><span class="cov8" title="1">{
                found := false
                for _, index := range indices </span><span class="cov8" title="1">{
                        if i == index </span><span class="cov8" title="1">{
                                found = true
                                break</span>
                        }
                }
                <span class="cov8" title="1">if !found </span><span class="cov8" title="1">{
                        filteredPrompts = append(filteredPrompts, prompt)
                }</span>
        }

        <span class="cov8" title="1">err = h.DataStore.WritePrompts(filteredPrompts)
        if err != nil </span><span class="cov8" title="1">{
                log.Printf("Error writing prompts: %v", err)
                http.Error(w, "Error writing prompts", http.StatusInternalServerError)
                return
        }</span>

        <span class="cov8" title="1">log.Println("Prompts deleted successfully")
        h.DataStore.BroadcastResults()
        w.WriteHeader(http.StatusOK)</span>
}

// DeletePrompt handles deleting a prompt
func (h *Handler) DeletePrompt(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        log.Println("Handling delete prompt")
        if r.Method == "GET" </span><span class="cov8" title="1">{
                err := r.ParseForm()
                if err != nil </span><span class="cov8" title="1">{
                        log.Printf("Error parsing form: %v", err)
                        http.Error(w, "Error parsing form", http.StatusBadRequest)
                        return
                }</span>
                <span class="cov8" title="1">indexStr := r.Form.Get("index")
                index, err := strconv.Atoi(indexStr)
                if err != nil </span><span class="cov8" title="1">{
                        log.Printf("Invalid index: %v", err)
                        http.Error(w, "Invalid index", http.StatusBadRequest)
                        return
                }</span>
                <span class="cov8" title="1">prompts := h.DataStore.ReadPrompts()
                if index &gt;= 0 &amp;&amp; index &lt; len(prompts) </span><span class="cov8" title="1">{
                        funcMap := templates.FuncMap
                        err := h.Renderer.Render(w, "delete_prompt.html", funcMap, struct {
                                Index  int
                                Prompt middleware.Prompt
                        }{
                                Index:  index,
                                Prompt: prompts[index],
                        }, "templates/delete_prompt.html")
                        if err != nil </span><span class="cov8" title="1">{
                                log.Printf("Error rendering template: %v", err)
                                http.Error(w, "Error rendering template", http.StatusInternalServerError)
                                return
                        }</span>
                }
        } else<span class="cov8" title="1"> if r.Method == "POST" </span><span class="cov8" title="1">{
                err := r.ParseForm()
                if err != nil </span><span class="cov8" title="1">{
                        log.Printf("Error parsing form: %v", err)
                        http.Error(w, "Error parsing form", http.StatusBadRequest)
                        return
                }</span>
                <span class="cov8" title="1">indexStr := r.Form.Get("index")
                index, err := strconv.Atoi(indexStr)
                if err != nil </span><span class="cov8" title="1">{
                        log.Printf("Invalid index: %v", err)
                        http.Error(w, "Invalid index", http.StatusBadRequest)
                        return
                }</span>
                <span class="cov8" title="1">prompts := h.DataStore.ReadPrompts()
                if index &gt;= 0 &amp;&amp; index &lt; len(prompts) </span><span class="cov8" title="1">{
                        prompts = append(prompts[:index], prompts[index+1:]...)
                }</span>
                <span class="cov8" title="1">err = h.DataStore.WritePrompts(prompts)
                if err != nil </span><span class="cov8" title="1">{
                        log.Printf("Error writing prompts: %v", err)
                        http.Error(w, "Error writing prompts", http.StatusInternalServerError)
                        return
                }</span>
                <span class="cov8" title="1">log.Println("Prompt deleted successfully")
                h.DataStore.BroadcastResults()
                http.Redirect(w, r, "/prompts", http.StatusSeeOther)</span>
        } else<span class="cov8" title="1"> {
                http.Error(w, "Method not allowed", http.StatusMethodNotAllowed)
        }</span>
}

// MovePrompt handles moving a prompt
func (h *Handler) MovePrompt(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        log.Println("Handling move prompt")
        if r.Method == "GET" </span><span class="cov8" title="1">{
                err := r.ParseForm()
                if err != nil </span><span class="cov8" title="1">{
                        log.Printf("Error parsing form: %v", err)
                        http.Error(w, "Error parsing form", http.StatusBadRequest)
                        return
                }</span>
                <span class="cov8" title="1">indexStr := r.Form.Get("index")
                index, err := strconv.Atoi(indexStr)
                if err != nil </span><span class="cov8" title="1">{
                        log.Printf("Invalid index: %v", err)
                        http.Error(w, "Invalid index", http.StatusBadRequest)
                        return
                }</span>
                <span class="cov8" title="1">prompts := h.DataStore.ReadPrompts()
                if index &gt;= 0 &amp;&amp; index &lt; len(prompts) </span><span class="cov8" title="1">{
                        funcMap := templates.FuncMap
                        err := h.Renderer.Render(w, "move_prompt.html", funcMap, struct {
                                Index   int
                                Prompt  string
                                Prompts []middleware.Prompt
                        }{
                                Index:   index,
                                Prompt:  prompts[index].Text,
                                Prompts: prompts,
                        }, "templates/move_prompt.html")
                        if err != nil </span><span class="cov8" title="1">{
                                log.Printf("Error rendering template: %v", err)
                                http.Error(w, "Error rendering template", http.StatusInternalServerError)
                                return
                        }</span>
                }
        } else<span class="cov8" title="1"> if r.Method == "POST" </span><span class="cov8" title="1">{
                err := r.ParseForm()
                if err != nil </span><span class="cov8" title="1">{
                        log.Printf("Error parsing form: %v", err)
                        http.Error(w, "Error parsing form", http.StatusBadRequest)
                        return
                }</span>
                <span class="cov8" title="1">indexStr := r.Form.Get("index")
                index, err := strconv.Atoi(indexStr)
                if err != nil </span><span class="cov8" title="1">{
                        log.Printf("Invalid index: %v", err)
                        http.Error(w, "Invalid index", http.StatusBadRequest)
                        return
                }</span>
                <span class="cov8" title="1">newIndexStr := r.Form.Get("new_index")
                newIndex, err := strconv.Atoi(newIndexStr)
                if err != nil </span><span class="cov8" title="1">{
                        log.Printf("Invalid new index: %v", err)
                        http.Error(w, "Invalid new index", http.StatusBadRequest)
                        return
                }</span>
                <span class="cov8" title="1">prompts := h.DataStore.ReadPrompts()
                if index &gt;= 0 &amp;&amp; index &lt; len(prompts) &amp;&amp; newIndex &gt;= 0 &amp;&amp; newIndex &lt;= len(prompts) </span><span class="cov8" title="1">{
                        prompt := prompts[index]
                        prompts = append(prompts[:index], prompts[index+1:]...)
                        if newIndex &gt; index </span><span class="cov8" title="1">{
                                newIndex--
                        }</span>
                        <span class="cov8" title="1">prompts = append(prompts[:newIndex], append([]middleware.Prompt{prompt}, prompts[newIndex:]...)...)</span>
                }
                <span class="cov8" title="1">err = h.DataStore.WritePrompts(prompts)
                if err != nil </span><span class="cov8" title="1">{
                        log.Printf("Error writing prompts: %v", err)
                        http.Error(w, "Error writing prompts", http.StatusInternalServerError)
                        return
                }</span>
                <span class="cov8" title="1">log.Println("Prompt moved successfully")
                h.DataStore.BroadcastResults()
                http.Redirect(w, r, "/prompts", http.StatusSeeOther)</span>
        } else<span class="cov8" title="1"> {
                http.Error(w, "Method not allowed", http.StatusMethodNotAllowed)
        }</span>
}

// ResetPrompts handles resetting prompts
func (h *Handler) ResetPrompts(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        log.Println("Handling reset prompts")
        if r.Method == "GET" </span><span class="cov8" title="1">{
                if err := h.Renderer.RenderTemplateSimple(w, "reset_prompts.html", nil); err != nil </span><span class="cov8" title="1">{
                        log.Printf("Error rendering template: %v", err)
                        http.Error(w, "Error rendering template", http.StatusInternalServerError)
                }</span>
        } else<span class="cov8" title="1"> if r.Method == "POST" </span><span class="cov8" title="1">{
                err := h.DataStore.WritePrompts([]middleware.Prompt{})
                if err != nil </span><span class="cov8" title="1">{
                        log.Printf("Error writing prompts: %v", err)
                        http.Error(w, "Error writing prompts", http.StatusInternalServerError)
                        return
                }</span>
                <span class="cov8" title="1">log.Println("Prompts reset successfully")
                h.DataStore.BroadcastResults()
                http.Redirect(w, r, "/prompts", http.StatusSeeOther)</span>
        } else<span class="cov8" title="1"> {
                http.Error(w, "Method not allowed", http.StatusMethodNotAllowed)
        }</span>
}
</pre>
		
		<pre class="file" id="file10" style="display: none">package handlers

import (
        "encoding/json"
        "io"
        "log"
        "math/rand"
        "net/http"
        "sort"
        "strconv"
        "strings"
        "time"

        "llm-tournament/middleware"
        "llm-tournament/templates"
)

// min returns the smaller of x or y
func min(x, y int) int <span class="cov8" title="1">{
        if x &lt; y </span><span class="cov8" title="1">{
                return x
        }</span>
        <span class="cov8" title="1">return y</span>
}

// max returns the larger of x or y
func max(x, y int) int <span class="cov8" title="1">{
        if x &gt; y </span><span class="cov8" title="1">{
                return x
        }</span>
        <span class="cov8" title="1">return y</span>
}

// initRand returns a new random number generator seeded with the current time
func initRand() *rand.Rand <span class="cov8" title="1">{
        source := rand.NewSource(time.Now().UnixNano())
        return rand.New(source)
}</span>

// GroupedPrompt represents a prompt with its profile information
type GroupedPrompt struct {
        Index       int
        Text        string
        ProfileID   string
        ProfileName string
}

// ResultsHandler handles the results page (backward compatible wrapper)
func ResultsHandler(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        DefaultHandler.Results(w, r)
}</span>

// UpdateResultHandler handles updating results (backward compatible wrapper)
func UpdateResultHandler(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        DefaultHandler.UpdateResult(w, r)
}</span>

// ResetResultsHandler handles resetting results (backward compatible wrapper)
func ResetResultsHandler(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        DefaultHandler.ResetResults(w, r)
}</span>

// ConfirmRefreshResultsHandler handles confirm refresh results (backward compatible wrapper)
func ConfirmRefreshResultsHandler(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        DefaultHandler.ConfirmRefreshResults(w, r)
}</span>

// RefreshResultsHandler handles refresh results (backward compatible wrapper)
func RefreshResultsHandler(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        DefaultHandler.RefreshResults(w, r)
}</span>

// EvaluateResult handles evaluating individual results (backward compatible wrapper)
func EvaluateResult(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        DefaultHandler.EvaluateResultHandler(w, r)
}</span>

// ExportResultsHandler handles exporting results (backward compatible wrapper)
func ExportResultsHandler(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        DefaultHandler.ExportResults(w, r)
}</span>

// UpdateMockResultsHandler handles updating mock results (backward compatible wrapper)
func UpdateMockResultsHandler(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        DefaultHandler.UpdateMockResults(w, r)
}</span>

// Results handles the results page
func (h *Handler) Results(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        log.Println("Handling results page")
        prompts := h.DataStore.ReadPrompts()
        results := h.DataStore.ReadResults()

        // Group prompts by profile
        var orderedPrompts []GroupedPrompt

        // Get all profiles first (to include empty ones)
        profiles := h.DataStore.ReadProfiles()

        // Get profile groups using the utility function
        profileGroups, profileMap := middleware.GetProfileGroups(prompts, profiles)

        // Check if we have any uncategorized prompts
        hasUncategorized := false
        for _, prompt := range prompts </span><span class="cov8" title="1">{
                if prompt.Profile == "" </span><span class="cov8" title="1">{
                        hasUncategorized = true
                        break</span>
                }
        }

        // Add a group for prompts with no profile only if needed
        <span class="cov8" title="1">if hasUncategorized </span><span class="cov8" title="1">{
                noProfileGroup := &amp;middleware.ProfileGroup{
                        ID:       "none",
                        Name:     "Uncategorized",
                        Color:    "hsl(0, 0%, 50%)",
                        StartCol: -1,
                        EndCol:   -1,
                }
                profileGroups = append(profileGroups, noProfileGroup)
                profileMap[""] = noProfileGroup
        }</span>

        // Process prompts and assign them to profile groups
        <span class="cov8" title="1">currentCol := 0
        for i, prompt := range prompts </span><span class="cov8" title="1">{
                profileName := prompt.Profile

                group := profileMap[profileName]

                if group.StartCol == -1 </span><span class="cov8" title="1">{
                        group.StartCol = currentCol
                }</span>
                <span class="cov8" title="1">group.EndCol = currentCol

                orderedPrompts = append(orderedPrompts, GroupedPrompt{
                        Index:       i,
                        Text:        prompt.Text,
                        ProfileID:   group.ID,
                        ProfileName: profileName,
                })

                currentCol++</span>
        }

        <span class="cov8" title="1">log.Println("Calculating total scores for each model")
        // Calculate total scores for each model
        modelScores := make(map[string]int)
        for model, result := range results </span><span class="cov8" title="1">{
                totalScore := 0
                for _, score := range result.Scores </span><span class="cov8" title="1">{
                        totalScore += score
                }</span>
                <span class="cov8" title="1">modelScores[model] = totalScore</span>
        }

        <span class="cov8" title="1">log.Println("Sorting models by score in descending order")
        // Sort models by score in descending order
        models := make([]string, 0, len(results))
        for model := range results </span><span class="cov8" title="1">{
                models = append(models, model)
        }</span>
        <span class="cov8" title="1">if len(models) == 0 </span><span class="cov8" title="1">{
                // If no results exist, get models from somewhere else if needed
                // This is just a fallback - you may need to adjust based on your data source
                models = []string{"Model1", "Model2"} // Example fallback
        }</span>
        <span class="cov8" title="1">sort.Slice(models, func(i, j int) bool </span><span class="cov8" title="1">{
                return modelScores[models[i]] &gt; modelScores[models[j]]
        }</span>)
        <span class="cov8" title="1">log.Printf("Sorted models: %v", models)

        modelFilter := r.FormValue("model_filter")
        searchQuery := strings.ToLower(r.FormValue("search"))

        filteredResults := make(map[string]middleware.Result)
        for model, result := range results </span><span class="cov8" title="1">{
                // Apply model filter if specified
                if modelFilter != "" &amp;&amp; model != modelFilter </span><span class="cov8" title="1">{
                        continue</span>
                }
                // Apply search filter if specified
                <span class="cov8" title="1">if searchQuery != "" &amp;&amp; !strings.Contains(strings.ToLower(model), searchQuery) </span><span class="cov8" title="1">{
                        continue</span>
                }
                <span class="cov8" title="1">filteredResults[model] = result</span>
        }

        <span class="cov8" title="1">pageName := templates.PageNameResults
        promptTexts := make([]string, len(prompts))
        for i, prompt := range prompts </span><span class="cov8" title="1">{
                promptTexts[i] = prompt.Text
        }</span>
        <span class="cov8" title="1">resultsForTemplate := make(map[string]middleware.Result)
        for model, result := range filteredResults </span><span class="cov8" title="1">{
                // Initialize scores array if nil
                if result.Scores == nil </span><span class="cov8" title="1">{
                        result.Scores = make([]int, len(prompts))
                }</span>

                // Ensure scores array matches prompts length
                <span class="cov8" title="1">if len(result.Scores) != len(prompts) </span><span class="cov8" title="1">{
                        newScores := make([]int, len(prompts))
                        copy(newScores, result.Scores)
                        result.Scores = newScores
                }</span>

                // Ensure all scores are valid (0-100)
                <span class="cov8" title="1">for i, score := range result.Scores </span><span class="cov8" title="1">{
                        if score &lt; 0 || score &gt; 100 </span><span class="cov8" title="1">{
                                result.Scores[i] = 0
                        }</span>
                }

                // Create a new Result struct to ensure proper initialization
                <span class="cov8" title="1">resultsForTemplate[model] = middleware.Result{
                        Scores: result.Scores,
                }</span>
        }
        <span class="cov8" title="1">modelPassPercentages := make(map[string]float64)
        modelTotalScores := make(map[string]int)
        promptIndices := make([]int, len(prompts))
        for i := range prompts </span><span class="cov8" title="1">{
                promptIndices[i] = i + 1
        }</span>
        <span class="cov8" title="1">for model, result := range filteredResults </span><span class="cov8" title="1">{
                totalScore := 0
                for _, score := range result.Scores </span><span class="cov8" title="1">{
                        totalScore += score
                }</span>
                <span class="cov8" title="1">modelPassPercentages[model] = float64(totalScore) / float64(len(prompts)*100) * 100
                modelTotalScores[model] = totalScore</span>
        }

        // Log the data we're about to send to the template for debugging
        <span class="cov8" title="1">if len(models) &gt; 0 &amp;&amp; len(promptTexts) &gt; 0 </span><span class="cov8" title="1">{
                log.Printf("First model: %s, scores: %v", models[0], resultsForTemplate[models[0]].Scores)
        }</span>

        <span class="cov8" title="1">templateData := struct {
                PageName        string
                Prompts         []string
                Results         map[string]middleware.Result
                Models          []string
                PassPercentages map[string]float64
                ModelFilter     string
                TotalScores     map[string]int
                PromptIndices   []int
                SearchQuery     string
                ProfileGroups   []*middleware.ProfileGroup
                OrderedPrompts  []GroupedPrompt
        }{
                PageName:        pageName,
                Prompts:         promptTexts,
                Results:         resultsForTemplate,
                Models:          models,
                PassPercentages: modelPassPercentages,
                ModelFilter:     modelFilter,
                TotalScores:     modelTotalScores,
                PromptIndices:   promptIndices,
                SearchQuery:     searchQuery,
                ProfileGroups:   profileGroups,
                OrderedPrompts:  orderedPrompts,
        }

        err := h.Renderer.Render(w, "results.html", templates.FuncMap, templateData, "templates/results.html", "templates/nav.html")
        if err != nil </span><span class="cov8" title="1">{
                log.Printf("Error rendering template: %v", err)
                http.Error(w, "Error rendering template", http.StatusInternalServerError)
                return
        }</span>
        <span class="cov8" title="1">log.Println("Results page rendered successfully")</span>
}

// UpdateResult handles AJAX requests to update results
func (h *Handler) UpdateResult(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        log.Println("Handling update result")
        r.ParseForm()
        model := r.Form.Get("model")
        promptIndexStr := r.Form.Get("promptIndex")
        passStr := r.Form.Get("pass")
        promptIndex, _ := strconv.Atoi(promptIndexStr)
        pass, err := strconv.ParseBool(passStr)
        if err != nil </span><span class="cov8" title="1">{
                log.Printf("Invalid pass value: %v", err)
                http.Error(w, "Invalid pass value", http.StatusBadRequest)
                return
        }</span>

        <span class="cov8" title="1">suiteName := h.DataStore.GetCurrentSuiteName()
        results := h.DataStore.ReadResults()
        if results == nil </span><span class="cov8" title="1">{
                results = make(map[string]middleware.Result)
        }</span>
        <span class="cov8" title="1">if _, ok := results[model]; !ok </span><span class="cov8" title="1">{
                results[model] = middleware.Result{
                        Scores: make([]int, len(h.DataStore.ReadPrompts())),
                }
        }</span>

        <span class="cov8" title="1">prompts := h.DataStore.ReadPrompts()
        result := results[model]
        if len(result.Scores) &lt; len(prompts) </span><span class="cov8" title="1">{
                result.Scores = append(result.Scores, make([]int, len(prompts)-len(result.Scores))...)
        }</span>
        <span class="cov8" title="1">if promptIndex &gt;= 0 &amp;&amp; promptIndex &lt; len(result.Scores) </span><span class="cov8" title="1">{
                if pass </span><span class="cov8" title="1">{
                        result.Scores[promptIndex] = 100
                }</span> else<span class="cov8" title="1"> {
                        result.Scores[promptIndex] = 0
                }</span>
        }
        <span class="cov8" title="1">results[model] = result
        err = h.DataStore.WriteResults(suiteName, results)
        if err != nil </span><span class="cov8" title="1">{
                log.Printf("Error writing results: %v", err)
                http.Error(w, "Error writing results", http.StatusInternalServerError)
                return
        }</span>

        <span class="cov8" title="1">h.DataStore.BroadcastResults()

        _, err = w.Write([]byte("OK"))
        if err != nil </span><span class="cov8" title="1">{
                log.Printf("Error writing response: %v", err)
                http.Error(w, "Error writing response", http.StatusInternalServerError)
                return
        }</span>
        <span class="cov8" title="1">log.Println("protocols.Result updated successfully")</span>
}

// ResetResults handles resetting results
func (h *Handler) ResetResults(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        log.Println("Handling reset results")
        if r.Method == "GET" </span><span class="cov8" title="1">{
                if err := h.Renderer.RenderTemplateSimple(w, "reset_results.html", nil); err != nil </span><span class="cov8" title="1">{
                        log.Printf("Error rendering template: %v", err)
                        http.Error(w, "Error rendering template", http.StatusInternalServerError)
                }</span>
        } else<span class="cov8" title="1"> if r.Method == "POST" </span><span class="cov8" title="1">{
                emptyResults := make(map[string]middleware.Result)
                suiteName := h.DataStore.GetCurrentSuiteName()
                err := h.DataStore.WriteResults(suiteName, emptyResults)
                if err != nil </span><span class="cov8" title="1">{
                        log.Printf("Error writing results: %v", err)
                        http.Error(w, "Error writing results", http.StatusInternalServerError)
                        return
                }</span>
                <span class="cov8" title="1">log.Println("Results reset successfully")
                h.DataStore.BroadcastResults()
                http.Redirect(w, r, "/results", http.StatusSeeOther)</span>
        }
}

// ConfirmRefreshResults handles confirm refresh results
func (h *Handler) ConfirmRefreshResults(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        log.Println("Handling confirm refresh results")
        if r.Method == "GET" </span><span class="cov8" title="1">{
                if err := h.Renderer.RenderTemplateSimple(w, "confirm_refresh_results.html", nil); err != nil </span><span class="cov8" title="1">{
                        log.Printf("Error rendering template: %v", err)
                        http.Error(w, "Error rendering template", http.StatusInternalServerError)
                }</span>
        } else<span class="cov8" title="1"> if r.Method == "POST" </span><span class="cov8" title="1">{
                results := h.DataStore.ReadResults()
                for model := range results </span><span class="cov8" title="1">{
                        results[model] = middleware.Result{
                                Scores: make([]int, len(h.DataStore.ReadPrompts())),
                        }
                }</span>
                <span class="cov8" title="1">suiteName := h.DataStore.GetCurrentSuiteName()
                err := h.DataStore.WriteResults(suiteName, results)
                if err != nil </span><span class="cov8" title="1">{
                        log.Printf("Error writing results: %v", err)
                        http.Error(w, "Error writing results", http.StatusInternalServerError)
                        return
                }</span>
                <span class="cov8" title="1">log.Println("Results refreshed successfully")
                h.DataStore.BroadcastResults()
                http.Redirect(w, r, "/results", http.StatusSeeOther)</span>
        }
}

// RefreshResults handles refresh results
func (h *Handler) RefreshResults(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        log.Println("Handling refresh results")
        if r.Method == "GET" </span><span class="cov8" title="1">{
                if err := h.Renderer.RenderTemplateSimple(w, "confirm_refresh_results.html", nil); err != nil </span><span class="cov8" title="1">{
                        log.Printf("Error rendering template: %v", err)
                        http.Error(w, "Error rendering template", http.StatusInternalServerError)
                }</span>
        } else<span class="cov8" title="1"> if r.Method == "POST" </span><span class="cov8" title="1">{
                results := h.DataStore.ReadResults()
                for model := range results </span><span class="cov8" title="1">{
                        results[model] = middleware.Result{Scores: make([]int, len(h.DataStore.ReadPrompts()))}
                }</span>
                <span class="cov8" title="1">suiteName := h.DataStore.GetCurrentSuiteName()
                err := h.DataStore.WriteResults(suiteName, results)
                if err != nil </span><span class="cov8" title="1">{
                        log.Printf("Error writing results: %v", err)
                        http.Error(w, "Error writing results", http.StatusInternalServerError)
                        return
                }</span>
                <span class="cov8" title="1">log.Println("Results refreshed successfully")
                h.DataStore.BroadcastResults()
                http.Redirect(w, r, "/results", http.StatusSeeOther)</span>
        }
}

// EvaluateResultHandler handles evaluation of individual results
func (h *Handler) EvaluateResultHandler(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        model := r.URL.Query().Get("model")
        promptIndexStr := r.URL.Query().Get("prompt")

        if r.Method == "POST" </span><span class="cov8" title="1">{
                scoreStr := r.FormValue("score")
                score, err := strconv.Atoi(scoreStr)
                if err != nil </span><span class="cov8" title="1">{
                        http.Error(w, "Invalid score value", http.StatusBadRequest)
                        return
                }</span>

                <span class="cov8" title="1">results := h.DataStore.ReadResults()
                if results == nil </span><span class="cov8" title="1">{
                        results = make(map[string]middleware.Result)
                }</span>

                <span class="cov8" title="1">result, exists := results[model]
                if !exists </span><span class="cov8" title="1">{
                        // Initialize new result with scores array matching prompts length
                        prompts := h.DataStore.ReadPrompts()
                        result = middleware.Result{
                                Scores: make([]int, len(prompts)),
                        }
                }</span>

                <span class="cov8" title="1">index, err := strconv.Atoi(promptIndexStr)
                if err != nil || index &lt; 0 || index &gt;= len(result.Scores) </span><span class="cov8" title="1">{
                        http.Error(w, "Invalid prompt index", http.StatusBadRequest)
                        return
                }</span>

                // Update the score (ensure it's within 0-100 range)
                <span class="cov8" title="1">if score &lt; 0 </span><span class="cov8" title="1">{
                        score = 0
                }</span> else<span class="cov8" title="1"> if score &gt; 100 </span><span class="cov8" title="1">{
                        score = 100
                }</span>
                <span class="cov8" title="1">result.Scores[index] = score
                results[model] = result

                // Write updated results
                err = h.DataStore.WriteResults(h.DataStore.GetCurrentSuiteName(), results)
                if err != nil </span><span class="cov8" title="1">{
                        http.Error(w, "Failed to save results", http.StatusInternalServerError)
                        return
                }</span>

                // Broadcast updated results to all clients
                <span class="cov8" title="1">h.DataStore.BroadcastResults()

                // Add debug logging
                log.Printf("Updated score for model %s, prompt %d: %d", model, index, score)
                log.Printf("Current results for model %s: %v", model, result.Scores)

                // Redirect back to results page
                http.Redirect(w, r, "/results", http.StatusSeeOther)
                return</span>
        }

        // Get current score for this model/prompt
        <span class="cov8" title="1">results := h.DataStore.ReadResults()
        currentScore := 0
        if result, exists := results[model]; exists </span><span class="cov8" title="1">{
                if index, err := strconv.Atoi(promptIndexStr); err == nil &amp;&amp; index &lt; len(result.Scores) </span><span class="cov8" title="1">{
                        currentScore = result.Scores[index]
                }</span>
        }

        // Get the prompt text and solution for display
        <span class="cov8" title="1">prompts := h.DataStore.ReadPrompts()
        var promptText, solution string
        promptIndex, err := strconv.Atoi(promptIndexStr)
        if err == nil &amp;&amp; promptIndex &gt;= 0 &amp;&amp; promptIndex &lt; len(prompts) </span><span class="cov8" title="1">{
                promptText = prompts[promptIndex].Text
                solution = prompts[promptIndex].Solution
        }</span>

        <span class="cov8" title="1">data := struct {
                PageName     string
                Model        string
                PromptIndex  string
                ScoreOptions map[string]int
                CurrentScore int
                PromptText   string
                Solution     string
                TotalPrompts int
        }{
                PageName:     templates.PageNameEvaluate,
                Model:        model,
                PromptIndex:  promptIndexStr,
                ScoreOptions: templates.ScoreOptions,
                CurrentScore: currentScore,
                PromptText:   promptText,
                Solution:     solution,
                TotalPrompts: len(prompts),
        }

        err = h.Renderer.Render(w, "evaluate.html", templates.FuncMap, data, "templates/evaluate.html", "templates/nav.html")
        if err != nil </span><span class="cov8" title="1">{
                log.Printf("Error rendering template: %v", err)
                http.Error(w, "Error rendering template", http.StatusInternalServerError)
                return
        }</span>
}

// ExportResults handles export results
func (h *Handler) ExportResults(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        log.Println("Handling export results")
        results := h.DataStore.ReadResults()

        // Convert results to JSON
        jsonData, _ := json.MarshalIndent(results, "", "  ")

        // Set headers for JSON download
        w.Header().Set("Content-Type", "application/json")
        w.Header().Set("Content-Disposition", "attachment;filename=results.json")

        // Write JSON to response
        _, err := w.Write(jsonData)
        if err != nil </span><span class="cov8" title="1">{
                log.Printf("Error writing response: %v", err)
                http.Error(w, "Error writing response", http.StatusInternalServerError)
                return
        }</span>
        <span class="cov8" title="1">log.Println("Results exported successfully as JSON")</span>
}

// UpdateMockResults handles updating results with randomly generated mock data
// that ensures even distribution across all tier levels
func (h *Handler) UpdateMockResults(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        log.Println("Handling update mock results")

        if r.Method != "POST" </span><span class="cov8" title="1">{
                http.Error(w, "Method not allowed", http.StatusMethodNotAllowed)
                return
        }</span>

        // Parse the JSON request body
        <span class="cov8" title="1">var mockData struct {
                Results         map[string]middleware.Result `json:"results"`
                Models          []string                     `json:"models"`
                PassPercentages map[string]float64           `json:"passPercentages"`
                TotalScores     map[string]int               `json:"totalScores"`
        }

        log.Println("Received mock data request")

        body, err := io.ReadAll(r.Body)
        if err != nil </span><span class="cov8" title="1">{
                log.Printf("Error reading request body: %v", err)
                http.Error(w, "Error reading request body", http.StatusBadRequest)
                return
        }</span>

        <span class="cov8" title="1">err = json.Unmarshal(body, &amp;mockData)
        if err != nil </span><span class="cov8" title="1">{
                log.Printf("Error decoding mock data: %v", err)
                http.Error(w, "Invalid JSON data", http.StatusBadRequest)
                return
        }</span>

        // Use client-provided scores instead of generating new ones
        <span class="cov8" title="1">log.Println("Using client-provided scores for mock data")

        prompts := h.DataStore.ReadPrompts()

        // Get all model names
        models := mockData.Models
        if len(models) == 0 </span><span class="cov8" title="1">{
                // If no models passed, use models from existing results
                for model := range mockData.Results </span><span class="cov8" title="1">{
                        models = append(models, model)
                }</span>
        }

        // Use the client's results directly
        <span class="cov8" title="1">results := mockData.Results

        // Validate that all scores are legitimate values: 0, 20, 40, 60, 80, 100
        for model, result := range results </span><span class="cov8" title="1">{
                for i, score := range result.Scores </span><span class="cov8" title="1">{
                        // Only allow valid score values
                        switch score </span>{
                        case 0, 20, 40, 60, 80, 100:<span class="cov8" title="1"></span>
                                // Valid score, keep it
                        default:<span class="cov8" title="1">
                                // Invalid score, set to 0
                                log.Printf("Correcting invalid score %d for model %s prompt %d", score, model, i)
                                result.Scores[i] = 0</span>
                        }
                }
                <span class="cov8" title="1">results[model] = result</span>
        }

        // Skip the evenly distributed tier generation since we're using client scores

        // Save the evenly distributed mock results
        <span class="cov8" title="1">suiteName := h.DataStore.GetCurrentSuiteName()
        err = h.DataStore.WriteResults(suiteName, results)
        if err != nil </span><span class="cov8" title="1">{
                log.Printf("Error writing mock results: %v", err)
                http.Error(w, "Error saving mock results", http.StatusInternalServerError)
                return
        }</span>

        // Broadcast the updated results to all connected clients
        <span class="cov8" title="1">h.DataStore.BroadcastResults()

        // Calculate totalScores and passPercentages for the response
        totalScores := make(map[string]int)
        passPercentages := make(map[string]float64)

        log.Println("Calculating total scores for each model:")
        for model, result := range results </span><span class="cov8" title="1">{
                totalScore := 0
                for _, score := range result.Scores </span><span class="cov8" title="1">{
                        totalScore += score
                }</span>
                <span class="cov8" title="1">totalScores[model] = totalScore
                passPercentages[model] = float64(totalScore) / float64(len(prompts)*100) * 100

                log.Printf("Model %s: total score = %d, pass percentage = %.2f%%",
                        model, totalScore, passPercentages[model])</span>
        }

        // Sort models by total score in descending order
        <span class="cov8" title="1">sort.Slice(models, func(i, j int) bool </span><span class="cov8" title="1">{
                return totalScores[models[i]] &gt; totalScores[models[j]]
        }</span>)

        <span class="cov8" title="1">log.Printf("Sorted models after mock generation: %v", models[:min(5, len(models))])

        // Return success response with the generated data
        w.Header().Set("Content-Type", "application/json")
        response := map[string]interface{}{
                "status":          "success",
                "results":         results,
                "models":          models, // Now sorted by score
                "totalScores":     totalScores,
                "passPercentages": passPercentages,
        }

        err = json.NewEncoder(w).Encode(response)
        if err != nil </span><span class="cov8" title="1">{
                log.Printf("Error encoding response: %v", err)
        }</span>

        <span class="cov8" title="1">log.Println("Mock results with even tier distribution updated successfully")</span>
}
</pre>
		
		<pre class="file" id="file11" style="display: none">package handlers

import (
        "llm-tournament/middleware"
        "log"
        "net/http"
        "strconv"
)

// SettingsHandler displays the settings page (backward compatible wrapper)
func SettingsHandler(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        DefaultHandler.Settings(w, r)
}</span>

// UpdateSettingsHandler updates settings from form submission (backward compatible wrapper)
func UpdateSettingsHandler(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        DefaultHandler.UpdateSettings(w, r)
}</span>

// TestAPIKeyHandler tests an API key (backward compatible wrapper)
func TestAPIKeyHandler(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        DefaultHandler.TestAPIKey(w, r)
}</span>

// Settings displays the settings page
func (h *Handler) Settings(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        log.Println("Handling settings page")

        // Get masked API keys for display
        maskedKeys, err := h.DataStore.GetMaskedAPIKeys()
        if err != nil </span><span class="cov8" title="1">{
                log.Printf("Error getting masked API keys: %v", err)
                http.Error(w, "Failed to load settings", http.StatusInternalServerError)
                return
        }</span>

        // Get other settings
        <span class="cov8" title="1">threshold, _ := h.DataStore.GetSetting("cost_alert_threshold_usd")
        autoEval, _ := h.DataStore.GetSetting("auto_evaluate_new_models")
        pythonURL, _ := h.DataStore.GetSetting("python_service_url")

        // Parse threshold as float
        thresholdFloat, _ := strconv.ParseFloat(threshold, 64)
        if thresholdFloat == 0 </span><span class="cov8" title="1">{
                thresholdFloat = 100.0
        }</span>

        <span class="cov8" title="1">data := struct {
                PageName      string
                MaskedAPIKeys map[string]string
                Threshold     float64
                AutoEvaluate  bool
                PythonURL     string
        }{
                PageName:      "Settings",
                MaskedAPIKeys: maskedKeys,
                Threshold:     thresholdFloat,
                AutoEvaluate:  autoEval == "true",
                PythonURL:     pythonURL,
        }

        middleware.RenderTemplate(w, "settings.html", data)</span>
}

// UpdateSettings updates settings from form submission
func (h *Handler) UpdateSettings(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        if r.Method != http.MethodPost </span><span class="cov8" title="1">{
                http.Error(w, "Method not allowed", http.StatusMethodNotAllowed)
                return
        }</span>

        <span class="cov8" title="1">log.Println("Updating settings")

        // Parse form
        if err := r.ParseForm(); err != nil </span><span class="cov8" title="1">{
                log.Printf("Error parsing form: %v", err)
                http.Error(w, "Failed to parse form", http.StatusBadRequest)
                return
        }</span>

        // Update API keys (only if not empty)
        <span class="cov8" title="1">apiKeys := map[string]string{
                "anthropic": r.FormValue("api_key_anthropic"),
                "openai":    r.FormValue("api_key_openai"),
                "google":    r.FormValue("api_key_google"),
        }

        for provider, key := range apiKeys </span><span class="cov8" title="1">{
                if key != "" &amp;&amp; key != "********" </span><span class="cov8" title="1">{ // Don't update if placeholder
                        if err := h.DataStore.SetAPIKey(provider, key); err != nil </span><span class="cov8" title="1">{
                                log.Printf("Error setting API key for %s: %v", provider, err)
                                http.Error(w, "Failed to save API key", http.StatusInternalServerError)
                                return
                        }</span>
                }
        }

        // Update other settings
        <span class="cov8" title="1">threshold := r.FormValue("cost_alert_threshold_usd")
        if threshold != "" </span><span class="cov8" title="1">{
                if err := h.DataStore.SetSetting("cost_alert_threshold_usd", threshold); err != nil </span><span class="cov8" title="1">{
                        log.Printf("Error setting threshold: %v", err)
                }</span>
        }

        <span class="cov8" title="1">autoEval := r.FormValue("auto_evaluate_new_models")
        autoEvalValue := "false"
        if autoEval == "on" </span><span class="cov8" title="1">{
                autoEvalValue = "true"
        }</span>
        <span class="cov8" title="1">if err := h.DataStore.SetSetting("auto_evaluate_new_models", autoEvalValue); err != nil </span><span class="cov8" title="1">{
                log.Printf("Error setting auto_evaluate: %v", err)
        }</span>

        <span class="cov8" title="1">pythonURL := r.FormValue("python_service_url")
        if pythonURL != "" </span><span class="cov8" title="1">{
                if err := h.DataStore.SetSetting("python_service_url", pythonURL); err != nil </span><span class="cov8" title="1">{
                        log.Printf("Error setting Python URL: %v", err)
                }</span>
        }

        <span class="cov8" title="1">log.Println("Settings updated successfully")

        // Redirect back to settings page
        http.Redirect(w, r, "/settings", http.StatusSeeOther)</span>
}

// TestAPIKey tests an API key by making a health check to Python service
func (h *Handler) TestAPIKey(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        if r.Method != http.MethodPost </span><span class="cov8" title="1">{
                http.Error(w, "Method not allowed", http.StatusMethodNotAllowed)
                return
        }</span>

        <span class="cov8" title="1">provider := r.FormValue("provider")
        if provider == "" </span><span class="cov8" title="1">{
                http.Error(w, "Provider required", http.StatusBadRequest)
                return
        }</span>

        // Get API key
        <span class="cov8" title="1">apiKey, err := h.DataStore.GetAPIKey(provider)
        if err != nil || apiKey == "" </span><span class="cov8" title="1">{
                middleware.RespondJSON(w, map[string]interface{}{
                        "success": false,
                        "message": "API key not configured",
                })
                return
        }</span>

        // TODO: Make actual test call to respective API
        // For now, just return success
        <span class="cov8" title="1">middleware.RespondJSON(w, map[string]interface{}{
                "success": true,
                "message": "API key appears valid (test not fully implemented)",
        })</span>
}
</pre>
		
		<pre class="file" id="file12" style="display: none">package handlers

import (
        "encoding/json"
        "html/template"
        "log"
        "net/http"
        "strings"
)

// Calculate tiers based on total scores
func calculateTiers(totalScores map[string]int) (map[string][]string, map[string]string) <span class="cov8" title="1">{
        tiers := map[string][]string{
                "transcendental": {},
                "cosmic":         {},
                "divine":         {},
                "celestial":      {},
                "ascendant":      {},
                "ethereal":       {},
                "mystic":         {},
                "astral":         {},
                "spiritual":      {},
                "primal":         {},
                "mortal":         {},
                "primordial":     {},
        }

        tierRanges := map[string]string{
                "transcendental": "3780+",
                "cosmic":         "3360-3779",
                "divine":         "2700-3359",
                "celestial":      "2400-2699",
                "ascendant":      "2100-2399",
                "ethereal":       "1800-2099",
                "mystic":         "1500-1799",
                "astral":         "1200-1499",
                "spiritual":      "900-1199",
                "primal":         "600-899",
                "mortal":         "300-599",
                "primordial":     "0-299",
        }

        for model, score := range totalScores </span><span class="cov8" title="1">{
                switch </span>{
                case score &gt;= 3780:<span class="cov8" title="1">
                        tiers["transcendental"] = append(tiers["transcendental"], model)</span>
                case score &gt;= 3360:<span class="cov8" title="1">
                        tiers["cosmic"] = append(tiers["cosmic"], model)</span>
                case score &gt;= 2700:<span class="cov8" title="1">
                        tiers["divine"] = append(tiers["divine"], model)</span>
                case score &gt;= 2400:<span class="cov8" title="1">
                        tiers["celestial"] = append(tiers["celestial"], model)</span>
                case score &gt;= 2100:<span class="cov8" title="1">
                        tiers["ascendant"] = append(tiers["ascendant"], model)</span>
                case score &gt;= 1800:<span class="cov8" title="1">
                        tiers["ethereal"] = append(tiers["ethereal"], model)</span>
                case score &gt;= 1500:<span class="cov8" title="1">
                        tiers["mystic"] = append(tiers["mystic"], model)</span>
                case score &gt;= 1200:<span class="cov8" title="1">
                        tiers["astral"] = append(tiers["astral"], model)</span>
                case score &gt;= 900:<span class="cov8" title="1">
                        tiers["spiritual"] = append(tiers["spiritual"], model)</span>
                case score &gt;= 600:<span class="cov8" title="1">
                        tiers["primal"] = append(tiers["primal"], model)</span>
                case score &gt;= 300:<span class="cov8" title="1">
                        tiers["mortal"] = append(tiers["mortal"], model)</span>
                default:<span class="cov8" title="1">
                        tiers["primordial"] = append(tiers["primordial"], model)</span>
                }
        }

        <span class="cov8" title="1">return tiers, tierRanges</span>
}

// StatsHandler handles the stats page (backward compatible wrapper)
func StatsHandler(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        DefaultHandler.Stats(w, r)
}</span>

// Stats handles the stats page
func (h *Handler) Stats(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        log.Println("Handling stats page")
        results := h.DataStore.ReadResults()

        // Calculate score breakdowns
        type ScoreStats struct {
                TotalScore int `json:"TotalScore"`
                Count20    int `json:"Count20"`
                Count40    int `json:"Count40"`
                Count60    int `json:"Count60"`
                Count80    int `json:"Count80"`
                Count100   int `json:"Count100"`
        }

        scoreStats := make(map[string]ScoreStats)
        for model, result := range results </span><span class="cov8" title="1">{
                stats := ScoreStats{}
                for _, score := range result.Scores </span><span class="cov8" title="1">{
                        stats.TotalScore += score
                        switch score </span>{
                        case 20:<span class="cov8" title="1">
                                stats.Count20++</span>
                        case 40:<span class="cov8" title="1">
                                stats.Count40++</span>
                        case 60:<span class="cov8" title="1">
                                stats.Count60++</span>
                        case 80:<span class="cov8" title="1">
                                stats.Count80++</span>
                        case 100:<span class="cov8" title="1">
                                stats.Count100++</span>
                        }
                }

                // Double-check total score calculation to ensure consistency
                <span class="cov8" title="1">calculatedTotal := stats.Count20*20 + stats.Count40*40 + stats.Count60*60 + stats.Count80*80 + stats.Count100*100
                if calculatedTotal != stats.TotalScore </span><span class="cov8" title="1">{
                        log.Printf("Warning: Score mismatch for %s: calculated=%d, summed=%d", model, calculatedTotal, stats.TotalScore)
                        // Fix the total score if there's a discrepancy
                        stats.TotalScore = calculatedTotal
                }</span>
                <span class="cov8" title="1">scoreStats[model] = stats</span>
        }

        // Create total scores map for tier calculations
        <span class="cov8" title="1">totalScores := make(map[string]int)
        for model, stats := range scoreStats </span><span class="cov8" title="1">{
                totalScores[model] = stats.TotalScore
        }</span>

        // Calculate tiers
        <span class="cov8" title="1">tiers, tierRanges := calculateTiers(totalScores)

        // Prepare template data
        templateData := struct {
                PageName     string
                TotalScores  map[string]ScoreStats
                Tiers        map[string][]string
                TierRanges   map[string]string
                OrderedTiers []string
        }{
                PageName:    "Statistics",
                TotalScores: scoreStats,
                Tiers:       tiers,
                TierRanges:  tierRanges,
                OrderedTiers: []string{
                        "transcendental",
                        "cosmic",
                        "divine",
                        "celestial",
                        "ascendant",
                        "ethereal",
                        "mystic",
                        "astral",
                        "spiritual",
                        "primal",
                        "mortal",
                        "primordial",
                },
        }

        funcMap := template.FuncMap{
                "json": func(v interface{}) template.JS </span><span class="cov8" title="1">{
                        a, _ := json.Marshal(v)
                        return template.JS(a)
                }</span>,
                "eqs": func(a, b string) bool <span class="cov8" title="1">{
                        return a == b
                }</span>,
                "tierClass": func(tier string) string <span class="cov8" title="1">{
                        return tier
                }</span>,
                "formatTierName": func(tier string) string <span class="cov8" title="1">{
                        return strings.Title(strings.ReplaceAll(tier, "-", " "))
                }</span>,
                "join": strings.Join,
        }

        <span class="cov8" title="1">err := h.Renderer.Render(w, "stats.html", funcMap, templateData, "templates/stats.html", "templates/nav.html")
        if err != nil </span><span class="cov8" title="1">{
                log.Printf("Error rendering template: %v", err)
                http.Error(w, "Error rendering template", http.StatusInternalServerError)
                return
        }</span>
}
</pre>
		
		<pre class="file" id="file13" style="display: none">package handlers

import (
        "fmt"
        "log"
        "net/http"

        "llm-tournament/middleware"
)

// DeletePromptSuiteHandler handles delete prompt suite (backward compatible wrapper)
func DeletePromptSuiteHandler(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        DefaultHandler.DeletePromptSuite(w, r)
}</span>

// SelectPromptSuiteHandler handles select prompt suite (backward compatible wrapper)
func SelectPromptSuiteHandler(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        DefaultHandler.SelectPromptSuite(w, r)
}</span>

// NewPromptSuiteHandler handles new prompt suite (backward compatible wrapper)
func NewPromptSuiteHandler(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        DefaultHandler.NewPromptSuite(w, r)
}</span>

// EditPromptSuiteHandler handles edit prompt suite (backward compatible wrapper)
func EditPromptSuiteHandler(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        DefaultHandler.EditPromptSuite(w, r)
}</span>

// DeletePromptSuite handles delete prompt suite page
func (h *Handler) DeletePromptSuite(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        log.Println("Handling delete prompt suite page")
        if r.Method == "GET" </span><span class="cov8" title="1">{
                suiteName := r.URL.Query().Get("suite_name")
                if err := h.Renderer.Render(w, "delete_prompt_suite.html", nil, map[string]string{"SuiteName": suiteName}, "templates/delete_prompt_suite.html"); err != nil </span><span class="cov8" title="1">{
                        log.Printf("Error rendering template: %v", err)
                        http.Error(w, "Error rendering template", http.StatusInternalServerError)
                        return
                }</span>
                <span class="cov8" title="1">log.Println("Delete prompt suite page rendered successfully")</span>
        } else<span class="cov8" title="1"> if r.Method == "POST" </span><span class="cov8" title="1">{
                suiteName := r.FormValue("suite_name")
                if suiteName == "" </span><span class="cov8" title="1">{
                        http.Error(w, "Suite name is required", http.StatusBadRequest)
                        return
                }</span>

                <span class="cov8" title="1">currentSuite := h.DataStore.GetCurrentSuiteName()
                if suiteName == currentSuite </span><span class="cov8" title="1">{
                        if err := h.DataStore.SetCurrentSuite("default"); err != nil </span><span class="cov8" title="1">{
                                log.Printf("Error updating current suite: %v", err)
                                http.Error(w, "Error updating current suite", http.StatusInternalServerError)
                                return
                        }</span>
                }

                <span class="cov8" title="1">err := middleware.DeletePromptSuite(suiteName)
                if err != nil </span><span class="cov8" title="1">{
                        log.Printf("Error deleting prompt suite: %v", err)
                        http.Error(w, "Error deleting prompt suite", http.StatusInternalServerError)
                        return
                }</span>

                <span class="cov8" title="1">log.Printf("Prompt suite '%s' deleted successfully", suiteName)
                h.DataStore.BroadcastResults()
                http.Redirect(w, r, "/prompts", http.StatusSeeOther)</span>
        } else<span class="cov8" title="1"> {
                http.Error(w, "Method not allowed", http.StatusMethodNotAllowed)
        }</span>
}

// SelectPromptSuite handles select prompt suite
func (h *Handler) SelectPromptSuite(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        log.Println("Handling select prompt suite")
        if r.Method != http.MethodPost </span><span class="cov8" title="1">{
                http.Error(w, "Method not allowed", http.StatusMethodNotAllowed)
                return
        }</span>
        <span class="cov8" title="1">err := r.ParseForm()
        if err != nil </span><span class="cov8" title="1">{
                log.Printf("Error parsing form: %v", err)
                http.Error(w, "Error parsing form", http.StatusBadRequest)
                return
        }</span>
        <span class="cov8" title="1">suiteName := r.Form.Get("suite_name")
        if suiteName == "" </span><span class="cov8" title="1">{
                log.Println("Suite name cannot be empty")
                http.Error(w, "Suite name cannot be empty", http.StatusBadRequest)
                return
        }</span>

        <span class="cov8" title="1">if err = h.DataStore.SetCurrentSuite(suiteName); err != nil </span><span class="cov8" title="1">{
                log.Printf("Error setting current suite: %v", err)
                http.Error(w, "Error setting current suite", http.StatusInternalServerError)
                return
        }</span>

        <span class="cov8" title="1">log.Printf("Prompt suite '%s' selected successfully", suiteName)
        h.DataStore.BroadcastResults()
        http.Redirect(w, r, "/prompts", http.StatusSeeOther)</span>
}

// NewPromptSuite handles new prompt suite
func (h *Handler) NewPromptSuite(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        log.Println("Handling new prompt suite")
        if r.Method == "GET" </span><span class="cov8" title="1">{
                if err := h.Renderer.Render(w, "new_prompt_suite.html", nil, nil, "templates/new_prompt_suite.html"); err != nil </span><span class="cov8" title="1">{
                        log.Printf("Error rendering template: %v", err)
                        http.Error(w, "Error rendering template", http.StatusInternalServerError)
                        return
                }</span>
                <span class="cov8" title="1">log.Println("New prompt suite page rendered successfully")</span>
        } else<span class="cov8" title="1"> if r.Method == "POST" </span><span class="cov8" title="1">{
                err := r.ParseForm()
                if err != nil </span><span class="cov8" title="1">{
                        log.Printf("Error parsing form: %v", err)
                        http.Error(w, "Error parsing form", http.StatusBadRequest)
                        return
                }</span>
                <span class="cov8" title="1">suiteName := r.Form.Get("suite_name")
                if suiteName == "" </span><span class="cov8" title="1">{
                        log.Println("Suite name cannot be empty")
                        http.Error(w, "Suite name cannot be empty", http.StatusBadRequest)
                        return
                }</span>
                <span class="cov8" title="1">err = h.DataStore.WritePromptSuite(suiteName, []middleware.Prompt{})
                if err != nil </span><span class="cov8" title="1">{
                        log.Printf("Error creating prompt suite: %v", err)
                        http.Error(w, "Error creating prompt suite", http.StatusInternalServerError)
                        return
                }</span>
                <span class="cov8" title="1">log.Printf("Prompt suite '%s' created successfully", suiteName)
                h.DataStore.BroadcastResults()
                http.Redirect(w, r, "/prompts", http.StatusSeeOther)</span>
        } else<span class="cov8" title="1"> {
                http.Error(w, "Method not allowed", http.StatusMethodNotAllowed)
        }</span>
}

// EditPromptSuite handles edit prompt suite
func (h *Handler) EditPromptSuite(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        log.Println("Handling edit prompt suite")
        if r.Method == "GET" </span><span class="cov8" title="1">{
                suiteName := r.URL.Query().Get("suite_name")
                if err := h.Renderer.Render(w, "edit_prompt_suite.html", nil, map[string]string{"SuiteName": suiteName}, "templates/edit_prompt_suite.html"); err != nil </span><span class="cov8" title="1">{
                        log.Printf("Error rendering template: %v", err)
                        http.Error(w, "Error rendering template", http.StatusInternalServerError)
                        return
                }</span>
                <span class="cov8" title="1">log.Println("Edit prompt suite page rendered successfully")</span>
        } else<span class="cov8" title="1"> if r.Method == "POST" </span><span class="cov8" title="1">{
                err := r.ParseForm()
                if err != nil </span><span class="cov8" title="1">{
                        log.Printf("Error parsing form: %v", err)
                        http.Error(w, "Error parsing form", http.StatusBadRequest)
                        return
                }</span>
                <span class="cov8" title="1">oldSuiteName := r.Form.Get("suite_name")
                newSuiteName := r.Form.Get("new_suite_name")

                if oldSuiteName == "" || newSuiteName == "" </span><span class="cov8" title="1">{
                        log.Println("Both old and new names required")
                        http.Error(w, "Both original and new suite names are required", http.StatusBadRequest)
                        return
                }</span>

                <span class="cov8" title="1">if err := middleware.RenameSuiteFiles(oldSuiteName, newSuiteName); err != nil </span><span class="cov8" title="1">{
                        log.Printf("Error renaming suite: %v", err)
                        http.Error(w, fmt.Sprintf("Error renaming suite: %v", err), http.StatusBadRequest)
                        return
                }</span>
                <span class="cov8" title="1">log.Printf("Prompt suite '%s' edited successfully to '%s'", oldSuiteName, newSuiteName)
                h.DataStore.BroadcastResults()
                http.Redirect(w, r, "/prompts", http.StatusSeeOther)</span>
        } else<span class="cov8" title="1"> {
                http.Error(w, "Method not allowed", http.StatusMethodNotAllowed)
        }</span>
}
</pre>
		
		<pre class="file" id="file14" style="display: none">package main

import (
        "log"
        "net/http"

        "llm-tournament/handlers"
        "llm-tournament/middleware"
)

var routes = map[string]http.HandlerFunc{
        "/import_error":            middleware.ImportErrorHandler,
        "/prompts":                 handlers.PromptListHandler,
        "/add_model":               handlers.AddModelHandler,
        "/edit_model":              handlers.EditModelHandler,
        "/delete_model":            handlers.DeleteModelHandler,
        "/add_prompt":              handlers.AddPromptHandler,
        "/edit_prompt":             handlers.EditPromptHandler,
        "/delete_prompt":           handlers.DeletePromptHandler,
        "/move_prompt":             handlers.MovePromptHandler,
        "/import_results":          handlers.ImportResultsHandler,
        "/export_prompts":          handlers.ExportPromptsHandler,
        "/import_prompts":          handlers.ImportPromptsHandler,
        "/update_prompts_order":    handlers.UpdatePromptsOrderHandler,
        "/reset_prompts":           handlers.ResetPromptsHandler,
        "/bulk_delete_prompts":     handlers.BulkDeletePromptsHandler,
        "/prompts/suites/new":      handlers.NewPromptSuiteHandler,
        "/prompts/suites/edit":     handlers.EditPromptSuiteHandler,
        "/prompts/suites/delete":   handlers.DeletePromptSuiteHandler,
        "/prompts/suites/select":   handlers.SelectPromptSuiteHandler,
        "/results":                 handlers.ResultsHandler,
        "/update_result":           handlers.UpdateResultHandler,
        "/reset_results":           handlers.ResetResultsHandler,
        "/confirm_refresh_results": handlers.ConfirmRefreshResultsHandler,
        "/refresh_results":         handlers.RefreshResultsHandler,
        "/export_results":          handlers.ExportResultsHandler,
        "/update_mock_results":     handlers.UpdateMockResultsHandler,
        "/evaluate":                handlers.EvaluateResult,
        "/profiles":                handlers.ProfilesHandler,
        "/add_profile":             handlers.AddProfileHandler,
        "/edit_profile":            handlers.EditProfileHandler,
        "/delete_profile":          handlers.DeleteProfileHandler,
        "/reset_profiles":          handlers.ResetProfilesHandler,
        "/stats":                   handlers.StatsHandler,
        // New evaluation routes
        "/settings":            handlers.SettingsHandler,
        "/settings/update":     handlers.UpdateSettingsHandler,
        "/settings/test_key":   handlers.TestAPIKeyHandler,
        "/evaluate/all":        handlers.EvaluateAllHandler,
        "/evaluate/model":      handlers.EvaluateModelHandler,
        "/evaluate/prompt":     handlers.EvaluatePromptHandler,
        "/evaluation/progress": handlers.EvaluationProgressHandler,
        "/evaluation/cancel":   handlers.CancelEvaluationHandler,
}

func router(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        log.Printf("Request received: %s %s", r.Method, r.URL.Path)

        if handler, exists := routes[r.URL.Path]; exists </span><span class="cov8" title="1">{
                handler(w, r)
                return
        }</span>

        <span class="cov8" title="1">log.Printf("Redirecting to /prompts from %s", r.URL.Path)
        http.Redirect(w, r, "/prompts", http.StatusSeeOther)</span>
}
</pre>
		
		<pre class="file" id="file15" style="display: none">package middleware

import (
        "database/sql"
        "fmt"
        "os"
        "path/filepath"
        "strings"

        _ "github.com/mattn/go-sqlite3"
)

var db *sql.DB

var lastInsertID = func(result sql.Result) (int64, error) <span class="cov8" title="1">{ return result.LastInsertId() }</span>
var sqlOpen = sql.Open
var execPragmas = func(conn *sql.DB) error <span class="cov8" title="1">{
        _, err := conn.Exec(`PRAGMA journal_mode = WAL;
                     PRAGMA synchronous = NORMAL;
                     PRAGMA foreign_keys = ON;`)
        return err
}</span>
var createTablesFunc = createTables
var dbBegin = func() (*sql.Tx, error) <span class="cov8" title="1">{ return db.Begin() }</span>

// GetDB returns the database connection
func GetDB() *sql.DB <span class="cov8" title="1">{
        return db
}</span>

// InitDB initializes the SQLite database connection
func InitDB(dbPath string) error <span class="cov8" title="1">{
        // Ensure data directory exists
        dataDir := filepath.Dir(dbPath)
        if err := os.MkdirAll(dataDir, 0755); err != nil </span><span class="cov8" title="1">{
                return fmt.Errorf("failed to create data directory: %w", err)
        }</span>

        <span class="cov8" title="1">var err error
        db, err = sqlOpen("sqlite3", dbPath)
        if err != nil </span><span class="cov8" title="1">{
                return fmt.Errorf("failed to open database: %w", err)
        }</span>

        // Set pragmas for better performance
        <span class="cov8" title="1">if err = execPragmas(db); err != nil </span><span class="cov8" title="1">{
                return fmt.Errorf("failed to set database pragmas: %w", err)
        }</span>

        // Create schema if it doesn't exist
        <span class="cov8" title="1">if err = createTablesFunc(); err != nil </span><span class="cov8" title="1">{
                return fmt.Errorf("failed to create tables: %w", err)
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// CloseDB closes the database connection
func CloseDB() error <span class="cov8" title="1">{
        if db != nil </span><span class="cov8" title="1">{
                return db.Close()
        }</span>
        <span class="cov8" title="1">return nil</span>
}

// createTables creates all the necessary tables if they don't exist
func createTables() error <span class="cov8" title="1">{
        schema := `
        CREATE TABLE IF NOT EXISTS suites (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                name TEXT UNIQUE NOT NULL,
                is_current BOOLEAN DEFAULT FALSE
        );

        CREATE TABLE IF NOT EXISTS profiles (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                name TEXT NOT NULL,
                description TEXT,
                suite_id INTEGER NOT NULL,
                FOREIGN KEY (suite_id) REFERENCES suites(id) ON DELETE CASCADE,
                UNIQUE(name, suite_id)
        );

        CREATE TABLE IF NOT EXISTS prompts (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                text TEXT NOT NULL,
                solution TEXT,
                profile_id INTEGER,
                suite_id INTEGER NOT NULL,
                display_order INTEGER NOT NULL,
                type TEXT NOT NULL DEFAULT 'objective',
                FOREIGN KEY (profile_id) REFERENCES profiles(id) ON DELETE SET NULL,
                FOREIGN KEY (suite_id) REFERENCES suites(id) ON DELETE CASCADE,
                UNIQUE(text, suite_id)
        );

        CREATE TABLE IF NOT EXISTS models (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                name TEXT NOT NULL,
                suite_id INTEGER NOT NULL,
                FOREIGN KEY (suite_id) REFERENCES suites(id) ON DELETE CASCADE,
                UNIQUE(name, suite_id)
        );

        CREATE TABLE IF NOT EXISTS scores (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                model_id INTEGER NOT NULL,
                prompt_id INTEGER NOT NULL,
                score INTEGER NOT NULL DEFAULT 0,
                FOREIGN KEY (model_id) REFERENCES models(id) ON DELETE CASCADE,
                FOREIGN KEY (prompt_id) REFERENCES prompts(id) ON DELETE CASCADE,
                UNIQUE(model_id, prompt_id)
        );

        CREATE TABLE IF NOT EXISTS settings (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                key TEXT UNIQUE NOT NULL,
                value TEXT NOT NULL,
                created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
        );

        CREATE TABLE IF NOT EXISTS evaluation_jobs (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                suite_id INTEGER NOT NULL,
                job_type TEXT NOT NULL,
                target_id INTEGER,
                status TEXT NOT NULL DEFAULT 'pending',
                progress_current INTEGER DEFAULT 0,
                progress_total INTEGER DEFAULT 0,
                estimated_cost_usd REAL DEFAULT 0.0,
                actual_cost_usd REAL DEFAULT 0.0,
                error_message TEXT,
                created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                started_at TIMESTAMP,
                completed_at TIMESTAMP,
                FOREIGN KEY (suite_id) REFERENCES suites(id) ON DELETE CASCADE
        );

        CREATE TABLE IF NOT EXISTS model_responses (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                model_id INTEGER NOT NULL,
                prompt_id INTEGER NOT NULL,
                response_text TEXT,
                response_source TEXT NOT NULL DEFAULT 'manual',
                api_config TEXT,
                created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                FOREIGN KEY (model_id) REFERENCES models(id) ON DELETE CASCADE,
                FOREIGN KEY (prompt_id) REFERENCES prompts(id) ON DELETE CASCADE,
                UNIQUE(model_id, prompt_id)
        );

        CREATE TABLE IF NOT EXISTS evaluation_history (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                job_id INTEGER NOT NULL,
                model_id INTEGER NOT NULL,
                prompt_id INTEGER NOT NULL,
                judge_name TEXT NOT NULL,
                judge_score INTEGER,
                judge_confidence REAL,
                judge_reasoning TEXT,
                cost_usd REAL DEFAULT 0.0,
                created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                FOREIGN KEY (job_id) REFERENCES evaluation_jobs(id) ON DELETE CASCADE,
                FOREIGN KEY (model_id) REFERENCES models(id) ON DELETE CASCADE,
                FOREIGN KEY (prompt_id) REFERENCES prompts(id) ON DELETE CASCADE
        );

        CREATE TABLE IF NOT EXISTS cost_tracking (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                suite_id INTEGER NOT NULL,
                date DATE NOT NULL,
                total_cost_usd REAL DEFAULT 0.0,
                evaluation_count INTEGER DEFAULT 0,
                FOREIGN KEY (suite_id) REFERENCES suites(id) ON DELETE CASCADE,
                UNIQUE(suite_id, date)
        );

        -- Create indexes
        CREATE INDEX IF NOT EXISTS idx_settings_key ON settings(key);
        CREATE INDEX IF NOT EXISTS idx_evaluation_jobs_status ON evaluation_jobs(status);
        CREATE INDEX IF NOT EXISTS idx_evaluation_jobs_suite ON evaluation_jobs(suite_id);
        CREATE INDEX IF NOT EXISTS idx_model_responses_lookup ON model_responses(model_id, prompt_id);
        CREATE INDEX IF NOT EXISTS idx_evaluation_history_job ON evaluation_history(job_id);
        CREATE INDEX IF NOT EXISTS idx_evaluation_history_lookup ON evaluation_history(model_id, prompt_id);
        CREATE INDEX IF NOT EXISTS idx_cost_tracking_suite_date ON cost_tracking(suite_id, date);

        -- Add the default suite if it doesn't exist
        INSERT OR IGNORE INTO suites (name, is_current) VALUES ('default', 1);

        -- Initialize default settings
        INSERT OR IGNORE INTO settings (key, value) VALUES
                ('api_key_anthropic', ''),
                ('api_key_openai', ''),
                ('api_key_google', ''),
                ('cost_alert_threshold_usd', '100.0'),
                ('auto_evaluate_new_models', 'false'),
                ('python_service_url', 'http://localhost:8001');
        `

        _, err := db.Exec(schema)
        return err
}</span>

// GetSuiteID returns the ID of the specified suite or creates it if it doesn't exist
func GetSuiteID(suiteName string) (int, error) <span class="cov8" title="1">{
        if suiteName == "" </span><span class="cov8" title="1">{
                suiteName = "default"
        }</span>

        // Try to get the existing suite
        <span class="cov8" title="1">var suiteID int
        err := db.QueryRow("SELECT id FROM suites WHERE name = ?", suiteName).Scan(&amp;suiteID)
        if err == nil </span><span class="cov8" title="1">{
                return suiteID, nil
        }</span>

        // If suite doesn't exist, create it
        <span class="cov8" title="1">if err == sql.ErrNoRows </span><span class="cov8" title="1">{
                result, err := db.Exec("INSERT INTO suites (name) VALUES (?)", suiteName)
                if err != nil </span><span class="cov8" title="1">{
                        return 0, fmt.Errorf("failed to create suite: %w", err)
                }</span>
                <span class="cov8" title="1">id, err := lastInsertID(result)
                if err != nil </span><span class="cov8" title="1">{
                        return 0, fmt.Errorf("failed to get suite ID: %w", err)
                }</span>
                <span class="cov8" title="1">return int(id), nil</span>
        }

        <span class="cov8" title="1">return 0, err</span>
}

// GetCurrentSuiteID returns the ID of the current suite
func GetCurrentSuiteID() (int, error) <span class="cov8" title="1">{
        var suiteID int
        err := db.QueryRow("SELECT id FROM suites WHERE is_current = 1").Scan(&amp;suiteID)
        if err == sql.ErrNoRows </span><span class="cov8" title="1">{
                // If no current suite, set default as current
                _, err = db.Exec("UPDATE suites SET is_current = 1 WHERE name = 'default'")
                if err != nil </span><span class="cov8" title="1">{
                        return 0, fmt.Errorf("failed to set default suite as current: %w", err)
                }</span>
                <span class="cov8" title="1">return GetCurrentSuiteID()</span>
        }
        <span class="cov8" title="1">return suiteID, err</span>
}

// SetCurrentSuite sets the specified suite as the current one
func SetCurrentSuite(suiteName string) error <span class="cov8" title="1">{
        if suiteName == "" </span><span class="cov8" title="1">{
                suiteName = "default"
        }</span>

        // Get or create the suite
        <span class="cov8" title="1">suiteID, err := GetSuiteID(suiteName)
        if err != nil </span><span class="cov8" title="1">{
                return fmt.Errorf("failed to get suite: %w", err)
        }</span>

        // Begin transaction
        <span class="cov8" title="1">tx, err := dbBegin()
        if err != nil </span><span class="cov8" title="1">{
                return fmt.Errorf("failed to begin transaction: %w", err)
        }</span>
        <span class="cov8" title="1">defer func() </span><span class="cov8" title="1">{
                if err != nil </span><span class="cov8" title="1">{
                        tx.Rollback()
                }</span>
        }()

        // Clear current suite flag
        <span class="cov8" title="1">_, err = tx.Exec("UPDATE suites SET is_current = 0")
        if err != nil </span><span class="cov8" title="1">{
                return fmt.Errorf("failed to clear current suite flag: %w", err)
        }</span>

        // Set new current suite
        <span class="cov8" title="1">_, err = tx.Exec("UPDATE suites SET is_current = 1 WHERE id = ?", suiteID)
        if err != nil </span><span class="cov8" title="1">{
                return fmt.Errorf("failed to set current suite: %w", err)
        }</span>

        <span class="cov8" title="1">return tx.Commit()</span>
}

// ListSuites returns a list of all suite names
func ListSuites() ([]string, error) <span class="cov8" title="1">{
        rows, err := db.Query("SELECT name FROM suites ORDER BY name")
        if err != nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("failed to query suites: %w", err)
        }</span>
        <span class="cov8" title="1">defer rows.Close()

        var suites []string
        for rows.Next() </span><span class="cov8" title="1">{
                var name string
                if err := rows.Scan(&amp;name); err != nil </span><span class="cov8" title="1">{
                        return nil, fmt.Errorf("failed to scan suite name: %w", err)
                }</span>
                <span class="cov8" title="1">suites = append(suites, name)</span>
        }

        <span class="cov8" title="1">return suites, nil</span>
}

// DeleteSuite deletes a suite and all associated data
func DeleteSuite(suiteName string) error <span class="cov8" title="1">{
        if suiteName == "default" </span><span class="cov8" title="1">{
                return fmt.Errorf("cannot delete the default suite")
        }</span>

        <span class="cov8" title="1">suiteID, err := GetSuiteID(suiteName)
        if err != nil </span><span class="cov8" title="1">{
                return fmt.Errorf("failed to get suite ID: %w", err)
        }</span>

        // Check if it's the current suite
        <span class="cov8" title="1">var isCurrent bool
        err = db.QueryRow("SELECT is_current FROM suites WHERE id = ?", suiteID).Scan(&amp;isCurrent)
        if err != nil </span><span class="cov8" title="1">{
                return fmt.Errorf("failed to check if suite is current: %w", err)
        }</span>

        // Begin transaction
        <span class="cov8" title="1">tx, err := dbBegin()
        if err != nil </span><span class="cov8" title="1">{
                return fmt.Errorf("failed to begin transaction: %w", err)
        }</span>
        <span class="cov8" title="1">defer func() </span><span class="cov8" title="1">{
                if err != nil </span><span class="cov8" title="1">{
                        tx.Rollback()
                }</span>
        }()

        // Delete the suite (cascade will delete related data)
        <span class="cov8" title="1">_, err = tx.Exec("DELETE FROM suites WHERE id = ?", suiteID)
        if err != nil </span><span class="cov8" title="1">{
                return fmt.Errorf("failed to delete suite: %w", err)
        }</span>

        // If it was the current suite, set default as current
        <span class="cov8" title="1">if isCurrent </span><span class="cov8" title="1">{
                _, err = tx.Exec("UPDATE suites SET is_current = 1 WHERE name = 'default'")
                if err != nil </span><span class="cov8" title="1">{
                        return fmt.Errorf("failed to set default suite as current: %w", err)
                }</span>
        }

        <span class="cov8" title="1">return tx.Commit()</span>
}

// RenameSuite renames a suite
func RenameSuite(oldName, newName string) error <span class="cov8" title="1">{
        if oldName == "default" </span><span class="cov8" title="1">{
                return fmt.Errorf("cannot rename the default suite")
        }</span>
        <span class="cov8" title="1">if newName == "" </span><span class="cov8" title="1">{
                return fmt.Errorf("new suite name cannot be empty")
        }</span>
        <span class="cov8" title="1">if strings.ContainsAny(newName, "/\\") </span><span class="cov8" title="1">{
                return fmt.Errorf("suite name contains invalid characters")
        }</span>

        // Check if new name already exists
        <span class="cov8" title="1">var exists int
        err := db.QueryRow("SELECT 1 FROM suites WHERE name = ?", newName).Scan(&amp;exists)
        if err == nil </span><span class="cov8" title="1">{
                return fmt.Errorf("suite with name '%s' already exists", newName)
        }</span> else<span class="cov8" title="1"> if err != sql.ErrNoRows </span><span class="cov8" title="1">{
                return fmt.Errorf("failed to check if suite exists: %w", err)
        }</span>

        // Rename the suite
        <span class="cov8" title="1">_, err = db.Exec("UPDATE suites SET name = ? WHERE name = ?", newName, oldName)
        if err != nil </span><span class="cov8" title="1">{
                return fmt.Errorf("failed to rename suite: %w", err)
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// GetProfileID returns the profile ID for a given name and suite
func GetProfileID(profileName string, suiteID int) (int, bool, error) <span class="cov8" title="1">{
        if profileName == "" </span><span class="cov8" title="1">{
                return 0, false, nil
        }</span>

        <span class="cov8" title="1">var profileID int
        err := db.QueryRow("SELECT id FROM profiles WHERE name = ? AND suite_id = ?", profileName, suiteID).Scan(&amp;profileID)
        if err == sql.ErrNoRows </span><span class="cov8" title="1">{
                return 0, false, nil
        }</span>
        <span class="cov8" title="1">if err != nil </span><span class="cov8" title="1">{
                return 0, false, err
        }</span>
        <span class="cov8" title="1">return profileID, true, nil</span>
}
</pre>
		
		<pre class="file" id="file16" style="display: none">package middleware

// DataStore defines the interface for data persistence operations
type DataStore interface {
        // Suite operations
        GetCurrentSuiteID() (int, error)
        GetCurrentSuiteName() string
        ListSuites() ([]string, error)
        SetCurrentSuite(name string) error
        SuiteExists(name string) bool

        // Prompt operations
        ReadPrompts() []Prompt
        WritePrompts(prompts []Prompt) error
        ReadPromptSuite(suiteName string) ([]Prompt, error)
        WritePromptSuite(suiteName string, prompts []Prompt) error
        ListPromptSuites() ([]string, error)
        UpdatePromptsOrder(order []int)

        // Profile operations
        ReadProfiles() []Profile
        WriteProfiles(profiles []Profile) error

        // Results operations
        ReadResults() map[string]Result
        WriteResults(suiteName string, results map[string]Result) error

        // Settings operations
        GetSetting(key string) (string, error)
        SetSetting(key, value string) error
        GetAPIKey(provider string) (string, error)
        SetAPIKey(provider, key string) error
        GetMaskedAPIKeys() (map[string]string, error)

        // Broadcast
        BroadcastResults()
}

// SQLiteDataStore implements DataStore using SQLite
type SQLiteDataStore struct{}

// GetCurrentSuiteID delegates to the package-level function
func (s *SQLiteDataStore) GetCurrentSuiteID() (int, error) <span class="cov8" title="1">{
        return GetCurrentSuiteID()
}</span>

// GetCurrentSuiteName delegates to the package-level function
func (s *SQLiteDataStore) GetCurrentSuiteName() string <span class="cov8" title="1">{
        return GetCurrentSuiteName()
}</span>

// ListSuites delegates to the package-level function
func (s *SQLiteDataStore) ListSuites() ([]string, error) <span class="cov8" title="1">{
        return ListSuites()
}</span>

// SetCurrentSuite delegates to the package-level function
func (s *SQLiteDataStore) SetCurrentSuite(name string) error <span class="cov8" title="1">{
        return SetCurrentSuite(name)
}</span>

// SuiteExists delegates to the package-level function
func (s *SQLiteDataStore) SuiteExists(name string) bool <span class="cov8" title="1">{
        return SuiteExists(name)
}</span>

// ReadPrompts delegates to the package-level function
func (s *SQLiteDataStore) ReadPrompts() []Prompt <span class="cov8" title="1">{
        return ReadPrompts()
}</span>

// WritePrompts delegates to the package-level function
func (s *SQLiteDataStore) WritePrompts(prompts []Prompt) error <span class="cov8" title="1">{
        return WritePrompts(prompts)
}</span>

// ReadPromptSuite delegates to the package-level function
func (s *SQLiteDataStore) ReadPromptSuite(suiteName string) ([]Prompt, error) <span class="cov8" title="1">{
        return ReadPromptSuite(suiteName)
}</span>

// WritePromptSuite delegates to the package-level function
func (s *SQLiteDataStore) WritePromptSuite(suiteName string, prompts []Prompt) error <span class="cov8" title="1">{
        return WritePromptSuite(suiteName, prompts)
}</span>

// ListPromptSuites delegates to the package-level function
func (s *SQLiteDataStore) ListPromptSuites() ([]string, error) <span class="cov8" title="1">{
        return ListPromptSuites()
}</span>

// UpdatePromptsOrder delegates to the package-level function
func (s *SQLiteDataStore) UpdatePromptsOrder(order []int) <span class="cov8" title="1">{
        UpdatePromptsOrder(order)
}</span>

// ReadProfiles delegates to the package-level function
func (s *SQLiteDataStore) ReadProfiles() []Profile <span class="cov8" title="1">{
        return ReadProfiles()
}</span>

// WriteProfiles delegates to the package-level function
func (s *SQLiteDataStore) WriteProfiles(profiles []Profile) error <span class="cov8" title="1">{
        return WriteProfiles(profiles)
}</span>

// ReadResults delegates to the package-level function
func (s *SQLiteDataStore) ReadResults() map[string]Result <span class="cov8" title="1">{
        return ReadResults()
}</span>

// WriteResults delegates to the package-level function
func (s *SQLiteDataStore) WriteResults(suiteName string, results map[string]Result) error <span class="cov8" title="1">{
        return WriteResults(suiteName, results)
}</span>

// GetSetting delegates to the package-level function
func (s *SQLiteDataStore) GetSetting(key string) (string, error) <span class="cov8" title="1">{
        return GetSetting(key)
}</span>

// SetSetting delegates to the package-level function
func (s *SQLiteDataStore) SetSetting(key, value string) error <span class="cov8" title="1">{
        return SetSetting(key, value)
}</span>

// GetAPIKey delegates to the package-level function
func (s *SQLiteDataStore) GetAPIKey(provider string) (string, error) <span class="cov8" title="1">{
        return GetAPIKey(provider)
}</span>

// SetAPIKey delegates to the package-level function
func (s *SQLiteDataStore) SetAPIKey(provider, key string) error <span class="cov8" title="1">{
        return SetAPIKey(provider, key)
}</span>

// GetMaskedAPIKeys delegates to the package-level function
func (s *SQLiteDataStore) GetMaskedAPIKeys() (map[string]string, error) <span class="cov8" title="1">{
        return GetMaskedAPIKeys()
}</span>

// BroadcastResults delegates to the package-level function
func (s *SQLiteDataStore) BroadcastResults() <span class="cov8" title="1">{
        BroadcastResults()
}</span>

// DefaultDataStore is the default DataStore instance
var DefaultDataStore DataStore = &amp;SQLiteDataStore{}
</pre>
		
		<pre class="file" id="file17" style="display: none">package middleware

import (
        "crypto/aes"
        "crypto/cipher"
        "crypto/rand"
        "encoding/base64"
        "fmt"
        "io"
        "os"
)

var (
        aesNewCipher           = aes.NewCipher
        cipherNewGCM           = cipher.NewGCM
        randReader   io.Reader = rand.Reader
)

// getEncryptionKey retrieves the encryption key from environment
func getEncryptionKey() ([]byte, error) <span class="cov8" title="1">{
        keyHex := os.Getenv("ENCRYPTION_KEY")
        if keyHex == "" </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("ENCRYPTION_KEY environment variable not set")
        }</span>

        // Convert hex string to bytes (expecting 32-byte hex = 64 characters)
        <span class="cov8" title="1">if len(keyHex) != 64 </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("ENCRYPTION_KEY must be 64 hex characters (32 bytes)")
        }</span>

        <span class="cov8" title="1">key := make([]byte, 32)
        for i := 0; i &lt; 32; i++ </span><span class="cov8" title="1">{
                _, err := fmt.Sscanf(keyHex[i*2:i*2+2], "%02x", &amp;key[i])
                if err != nil </span><span class="cov8" title="1">{
                        return nil, fmt.Errorf("invalid ENCRYPTION_KEY format: %w", err)
                }</span>
        }

        <span class="cov8" title="1">return key, nil</span>
}

// EncryptAPIKey encrypts an API key using AES-256-GCM
func EncryptAPIKey(plaintext string) (string, error) <span class="cov8" title="1">{
        if plaintext == "" </span><span class="cov8" title="1">{
                return "", nil
        }</span>

        <span class="cov8" title="1">key, err := getEncryptionKey()
        if err != nil </span><span class="cov8" title="1">{
                return "", err
        }</span>

        <span class="cov8" title="1">block, err := aesNewCipher(key)
        if err != nil </span><span class="cov8" title="1">{
                return "", fmt.Errorf("failed to create cipher: %w", err)
        }</span>

        <span class="cov8" title="1">aesGCM, err := cipherNewGCM(block)
        if err != nil </span><span class="cov8" title="1">{
                return "", fmt.Errorf("failed to create GCM: %w", err)
        }</span>

        // Create nonce
        <span class="cov8" title="1">nonce := make([]byte, aesGCM.NonceSize())
        if _, err := io.ReadFull(randReader, nonce); err != nil </span><span class="cov8" title="1">{
                return "", fmt.Errorf("failed to generate nonce: %w", err)
        }</span>

        // Encrypt
        <span class="cov8" title="1">ciphertext := aesGCM.Seal(nonce, nonce, []byte(plaintext), nil)

        // Encode to base64 for storage
        return base64.StdEncoding.EncodeToString(ciphertext), nil</span>
}

// DecryptAPIKey decrypts an API key using AES-256-GCM
func DecryptAPIKey(ciphertext string) (string, error) <span class="cov8" title="1">{
        if ciphertext == "" </span><span class="cov8" title="1">{
                return "", nil
        }</span>

        <span class="cov8" title="1">key, err := getEncryptionKey()
        if err != nil </span><span class="cov8" title="1">{
                return "", err
        }</span>

        // Decode from base64
        <span class="cov8" title="1">data, err := base64.StdEncoding.DecodeString(ciphertext)
        if err != nil </span><span class="cov8" title="1">{
                return "", fmt.Errorf("failed to decode ciphertext: %w", err)
        }</span>

        <span class="cov8" title="1">block, err := aesNewCipher(key)
        if err != nil </span><span class="cov8" title="1">{
                return "", fmt.Errorf("failed to create cipher: %w", err)
        }</span>

        <span class="cov8" title="1">aesGCM, err := cipherNewGCM(block)
        if err != nil </span><span class="cov8" title="1">{
                return "", fmt.Errorf("failed to create GCM: %w", err)
        }</span>

        <span class="cov8" title="1">nonceSize := aesGCM.NonceSize()
        if len(data) &lt; nonceSize </span><span class="cov8" title="1">{
                return "", fmt.Errorf("ciphertext too short")
        }</span>

        <span class="cov8" title="1">nonce, ciphertextBytes := data[:nonceSize], data[nonceSize:]
        plaintext, err := aesGCM.Open(nil, nonce, ciphertextBytes, nil)
        if err != nil </span><span class="cov8" title="1">{
                return "", fmt.Errorf("failed to decrypt: %w", err)
        }</span>

        <span class="cov8" title="1">return string(plaintext), nil</span>
}

// MaskAPIKey masks an API key for display (show only last 4 characters)
func MaskAPIKey(apiKey string) string <span class="cov8" title="1">{
        if apiKey == "" </span><span class="cov8" title="1">{
                return ""
        }</span>

        <span class="cov8" title="1">if len(apiKey) &lt;= 4 </span><span class="cov8" title="1">{
                return "****"
        }</span>

        <span class="cov8" title="1">return "sk-..." + apiKey[len(apiKey)-4:]</span>
}
</pre>
		
		<pre class="file" id="file18" style="display: none">package middleware

import (
        "encoding/json"
        "log"
        "net/http"

        "llm-tournament/templates"
)

func RenderTemplate(w http.ResponseWriter, tmpl string, data interface{}) <span class="cov8" title="1">{
        err := DefaultRenderer.Render(w, tmpl, templates.FuncMap, data, "templates/"+tmpl, "templates/nav.html")
        if err != nil </span><span class="cov8" title="1">{
                log.Printf("Error rendering template: %v", err)
                http.Error(w, "Error rendering template", http.StatusInternalServerError)
        }</span>
}

// RenderTemplateSimple renders a single template without nav.html
func RenderTemplateSimple(w http.ResponseWriter, tmpl string, data interface{}) error <span class="cov8" title="1">{
        err := DefaultRenderer.Render(w, tmpl, nil, data, "templates/"+tmpl)
        if err != nil </span><span class="cov8" title="1">{
                log.Printf("Error rendering template: %v", err)
                http.Error(w, "Error rendering template", http.StatusInternalServerError)
        }</span>
        <span class="cov8" title="1">return err</span>
}

func HandleFormError(w http.ResponseWriter, err error) <span class="cov8" title="1">{
        log.Printf("Error parsing form: %v", err)
        http.Error(w, "Error parsing form", http.StatusBadRequest)
}</span>

// RespondJSON sends a JSON response
func RespondJSON(w http.ResponseWriter, data interface{}) <span class="cov8" title="1">{
        w.Header().Set("Content-Type", "application/json")
        if err := json.NewEncoder(w).Encode(data); err != nil </span><span class="cov8" title="1">{
                log.Printf("Error encoding JSON: %v", err)
                http.Error(w, "Error encoding JSON", http.StatusInternalServerError)
        }</span>
}
</pre>
		
		<pre class="file" id="file19" style="display: none">package middleware

import (
        "html/template"
        "log"
        "net/http"
)

// ImportErrorHandler handles the import error page
func ImportErrorHandler(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        log.Println("Handling import error page")
        t, err := template.ParseFiles("templates/import_error.html")
        if err != nil </span><span class="cov8" title="1">{
                log.Printf("Error parsing template: %v", err)
                http.Error(w, "Error parsing template", http.StatusInternalServerError)
                return
        }</span>
        <span class="cov8" title="1">err = t.Execute(w, nil)
        if err != nil </span><span class="cov8" title="1">{
                log.Printf("Error executing template: %v", err)
                http.Error(w, "Error executing template", http.StatusInternalServerError)
                return
        }</span>
        <span class="cov8" title="1">log.Println("Import error page rendered successfully")</span>
}
</pre>
		
		<pre class="file" id="file20" style="display: none">package middleware

import (
        "html/template"
        "net/http"
)

// TemplateRenderer defines the interface for rendering templates
type TemplateRenderer interface {
        Render(w http.ResponseWriter, name string, funcMap template.FuncMap, data interface{}, files ...string) error
        RenderTemplateSimple(w http.ResponseWriter, tmpl string, data interface{}) error
}

// FileRenderer renders templates from files
type FileRenderer struct{}

// Render parses and executes templates from the given files
func (r *FileRenderer) Render(w http.ResponseWriter, name string, funcMap template.FuncMap, data interface{}, files ...string) error <span class="cov8" title="1">{
        t, err := template.New(name).Funcs(funcMap).ParseFiles(files...)
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>
        <span class="cov8" title="1">return t.Execute(w, data)</span>
}

// RenderTemplateSimple renders a single template file without funcMap
func (r *FileRenderer) RenderTemplateSimple(w http.ResponseWriter, tmpl string, data interface{}) error <span class="cov8" title="1">{
        return r.Render(w, tmpl, nil, data, "templates/"+tmpl)
}</span>

// DefaultRenderer is the default TemplateRenderer instance
var DefaultRenderer TemplateRenderer = &amp;FileRenderer{}
</pre>
		
		<pre class="file" id="file21" style="display: none">package middleware

import (
        "database/sql"
        "fmt"
        "time"
)

// GetSetting retrieves a setting value (encrypted values are not decrypted)
func GetSetting(key string) (string, error) <span class="cov8" title="1">{
        var value string
        err := db.QueryRow("SELECT value FROM settings WHERE key = ?", key).Scan(&amp;value)
        if err == sql.ErrNoRows </span><span class="cov8" title="1">{
                return "", nil
        }</span>
        <span class="cov8" title="1">return value, err</span>
}

// SetSetting updates or inserts a setting
func SetSetting(key, value string) error <span class="cov8" title="1">{
        now := time.Now()
        _, err := db.Exec(`
                INSERT OR REPLACE INTO settings (key, value, created_at, updated_at)
                VALUES (?, ?, COALESCE((SELECT created_at FROM settings WHERE key = ?), ?), ?)
        `, key, value, key, now, now)
        return err
}</span>

// GetAPIKey retrieves and decrypts an API key
func GetAPIKey(provider string) (string, error) <span class="cov8" title="1">{
        encrypted, err := GetSetting(fmt.Sprintf("api_key_%s", provider))
        if err != nil || encrypted == "" </span><span class="cov8" title="1">{
                return "", err
        }</span>
        <span class="cov8" title="1">return DecryptAPIKey(encrypted)</span>
}

// SetAPIKey encrypts and stores an API key
func SetAPIKey(provider, apiKey string) error <span class="cov8" title="1">{
        encrypted, err := EncryptAPIKey(apiKey)
        if err != nil </span><span class="cov8" title="1">{
                return fmt.Errorf("failed to encrypt API key: %w", err)
        }</span>
        <span class="cov8" title="1">return SetSetting(fmt.Sprintf("api_key_%s", provider), encrypted)</span>
}

// GetAllSettings retrieves all settings as a map
func GetAllSettings() (map[string]string, error) <span class="cov8" title="1">{
        rows, err := db.Query("SELECT key, value FROM settings")
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>
        <span class="cov8" title="1">defer rows.Close()

        settings := make(map[string]string)
        for rows.Next() </span><span class="cov8" title="1">{
                var key, value string
                if err := rows.Scan(&amp;key, &amp;value); err != nil </span><span class="cov8" title="1">{
                        return nil, err
                }</span>
                <span class="cov8" title="1">settings[key] = value</span>
        }
        <span class="cov8" title="1">return settings, nil</span>
}

// GetMaskedAPIKeys retrieves all API keys in masked form for display
func GetMaskedAPIKeys() (map[string]string, error) <span class="cov8" title="1">{
        rows, err := db.Query("SELECT key, value FROM settings WHERE key LIKE 'api_key_%'")
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>
        <span class="cov8" title="1">defer rows.Close()

        apiKeys := make(map[string]string)
        for rows.Next() </span><span class="cov8" title="1">{
                var key, encryptedValue string
                if err := rows.Scan(&amp;key, &amp;encryptedValue); err != nil </span><span class="cov8" title="1">{
                        return nil, err
                }</span>

                // Decrypt and mask
                <span class="cov8" title="1">decrypted, err := DecryptAPIKey(encryptedValue)
                if err != nil </span><span class="cov8" title="1">{
                        apiKeys[key] = "***ERROR***"
                        continue</span>
                }

                <span class="cov8" title="1">apiKeys[key] = MaskAPIKey(decrypted)</span>
        }

        <span class="cov8" title="1">return apiKeys, nil</span>
}
</pre>
		
		<pre class="file" id="file22" style="display: none">package middleware

import (
        "encoding/json"
        "log"
        "net/http"
        "sort"
        "sync"

        "github.com/gorilla/websocket"
)

var upgrader = websocket.Upgrader{
        ReadBufferSize:  1024,
        WriteBufferSize: 1024,
        CheckOrigin: func(r *http.Request) bool <span class="cov8" title="1">{
                return true
        }</span>,
}

// ProfileGroup represents a group of prompts with the same profile
type ProfileGroup struct {
        ID       string `json:"id"`
        Name     string `json:"name"`
        StartCol int    `json:"startCol"` // Column index where this profile starts
        EndCol   int    `json:"endCol"`   // Column index where this profile ends
        Color    string `json:"color"`    // Generated color for this profile
}

var clients = make(map[*websocket.Conn]bool)
var clientsMutex sync.Mutex

func HandleWebSocket(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        log.Println("Handling websocket connection")
        conn, err := upgrader.Upgrade(w, r, nil)
        if err != nil </span><span class="cov8" title="1">{
                log.Printf("Error upgrading connection: %v", err)
                return
        }</span>

        <span class="cov8" title="1">clientsMutex.Lock()
        clients[conn] = true
        clientsMutex.Unlock()

        defer func() </span><span class="cov8" title="1">{
                clientsMutex.Lock()
                delete(clients, conn)
                clientsMutex.Unlock()
                log.Println("Closing websocket connection")
                conn.Close()
        }</span>()

        <span class="cov8" title="1">for </span><span class="cov8" title="1">{
                _, msg, err := conn.ReadMessage()
                if err != nil </span><span class="cov8" title="1">{
                        if websocket.IsUnexpectedCloseError(err, websocket.CloseGoingAway, websocket.CloseAbnormalClosure) </span><span class="cov8" title="1">{
                                log.Printf("Websocket error: %v", err)
                        }</span>
                        <span class="cov8" title="1">break</span>
                }

                <span class="cov8" title="1">var message struct {
                        Type  string `json:"type"`
                        Order []int  `json:"order"`
                }
                if err := json.Unmarshal(msg, &amp;message); err != nil </span><span class="cov8" title="1">{
                        log.Printf("Error unmarshalling message: %v", err)
                        continue</span>
                }

                <span class="cov8" title="1">switch message.Type </span>{
                case "update_prompts_order":<span class="cov8" title="1">
                        UpdatePromptsOrder(message.Order)</span>
                default:<span class="cov8" title="1">
                        log.Printf("Unknown message type: %s", message.Type)</span>
                }
        }
}

func BroadcastResults() <span class="cov8" title="1">{
        suiteName := GetCurrentSuiteName()
        prompts := ReadPrompts()
        results := ReadResults()
        log.Println("BroadcastResults results:", results)

        modelTotalScores := make(map[string]int)
        for model, result := range results </span><span class="cov8" title="1">{
                totalScore := 0
                for _, score := range result.Scores </span><span class="cov8" title="1">{
                        totalScore += score
                }</span>
                <span class="cov8" title="1">modelTotalScores[model] = totalScore</span>
        }

        <span class="cov8" title="1">models := make([]string, 0, len(results))
        for model := range results </span><span class="cov8" title="1">{
                models = append(models, model)
        }</span>
        <span class="cov8" title="1">if len(models) == 0 </span><span class="cov8" title="1">{
                models = []string{"Model1", "Model2"} // Example fallback
        }</span>
        <span class="cov8" title="1">sort.Slice(models, func(i, j int) bool </span><span class="cov8" title="1">{
                return modelTotalScores[models[i]] &gt; modelTotalScores[models[j]]
        }</span>)

        // Group prompts by profile
        <span class="cov8" title="1">var orderedPrompts []struct {
                Index       int    `json:"index"`
                Text        string `json:"text"`
                ProfileID   string `json:"profileId"`
                ProfileName string `json:"profileName"`
        }

        // Get all profiles first (to include empty ones)
        profiles := ReadProfiles()

        // Get profile groups using the utility function
        profileGroups, profileMap := GetProfileGroups(prompts, profiles)

        // Check if we have any uncategorized prompts
        hasUncategorized := false
        for _, prompt := range prompts </span><span class="cov8" title="1">{
                if prompt.Profile == "" </span><span class="cov8" title="1">{
                        hasUncategorized = true
                        break</span>
                }
        }

        // Add a group for prompts with no profile only if needed
        <span class="cov8" title="1">if hasUncategorized </span><span class="cov8" title="1">{
                noProfileGroup := &amp;ProfileGroup{
                        ID:       "none",
                        Name:     "Uncategorized",
                        Color:    "hsl(0, 0%, 50%)",
                        StartCol: -1,
                        EndCol:   -1,
                }
                profileGroups = append(profileGroups, noProfileGroup)
                profileMap[""] = noProfileGroup
        }</span>

        // Process prompts and assign them to profile groups
        <span class="cov8" title="1">currentCol := 0
        for i, prompt := range prompts </span><span class="cov8" title="1">{
                profileName := prompt.Profile

                group := profileMap[profileName]

                if group.StartCol == -1 </span><span class="cov8" title="1">{
                        group.StartCol = currentCol
                }</span>
                <span class="cov8" title="1">group.EndCol = currentCol

                orderedPrompts = append(orderedPrompts, struct {
                        Index       int    `json:"index"`
                        Text        string `json:"text"`
                        ProfileID   string `json:"profileId"`
                        ProfileName string `json:"profileName"`
                }{
                        Index:       i,
                        Text:        prompt.Text,
                        ProfileID:   group.ID,
                        ProfileName: profileName,
                })

                currentCol++</span>
        }

        // Log the data we're about to send
        <span class="cov8" title="1">log.Printf("Broadcasting data - Models: %v", models)

        payload := struct {
                Type string `json:"type"`
                Data struct {
                        Results         map[string]Result  `json:"results"`
                        Models          []string           `json:"models"`
                        TotalScores     map[string]int     `json:"totalScores"`
                        PassPercentages map[string]float64 `json:"passPercentages"`
                        Prompts         []string           `json:"prompts"`
                        SuiteName       string             `json:"suiteName"`
                        ProfileGroups   []*ProfileGroup    `json:"profileGroups"`
                        OrderedPrompts  interface{}        `json:"orderedPrompts"`
                } `json:"data"`
        }{
                Type: "results",
                Data: struct {
                        Results         map[string]Result  `json:"results"`
                        Models          []string           `json:"models"`
                        TotalScores     map[string]int     `json:"totalScores"`
                        PassPercentages map[string]float64 `json:"passPercentages"`
                        Prompts         []string           `json:"prompts"`
                        SuiteName       string             `json:"suiteName"`
                        ProfileGroups   []*ProfileGroup    `json:"profileGroups"`
                        OrderedPrompts  interface{}        `json:"orderedPrompts"`
                }{
                        Results:         results,
                        Models:          models,
                        TotalScores:     modelTotalScores,
                        PassPercentages: calculatePassPercentages(results, len(prompts)),
                        Prompts:         promptsToStringArray(prompts),
                        SuiteName:       suiteName,
                        ProfileGroups:   profileGroups,
                        OrderedPrompts:  orderedPrompts,
                },
        }

        clientsMutex.Lock()
        defer clientsMutex.Unlock()
        for client := range clients </span><span class="cov8" title="1">{
                err := client.WriteJSON(payload)
                if err != nil </span><span class="cov8" title="1">{
                        log.Printf("Error broadcasting message: %v", err)
                        client.Close()
                        delete(clients, client)
                }</span>
        }
}

func promptsToStringArray(prompts []Prompt) []string <span class="cov8" title="1">{
        promptsTexts := make([]string, len(prompts))
        for i, prompt := range prompts </span><span class="cov8" title="1">{
                promptsTexts[i] = prompt.Text
        }</span>
        <span class="cov8" title="1">return promptsTexts</span>
}

func calculatePassPercentages(results map[string]Result, promptCount int) map[string]float64 <span class="cov8" title="1">{
        passPercentages := make(map[string]float64)
        for model, result := range results </span><span class="cov8" title="1">{
                totalScore := 0
                for _, score := range result.Scores </span><span class="cov8" title="1">{
                        totalScore += score
                }</span>
                <span class="cov8" title="1">passPercentages[model] = float64(totalScore) / float64(promptCount*100) * 100</span>
        }
        <span class="cov8" title="1">return passPercentages</span>
}

// BroadcastEvaluationProgress broadcasts evaluation progress to all clients
func BroadcastEvaluationProgress(jobID, current, total int, cost float64) <span class="cov8" title="1">{
        payload := struct {
                Type string `json:"type"`
                Data struct {
                        JobID   int     `json:"job_id"`
                        Current int     `json:"current"`
                        Total   int     `json:"total"`
                        Cost    float64 `json:"cost"`
                } `json:"data"`
        }{
                Type: "evaluation_progress",
        }
        payload.Data.JobID = jobID
        payload.Data.Current = current
        payload.Data.Total = total
        payload.Data.Cost = cost

        broadcastMessage(payload)
}</span>

// BroadcastEvaluationCompleted broadcasts evaluation completion
func BroadcastEvaluationCompleted(jobID int, finalCost float64) <span class="cov8" title="1">{
        payload := struct {
                Type string `json:"type"`
                Data struct {
                        JobID     int     `json:"job_id"`
                        FinalCost float64 `json:"final_cost"`
                } `json:"data"`
        }{
                Type: "evaluation_completed",
        }
        payload.Data.JobID = jobID
        payload.Data.FinalCost = finalCost

        broadcastMessage(payload)
        // Also refresh results
        BroadcastResults()
}</span>

// BroadcastEvaluationFailed broadcasts evaluation failure
func BroadcastEvaluationFailed(jobID int, errorMsg string) <span class="cov8" title="1">{
        payload := struct {
                Type string `json:"type"`
                Data struct {
                        JobID int    `json:"job_id"`
                        Error string `json:"error"`
                } `json:"data"`
        }{
                Type: "evaluation_failed",
        }
        payload.Data.JobID = jobID
        payload.Data.Error = errorMsg

        broadcastMessage(payload)
}</span>

// BroadcastCostAlert broadcasts cost threshold alert
func BroadcastCostAlert(suiteID int, currentCost, threshold float64) <span class="cov8" title="1">{
        payload := struct {
                Type string `json:"type"`
                Data struct {
                        SuiteID     int     `json:"suite_id"`
                        CurrentCost float64 `json:"current_cost"`
                        Threshold   float64 `json:"threshold"`
                } `json:"data"`
        }{
                Type: "cost_alert",
        }
        payload.Data.SuiteID = suiteID
        payload.Data.CurrentCost = currentCost
        payload.Data.Threshold = threshold

        broadcastMessage(payload)
}</span>

// broadcastMessage sends a JSON message to all connected clients
func broadcastMessage(payload interface{}) <span class="cov8" title="1">{
        clientsMutex.Lock()
        defer clientsMutex.Unlock()

        for client := range clients </span><span class="cov8" title="1">{
                err := client.WriteJSON(payload)
                if err != nil </span><span class="cov8" title="1">{
                        log.Printf("Error broadcasting message: %v", err)
                        client.Close()
                        delete(clients, client)
                }</span>
        }
}
</pre>
		
		<pre class="file" id="file23" style="display: none">package middleware

import (
        "database/sql"
        "fmt"
        "log"
)

var rowsErr = func(rows *sql.Rows) error <span class="cov8" title="1">{ return rows.Err() }</span>
var txCommit = func(tx *sql.Tx) error <span class="cov8" title="1">{ return tx.Commit() }</span>

type Prompt struct {
        Text     string `json:"text"`
        Solution string `json:"solution"`
        Profile  string `json:"profile"`
}

type Result struct {
        Scores []int `json:"scores"`
}

type Profile struct {
        Name        string `json:"name"`
        Description string `json:"description"`
}

// Read profiles from database for current suite
func ReadProfiles() []Profile <span class="cov8" title="1">{
        suiteName := GetCurrentSuiteName()
        profiles, _ := ReadProfileSuite(suiteName)
        return profiles
}</span>

// Write profiles to database
func WriteProfiles(profiles []Profile) error <span class="cov8" title="1">{
        suiteName := GetCurrentSuiteName()
        return WriteProfileSuite(suiteName, profiles)
}</span>

// Read profile suite from database
func ReadProfileSuite(suiteName string) ([]Profile, error) <span class="cov8" title="1">{
        suiteID, err := GetSuiteID(suiteName)
        if err != nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("failed to get suite ID: %w", err)
        }</span>

        <span class="cov8" title="1">rows, err := db.Query("SELECT name, description FROM profiles WHERE suite_id = ? ORDER BY id", suiteID)
        if err != nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("failed to query profiles: %w", err)
        }</span>
        <span class="cov8" title="1">defer rows.Close()

        var profiles []Profile
        for rows.Next() </span><span class="cov8" title="1">{
                var p Profile
                if err := rows.Scan(&amp;p.Name, &amp;p.Description); err != nil </span><span class="cov8" title="1">{
                        return nil, fmt.Errorf("failed to scan profile: %w", err)
                }</span>
                <span class="cov8" title="1">profiles = append(profiles, p)</span>
        }

        <span class="cov8" title="1">return profiles, nil</span>
}

// Write profile suite to database
func WriteProfileSuite(suiteName string, profiles []Profile) error <span class="cov8" title="1">{
        suiteID, err := GetSuiteID(suiteName)
        if err != nil </span><span class="cov8" title="1">{
                return fmt.Errorf("failed to get suite ID: %w", err)
        }</span>

        // Begin transaction
        <span class="cov8" title="1">tx, err := dbBegin()
        if err != nil </span><span class="cov8" title="1">{
                return fmt.Errorf("failed to begin transaction: %w", err)
        }</span>
        <span class="cov8" title="1">defer func() </span><span class="cov8" title="1">{
                if err != nil </span><span class="cov8" title="1">{
                        tx.Rollback()
                }</span>
        }()

        // Delete existing profiles for this suite
        <span class="cov8" title="1">_, err = tx.Exec("DELETE FROM profiles WHERE suite_id = ?", suiteID)
        if err != nil </span><span class="cov8" title="1">{
                return fmt.Errorf("failed to delete profiles: %w", err)
        }</span>

        // Insert new profiles
        <span class="cov8" title="1">if len(profiles) &gt; 0 </span><span class="cov8" title="1">{
                stmt, err := tx.Prepare("INSERT INTO profiles (name, description, suite_id) VALUES (?, ?, ?)")
                if err != nil </span><span class="cov8" title="1">{
                        return fmt.Errorf("failed to prepare profile insert: %w", err)
                }</span>
                <span class="cov8" title="1">defer stmt.Close()

                for _, profile := range profiles </span><span class="cov8" title="1">{
                        _, err = stmt.Exec(profile.Name, profile.Description, suiteID)
                        if err != nil </span><span class="cov8" title="1">{
                                return fmt.Errorf("failed to insert profile: %w", err)
                        }</span>
                }
        }

        <span class="cov8" title="1">return tx.Commit()</span>
}

// List all profile suites
func ListProfileSuites() ([]string, error) <span class="cov8" title="1">{
        return ListSuites()
}</span>

func DeleteProfileSuite(suiteName string) error <span class="cov8" title="1">{
        return DeleteSuite(suiteName)
}</span>

// Read prompts from prompts.json
func ReadPrompts() []Prompt <span class="cov8" title="1">{
        suiteName := GetCurrentSuiteName()
        prompts, _ := ReadPromptSuite(suiteName)
        return prompts
}</span>

// Write prompts to prompts.json
func WritePrompts(prompts []Prompt) error <span class="cov8" title="1">{
        suiteName := GetCurrentSuiteName()
        return WritePromptSuite(suiteName, prompts)
}</span>

// Read results from database
func ReadResults() map[string]Result <span class="cov8" title="1">{
        suiteName := GetCurrentSuiteName()
        var suiteID int
        err := db.QueryRow("SELECT id FROM suites WHERE name = ?", suiteName).Scan(&amp;suiteID)
        if err != nil </span><span class="cov8" title="1">{
                log.Printf("Error getting suite ID: %v", err)
                return make(map[string]Result)
        }</span>

        // Get all prompts for this suite
        <span class="cov8" title="1">promptCountQuery := "SELECT COUNT(*) FROM prompts WHERE suite_id = ?"
        var promptCount int
        err = db.QueryRow(promptCountQuery, suiteID).Scan(&amp;promptCount)
        if err != nil </span><span class="cov8" title="1">{
                log.Printf("Error counting prompts: %v", err)
                return make(map[string]Result)
        }</span>

        // Get all models for this suite
        <span class="cov8" title="1">modelQuery := "SELECT id, name FROM models WHERE suite_id = ?"
        modelRows, err := db.Query(modelQuery, suiteID)
        if err != nil </span><span class="cov8" title="1">{
                log.Printf("Error querying models: %v", err)
                return make(map[string]Result)
        }</span>
        <span class="cov8" title="1">defer modelRows.Close()

        results := make(map[string]Result)
        for modelRows.Next() </span><span class="cov8" title="1">{
                var modelID int
                var modelName string
                if err := modelRows.Scan(&amp;modelID, &amp;modelName); err != nil </span><span class="cov8" title="1">{
                        log.Printf("Error scanning model: %v", err)
                        continue</span>
                }

                // Initialize scores array
                <span class="cov8" title="1">scores := make([]int, promptCount)

                // Get scores for this model
                scoreQuery := `
                SELECT p.display_order, s.score
                FROM scores s
                JOIN prompts p ON s.prompt_id = p.id
                WHERE s.model_id = ? AND p.suite_id = ?
                ORDER BY p.display_order
                `
                scoreRows, err := db.Query(scoreQuery, modelID, suiteID)
                if err != nil </span><span class="cov8" title="1">{
                        log.Printf("Error querying scores: %v", err)
                        continue</span>
                }

                <span class="cov8" title="1">for scoreRows.Next() </span><span class="cov8" title="1">{
                        var promptOrder, score int
                        if err := scoreRows.Scan(&amp;promptOrder, &amp;score); err != nil </span><span class="cov8" title="1">{
                                log.Printf("Error scanning score: %v", err)
                                continue</span>
                        }

                        <span class="cov8" title="1">if promptOrder &gt;= 0 &amp;&amp; promptOrder &lt; promptCount </span><span class="cov8" title="1">{
                                scores[promptOrder] = score
                        }</span>
                }
                <span class="cov8" title="1">scoreRows.Close()

                results[modelName] = Result{Scores: scores}</span>
        }

        <span class="cov8" title="1">return results</span>
}

// Read prompt suite from database
func ReadPromptSuite(suiteName string) ([]Prompt, error) <span class="cov8" title="1">{
        suiteID, err := GetSuiteID(suiteName)
        if err != nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("failed to get suite ID: %w", err)
        }</span>

        // Query to get prompts with profile names - ensure distinct results
        <span class="cov8" title="1">query := `
        SELECT p.text, p.solution, COALESCE(pr.name, '') as profile_name, p.display_order
        FROM prompts p
        LEFT JOIN profiles pr ON p.profile_id = pr.id
        WHERE p.suite_id = ?
        ORDER BY p.display_order
        `

        rows, err := db.Query(query, suiteID)
        if err != nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("failed to query prompts: %w", err)
        }</span>
        <span class="cov8" title="1">defer rows.Close()

        var prompts []Prompt
        seenTexts := make(map[string]bool) // Track unique prompts by text content

        for rows.Next() </span><span class="cov8" title="1">{
                var p Prompt
                var displayOrder int
                if err := rows.Scan(&amp;p.Text, &amp;p.Solution, &amp;p.Profile, &amp;displayOrder); err != nil </span><span class="cov8" title="1">{
                        return nil, fmt.Errorf("failed to scan prompt: %w", err)
                }</span>

                // Ensure we don't add duplicates
                <span class="cov8" title="1">if !seenTexts[p.Text] </span><span class="cov8" title="1">{
                        prompts = append(prompts, p)
                        seenTexts[p.Text] = true
                }</span> else<span class="cov8" title="1"> {
                        log.Printf("Warning: Skipped duplicate prompt with text: %s", p.Text[:min(20, len(p.Text))])
                }</span>
        }

        // Check for any errors during iteration
        <span class="cov8" title="1">if err = rowsErr(rows); err != nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("error iterating prompt rows: %w", err)
        }</span>

        <span class="cov8" title="1">return prompts, nil</span>
}

// min returns the smaller of two integers
func min(a, b int) int <span class="cov8" title="1">{
        if a &lt; b </span><span class="cov8" title="1">{
                return a
        }</span>
        <span class="cov8" title="1">return b</span>
}

// Write prompt suite to database
func WritePromptSuite(suiteName string, prompts []Prompt) error <span class="cov8" title="1">{
        suiteID, err := GetSuiteID(suiteName)
        if err != nil </span><span class="cov8" title="1">{
                return fmt.Errorf("failed to get suite ID: %w", err)
        }</span>

        // Begin transaction
        <span class="cov8" title="1">tx, err := dbBegin()
        if err != nil </span><span class="cov8" title="1">{
                return fmt.Errorf("failed to begin transaction: %w", err)
        }</span>
        <span class="cov8" title="1">defer func() </span><span class="cov8" title="1">{
                if err != nil </span><span class="cov8" title="1">{
                        tx.Rollback()
                }</span>
        }()

        // Delete existing prompts for this suite
        <span class="cov8" title="1">_, err = tx.Exec("DELETE FROM prompts WHERE suite_id = ?", suiteID)
        if err != nil </span><span class="cov8" title="1">{
                return fmt.Errorf("failed to delete prompts: %w", err)
        }</span>

        // Insert new prompts
        <span class="cov8" title="1">if len(prompts) &gt; 0 </span><span class="cov8" title="1">{
                stmt, err := tx.Prepare(`
                INSERT INTO prompts (text, solution, profile_id, suite_id, display_order) 
                VALUES (?, ?, ?, ?, ?)
                `)
                if err != nil </span><span class="cov8" title="1">{
                        return fmt.Errorf("failed to prepare prompt insert: %w", err)
                }</span>
                <span class="cov8" title="1">defer stmt.Close()

                for i, prompt := range prompts </span><span class="cov8" title="1">{
                        // Get profile ID if a profile is specified
                        var profileID sql.NullInt64
                        if prompt.Profile != "" </span><span class="cov8" title="1">{
                                id, exists, err := GetProfileID(prompt.Profile, suiteID)
                                if err != nil </span><span class="cov8" title="1">{
                                        return fmt.Errorf("failed to get profile ID: %w", err)
                                }</span>
                                <span class="cov8" title="1">if exists </span><span class="cov8" title="1">{
                                        profileID.Int64 = int64(id)
                                        profileID.Valid = true
                                }</span>
                        }

                        <span class="cov8" title="1">_, err = stmt.Exec(prompt.Text, prompt.Solution, profileID, suiteID, i)
                        if err != nil </span><span class="cov8" title="1">{
                                return fmt.Errorf("failed to insert prompt: %w", err)
                        }</span>
                }
        }

        <span class="cov8" title="1">return tx.Commit()</span>
}

// List all prompt suites
func ListPromptSuites() ([]string, error) <span class="cov8" title="1">{
        return ListSuites()
}</span>

func DeletePromptSuite(suiteName string) error <span class="cov8" title="1">{
        return DeleteSuite(suiteName)
}</span>

// RenameSuiteFiles renames all files associated with a suite
func RenameSuiteFiles(oldName, newName string) error <span class="cov8" title="1">{
        return RenameSuite(oldName, newName)
}</span>

// SuiteExists checks if a suite with the given name exists
func SuiteExists(name string) bool <span class="cov8" title="1">{
        var exists int
        err := db.QueryRow("SELECT 1 FROM suites WHERE name = ?", name).Scan(&amp;exists)
        return err == nil
}</span>

// Get current suite name
func GetCurrentSuiteName() string <span class="cov8" title="1">{
        var name string
        err := db.QueryRow("SELECT name FROM suites WHERE is_current = 1").Scan(&amp;name)
        if err != nil </span><span class="cov8" title="1">{
                if err == sql.ErrNoRows </span><span class="cov8" title="1">{
                        // Set default suite as current if none is set
                        _, err = db.Exec("UPDATE suites SET is_current = 1 WHERE name = 'default'")
                        if err != nil </span><span class="cov8" title="1">{
                                log.Printf("Error setting default suite as current: %v", err)
                                return ""
                        }</span>
                        <span class="cov8" title="1">return "default"</span>
                }
                <span class="cov8" title="1">log.Printf("Error getting current suite name: %v", err)
                return ""</span>
        }
        <span class="cov8" title="1">return name</span>
}

// Write results to database
func WriteResults(suiteName string, results map[string]Result) error <span class="cov8" title="1">{
        suiteID, err := GetSuiteID(suiteName)
        if err != nil </span><span class="cov8" title="1">{
                return fmt.Errorf("failed to get suite ID: %w", err)
        }</span>

        // Begin transaction
        <span class="cov8" title="1">tx, err := dbBegin()
        if err != nil </span><span class="cov8" title="1">{
                return fmt.Errorf("failed to begin transaction: %w", err)
        }</span>
        <span class="cov8" title="1">defer func() </span><span class="cov8" title="1">{
                if err != nil </span><span class="cov8" title="1">{
                        tx.Rollback()
                }</span>
        }()

        // Get all prompt IDs for this suite
        <span class="cov8" title="1">promptRows, err := tx.Query("SELECT id FROM prompts WHERE suite_id = ? ORDER BY display_order", suiteID)
        if err != nil </span><span class="cov8" title="1">{
                return fmt.Errorf("failed to query prompts: %w", err)
        }</span>

        <span class="cov8" title="1">var promptIDs []int
        for promptRows.Next() </span><span class="cov8" title="1">{
                var id int
                if err := promptRows.Scan(&amp;id); err != nil </span><span class="cov8" title="1">{
                        promptRows.Close()
                        return fmt.Errorf("failed to scan prompt ID: %w", err)
                }</span>
                <span class="cov8" title="1">promptIDs = append(promptIDs, id)</span>
        }
        <span class="cov8" title="1">promptRows.Close()

        if err := rowsErr(promptRows); err != nil </span><span class="cov8" title="1">{
                return fmt.Errorf("error iterating prompt rows: %w", err)
        }</span>

        // Get current model names in the database
        <span class="cov8" title="1">modelNamesRows, err := tx.Query("SELECT name FROM models WHERE suite_id = ?", suiteID)
        if err != nil </span><span class="cov8" title="1">{
                return fmt.Errorf("failed to query model names: %w", err)
        }</span>

        <span class="cov8" title="1">var dbModelNames []string
        for modelNamesRows.Next() </span><span class="cov8" title="1">{
                var name string
                if err := modelNamesRows.Scan(&amp;name); err != nil </span><span class="cov8" title="1">{
                        modelNamesRows.Close()
                        return fmt.Errorf("failed to scan model name: %w", err)
                }</span>
                <span class="cov8" title="1">dbModelNames = append(dbModelNames, name)</span>
        }
        <span class="cov8" title="1">modelNamesRows.Close()

        // Delete models that are in the database but not in the results map
        for _, dbModelName := range dbModelNames </span><span class="cov8" title="1">{
                if _, exists := results[dbModelName]; !exists </span><span class="cov8" title="1">{
                        _, err = tx.Exec("DELETE FROM models WHERE name = ? AND suite_id = ?", dbModelName, suiteID)
                        if err != nil </span><span class="cov8" title="1">{
                                return fmt.Errorf("failed to delete model: %w", err)
                        }</span>
                }
        }

        // Clear existing scores for this suite
        <span class="cov8" title="1">_, err = tx.Exec(`
                DELETE FROM scores 
                WHERE model_id IN (SELECT id FROM models WHERE suite_id = ?)
        `, suiteID)
        if err != nil </span><span class="cov8" title="1">{
                return fmt.Errorf("failed to delete scores: %w", err)
        }</span>

        // Process each model
        <span class="cov8" title="1">for modelName, result := range results </span><span class="cov8" title="1">{
                // Get or create model
                var modelID int
                err := tx.QueryRow("SELECT id FROM models WHERE name = ? AND suite_id = ?", modelName, suiteID).Scan(&amp;modelID)
                if err == sql.ErrNoRows </span><span class="cov8" title="1">{
                        // Create new model
                        modelResult, err := tx.Exec("INSERT INTO models (name, suite_id) VALUES (?, ?)", modelName, suiteID)
                        if err != nil </span><span class="cov8" title="1">{
                                return fmt.Errorf("failed to insert model: %w", err)
                        }</span>
                        <span class="cov8" title="1">modelIDInt64, err := lastInsertID(modelResult)
                        if err != nil </span><span class="cov8" title="1">{
                                return fmt.Errorf("failed to get model ID: %w", err)
                        }</span>
                        <span class="cov8" title="1">modelID = int(modelIDInt64)</span>
                } else<span class="cov8" title="1"> if err != nil </span><span class="cov8" title="1">{
                        return fmt.Errorf("failed to query model: %w", err)
                }</span>

                // Insert scores
                <span class="cov8" title="1">if len(result.Scores) &gt; 0 </span><span class="cov8" title="1">{
                        scoreStmt, err := tx.Prepare("INSERT INTO scores (model_id, prompt_id, score) VALUES (?, ?, ?)")
                        if err != nil </span><span class="cov8" title="1">{
                                return fmt.Errorf("failed to prepare score insert: %w", err)
                        }</span>

                        <span class="cov8" title="1">for i, score := range result.Scores </span><span class="cov8" title="1">{
                                if i &lt; len(promptIDs) </span><span class="cov8" title="1">{
                                        _, err = scoreStmt.Exec(modelID, promptIDs[i], score)
                                        if err != nil </span><span class="cov8" title="1">{
                                                scoreStmt.Close()
                                                return fmt.Errorf("failed to insert score: %w", err)
                                        }</span>
                                }
                        }
                        <span class="cov8" title="1">scoreStmt.Close()</span>
                }
        }

        <span class="cov8" title="1">return tx.Commit()</span>
}

// MigrateResults converts old result formats to the current format
func MigrateResults(results map[string]Result) map[string]Result <span class="cov8" title="1">{
        migrated := make(map[string]Result)
        prompts := ReadPrompts()

        for model, result := range results </span><span class="cov8" title="1">{
                // If we have no Scores, initialize empty array
                if result.Scores == nil </span><span class="cov8" title="1">{
                        result.Scores = make([]int, len(prompts))
                }</span> else<span class="cov8" title="1"> if len(result.Scores) &lt; len(prompts) </span><span class="cov8" title="1">{
                        // Ensure scores array has correct length
                        newScores := make([]int, len(prompts))
                        copy(newScores, result.Scores)
                        result.Scores = newScores
                }</span>

                // Ensure all scores are within valid range
                <span class="cov8" title="1">for i, score := range result.Scores </span><span class="cov8" title="1">{
                        if score &lt; 0 || score &gt; 100 </span><span class="cov8" title="1">{
                                result.Scores[i] = 0
                        }</span>
                }

                <span class="cov8" title="1">migrated[model] = result</span>
        }
        <span class="cov8" title="1">return migrated</span>
}

func UpdatePromptsOrder(order []int) <span class="cov8" title="1">{
        prompts := ReadPrompts()
        if len(order) != len(prompts) </span><span class="cov8" title="1">{
                log.Println("Invalid order length")
                return
        }</span>

        <span class="cov8" title="1">suiteID, err := GetCurrentSuiteID()
        if err != nil </span><span class="cov8" title="1">{
                log.Printf("Error getting current suite ID: %v", err)
                return
        }</span>

        // Begin transaction
        <span class="cov8" title="1">tx, err := dbBegin()
        if err != nil </span><span class="cov8" title="1">{
                log.Printf("Error beginning transaction: %v", err)
                return
        }</span>
        <span class="cov8" title="1">defer func() </span><span class="cov8" title="1">{
                if err != nil </span><span class="cov8" title="1">{
                        tx.Rollback()
                }</span>
        }()

        // Get all prompt IDs for this suite
        <span class="cov8" title="1">promptRows, err := tx.Query("SELECT id FROM prompts WHERE suite_id = ? ORDER BY display_order", suiteID)
        if err != nil </span><span class="cov8" title="1">{
                log.Printf("Error querying prompts: %v", err)
                return
        }</span>

        <span class="cov8" title="1">var promptIDs []int
        for promptRows.Next() </span><span class="cov8" title="1">{
                var id int
                if err := promptRows.Scan(&amp;id); err != nil </span><span class="cov8" title="1">{
                        promptRows.Close()
                        log.Printf("Error scanning prompt ID: %v", err)
                        return
                }</span>
                <span class="cov8" title="1">promptIDs = append(promptIDs, id)</span>
        }
        <span class="cov8" title="1">promptRows.Close()

        // Update each prompt's display_order
        for newOrder, oldIndex := range order </span><span class="cov8" title="1">{
                if oldIndex &lt; 0 || oldIndex &gt;= len(promptIDs) </span><span class="cov8" title="1">{
                        log.Println("Invalid index in order")
                        return
                }</span>

                <span class="cov8" title="1">_, err = tx.Exec("UPDATE prompts SET display_order = ? WHERE id = ?", newOrder, promptIDs[oldIndex])
                if err != nil </span><span class="cov8" title="1">{
                        log.Printf("Error updating prompt order: %v", err)
                        return
                }</span>
        }

        <span class="cov8" title="1">if err = txCommit(tx); err != nil </span><span class="cov8" title="1">{
                log.Printf("Error committing transaction: %v", err)
                return
        }</span>

        <span class="cov8" title="1">log.Println("Prompts order updated successfully")
        BroadcastResults()</span>
}
</pre>
		
		<pre class="file" id="file24" style="display: none">package middleware

import (
        "fmt"
        "sort"
        "strconv"
)

// GetProfileGroups organizes profiles based on prompt order appearances
// Returns profile groups and a map of profile names to their group
func GetProfileGroups(prompts []Prompt, profiles []Profile) ([]*ProfileGroup, map[string]*ProfileGroup) <span class="cov8" title="1">{
        var profileGroups []*ProfileGroup
        profileMap := make(map[string]*ProfileGroup)

        // First, find all unique profiles used in prompts and their first occurrence
        profileOrder := make(map[string]int)
        profilesInUse := make(map[string]bool)

        // Track the order profiles first appear in prompts
        for i, prompt := range prompts </span><span class="cov8" title="1">{
                if prompt.Profile != "" </span><span class="cov8" title="1">{
                        if _, exists := profileOrder[prompt.Profile]; !exists </span><span class="cov8" title="1">{
                                profileOrder[prompt.Profile] = i
                                profilesInUse[prompt.Profile] = true
                        }</span>
                }
        }

        // Create a sorted list of profile names based on first appearance
        <span class="cov8" title="1">var orderedProfileNames []string
        for profileName := range profileOrder </span><span class="cov8" title="1">{
                orderedProfileNames = append(orderedProfileNames, profileName)
        }</span>
        <span class="cov8" title="1">sort.Slice(orderedProfileNames, func(i, j int) bool </span><span class="cov8" title="1">{
                return profileOrder[orderedProfileNames[i]] &lt; profileOrder[orderedProfileNames[j]]
        }</span>)

        // Add profiles in order of first appearance in prompts
        <span class="cov8" title="1">for i, profileName := range orderedProfileNames </span><span class="cov8" title="1">{
                // Generate evenly distributed colors based on index
                colorHue := (i * 137) % 360
                color := fmt.Sprintf("hsl(%d, 70%%, 50%%)", colorHue)

                profileGroups = append(profileGroups, &amp;ProfileGroup{
                        ID:       strconv.Itoa(i),
                        Name:     profileName,
                        Color:    color,
                        StartCol: -1, // Will be populated later
                        EndCol:   -1,
                })
                profileMap[profileName] = profileGroups[len(profileGroups)-1]
        }</span>

        // Add any remaining profiles from the database that aren't used in prompts
        <span class="cov8" title="1">unusedIndex := len(profileGroups)
        for _, profile := range profiles </span><span class="cov8" title="1">{
                if !profilesInUse[profile.Name] </span><span class="cov8" title="1">{
                        colorHue := (unusedIndex * 137) % 360
                        color := fmt.Sprintf("hsl(%d, 70%%, 50%%)", colorHue)

                        profileGroups = append(profileGroups, &amp;ProfileGroup{
                                ID:       strconv.Itoa(unusedIndex),
                                Name:     profile.Name,
                                Color:    color,
                                StartCol: -1, // Will be populated later
                                EndCol:   -1,
                        })
                        profileMap[profile.Name] = profileGroups[len(profileGroups)-1]
                        unusedIndex++
                }</span>
        }

        <span class="cov8" title="1">return profileGroups, profileMap</span>
}
</pre>
		
		<pre class="file" id="file25" style="display: none">package main

import (
        "database/sql"
        "flag"
        "io"
        "log"
        "math/rand"
        "net/http"
        "os"
        "time"

        "llm-tournament/handlers"
        "llm-tournament/middleware"
)

type runDeps struct {
        initDB              func(string) error
        closeDB             func() error
        readResults         func() map[string]middleware.Result
        migrateResults      func(map[string]middleware.Result) map[string]middleware.Result
        getCurrentSuiteName func() string
        writeResults        func(string, map[string]middleware.Result) error
        initEvaluator       func(*sql.DB)
        getDB               func() *sql.DB
        listenAndServe      func(string, http.Handler) error
}

var osExit = os.Exit

func defaultRunDeps() runDeps <span class="cov8" title="1">{
        return runDeps{
                initDB:              middleware.InitDB,
                closeDB:             middleware.CloseDB,
                readResults:         middleware.ReadResults,
                migrateResults:      middleware.MigrateResults,
                getCurrentSuiteName: middleware.GetCurrentSuiteName,
                writeResults:        middleware.WriteResults,
                initEvaluator:       handlers.InitEvaluator,
                getDB:               middleware.GetDB,
                listenAndServe:      http.ListenAndServe,
        }
}</span>

func run(args []string, deps runDeps) int <span class="cov8" title="1">{
        rand.Seed(time.Now().UnixNano())

        fs := flag.NewFlagSet("llm-tournament", flag.ContinueOnError)
        fs.SetOutput(io.Discard)

        migrateResults := fs.Bool("migrate-results", false, "Migrate existing results to new scoring system")
        dbPath := fs.String("db", "data/tournament.db", "SQLite database path")

        if err := fs.Parse(args); err != nil </span><span class="cov8" title="1">{
                return 2
        }</span>

        <span class="cov8" title="1">log.Println("Initializing database...")
        if err := deps.initDB(*dbPath); err != nil </span><span class="cov8" title="1">{
                log.Printf("Failed to initialize database: %v", err)
                return 1
        }</span>
        <span class="cov8" title="1">defer func() </span><span class="cov8" title="1">{ _ = deps.closeDB() }</span>()

        <span class="cov8" title="1">if *migrateResults </span><span class="cov8" title="1">{
                log.Println("Migrating results to new scoring system...")
                results := deps.readResults()
                results = deps.migrateResults(results)

                suiteName := deps.getCurrentSuiteName()
                if err := deps.writeResults(suiteName, results); err != nil </span><span class="cov8" title="1">{
                        log.Printf("Error migrating results: %v", err)
                        return 1
                }</span>
                <span class="cov8" title="1">log.Println("Migration completed successfully")
                return 0</span>
        }

        <span class="cov8" title="1">log.Println("Initializing evaluator...")
        deps.initEvaluator(deps.getDB())

        mux := http.NewServeMux()
        mux.HandleFunc("/", router)
        mux.HandleFunc("/ws", middleware.HandleWebSocket)
        mux.Handle("/templates/", http.StripPrefix("/templates/", http.FileServer(http.Dir("templates"))))
        mux.Handle("/assets/", http.StripPrefix("/assets/", http.FileServer(http.Dir("assets"))))

        log.Println("Server is listening on :8080")
        if err := deps.listenAndServe(":8080", mux); err != nil </span><span class="cov8" title="1">{
                log.Printf("Error starting server: %v", err)
                return 1
        }</span>

        <span class="cov8" title="1">return 0</span>
}

func main() <span class="cov8" title="1">{
        osExit(run(os.Args[1:], defaultRunDeps()))
}</span>
</pre>
		
		<pre class="file" id="file26" style="display: none">package templates

import (
        "encoding/json"
        "html/template"
        "strconv"
        "strings"

        "github.com/microcosm-cc/bluemonday"
        "github.com/russross/blackfriday/v2"
)

var FuncMap = map[string]interface{}{
        "inc": func(i int) int <span class="cov8" title="1">{
                return i + 1
        }</span>,
        "add": func(a, b int) int <span class="cov8" title="1">{
                return a + b
        }</span>,
        "sub": func(a, b int) int <span class="cov8" title="1">{
                return a - b
        }</span>,
        "eqs": func(a, b string) bool <span class="cov8" title="1">{
                return a == b
        }</span>,
        "atoi": func(s string) int <span class="cov8" title="1">{
                i, _ := strconv.Atoi(s)
                return i
        }</span>,
        "markdown": func(text string) template.HTML <span class="cov8" title="1">{
                unsafe := blackfriday.Run([]byte(text), blackfriday.WithNoExtensions())
                html := bluemonday.UGCPolicy().SanitizeBytes(unsafe)
                return template.HTML(html)
        }</span>,
        "tolower":  strings.ToLower,
        "contains": strings.Contains,
        "json": func(v interface{}) (string, error) <span class="cov8" title="1">{
                b, err := json.Marshal(v)
                return string(b), err
        }</span>,
}

const (
        PageNameResults  = "Results"
        PageNamePrompts  = "Prompts"
        PageNameProfiles = "Profiles"
        PageNameEvaluate = "Evaluate"
)

var ScoreOptions = map[string]int{
        "0/5 (0)":   0,
        "1/5 (20)":  20,
        "2/5 (40)":  40,
        "3/5 (60)":  60,
        "4/5 (80)":  80,
        "5/5 (100)": 100,
}
</pre>
		
		<pre class="file" id="file27" style="display: none">package testutil

import (
        "database/sql"
        "html/template"
        "net/http"
        "os"
        "testing"

        _ "github.com/mattn/go-sqlite3"
)

var sqlOpen = sql.Open
var enableForeignKeys = func(db *sql.DB) error <span class="cov8" title="1">{
        _, err := db.Exec("PRAGMA foreign_keys = ON")
        return err
}</span>
var createTestSchemaFunc = createTestSchema
var lastInsertID = func(result sql.Result) (int64, error) <span class="cov8" title="1">{ return result.LastInsertId() }</span>
var fatalf = func(t *testing.T, format string, args ...any) <span class="cov0" title="0">{ t.Fatalf(format, args...) }</span>

// Prompt is a local type matching middleware.Prompt for testing
type Prompt struct {
        Text         string
        Solution     string
        Profile      string
        DisplayOrder int
        Type         string
}

// Profile is a local type matching middleware.Profile for testing
type Profile struct {
        Name        string
        Description string
}

// Result is a local type matching middleware.Result for testing
type Result struct {
        Scores []int
}

// ValidEncryptionKey returns a valid 64-char hex key for testing
func ValidEncryptionKey() string <span class="cov8" title="1">{
        return "0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef"
}</span>

// SetupEncryptionKey sets up a valid ENCRYPTION_KEY env var and returns cleanup function
func SetupEncryptionKey(t *testing.T) func() <span class="cov8" title="1">{
        t.Helper()
        original := os.Getenv("ENCRYPTION_KEY")
        os.Setenv("ENCRYPTION_KEY", ValidEncryptionKey())

        return func() </span><span class="cov8" title="1">{
                if original == "" </span><span class="cov8" title="1">{
                        os.Unsetenv("ENCRYPTION_KEY")
                }</span> else<span class="cov8" title="1"> {
                        os.Setenv("ENCRYPTION_KEY", original)
                }</span>
        }
}

// ClearEncryptionKey removes the ENCRYPTION_KEY env var and returns cleanup function
func ClearEncryptionKey(t *testing.T) func() <span class="cov8" title="1">{
        t.Helper()
        original := os.Getenv("ENCRYPTION_KEY")
        os.Unsetenv("ENCRYPTION_KEY")

        return func() </span><span class="cov8" title="1">{
                if original != "" </span><span class="cov8" title="1">{
                        os.Setenv("ENCRYPTION_KEY", original)
                }</span>
        }
}

// SetupTestDB creates an in-memory SQLite database with schema for testing
func SetupTestDB(t *testing.T) *sql.DB <span class="cov8" title="1">{
        t.Helper()
        db, err := sqlOpen("sqlite3", ":memory:")
        if err != nil </span><span class="cov8" title="1">{
                fatalf(t, "failed to open test database: %v", err)
                return nil
        }</span>

        // Enable foreign keys
        <span class="cov8" title="1">err = enableForeignKeys(db)
        if err != nil </span><span class="cov8" title="1">{
                _ = db.Close()
                fatalf(t, "failed to enable foreign keys: %v", err)
                return nil
        }</span>

        // Create schema
        <span class="cov8" title="1">if err := createTestSchemaFunc(db); err != nil </span><span class="cov8" title="1">{
                _ = db.Close()
                fatalf(t, "failed to create test schema: %v", err)
                return nil
        }</span>

        <span class="cov8" title="1">return db</span>
}

// createTestSchema creates the database schema for testing
func createTestSchema(db *sql.DB) error <span class="cov8" title="1">{
        schema := `
                CREATE TABLE IF NOT EXISTS suites (
                        id INTEGER PRIMARY KEY AUTOINCREMENT,
                        name TEXT UNIQUE NOT NULL,
                        is_current INTEGER DEFAULT 0
                );

                CREATE TABLE IF NOT EXISTS profiles (
                        id INTEGER PRIMARY KEY AUTOINCREMENT,
                        name TEXT NOT NULL,
                        description TEXT DEFAULT '',
                        suite_id INTEGER NOT NULL,
                        FOREIGN KEY (suite_id) REFERENCES suites(id) ON DELETE CASCADE,
                        UNIQUE(name, suite_id)
                );

                CREATE TABLE IF NOT EXISTS prompts (
                        id INTEGER PRIMARY KEY AUTOINCREMENT,
                        text TEXT NOT NULL,
                        solution TEXT DEFAULT '',
                        profile_id INTEGER,
                        suite_id INTEGER NOT NULL,
                        display_order INTEGER DEFAULT 0,
                        type TEXT DEFAULT 'objective',
                        FOREIGN KEY (suite_id) REFERENCES suites(id) ON DELETE CASCADE,
                        FOREIGN KEY (profile_id) REFERENCES profiles(id) ON DELETE SET NULL
                );

                CREATE TABLE IF NOT EXISTS models (
                        id INTEGER PRIMARY KEY AUTOINCREMENT,
                        name TEXT NOT NULL,
                        suite_id INTEGER NOT NULL,
                        FOREIGN KEY (suite_id) REFERENCES suites(id) ON DELETE CASCADE,
                        UNIQUE(name, suite_id)
                );

                CREATE TABLE IF NOT EXISTS scores (
                        id INTEGER PRIMARY KEY AUTOINCREMENT,
                        model_id INTEGER NOT NULL,
                        prompt_id INTEGER NOT NULL,
                        score INTEGER DEFAULT 0,
                        FOREIGN KEY (model_id) REFERENCES models(id) ON DELETE CASCADE,
                        FOREIGN KEY (prompt_id) REFERENCES prompts(id) ON DELETE CASCADE,
                        UNIQUE(model_id, prompt_id)
                );

                CREATE TABLE IF NOT EXISTS settings (
                        id INTEGER PRIMARY KEY AUTOINCREMENT,
                        key TEXT UNIQUE NOT NULL,
                        value TEXT DEFAULT '',
                        created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
                        updated_at DATETIME DEFAULT CURRENT_TIMESTAMP
                );

                CREATE TABLE IF NOT EXISTS evaluation_jobs (
                        id INTEGER PRIMARY KEY AUTOINCREMENT,
                        suite_id INTEGER NOT NULL,
                        job_type TEXT NOT NULL,
                        target_id INTEGER,
                        status TEXT DEFAULT 'pending',
                        progress_current INTEGER DEFAULT 0,
                        progress_total INTEGER DEFAULT 0,
                        estimated_cost_usd REAL DEFAULT 0,
                        actual_cost_usd REAL DEFAULT 0,
                        error_message TEXT DEFAULT '',
                        created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
                        started_at DATETIME,
                        completed_at DATETIME,
                        FOREIGN KEY (suite_id) REFERENCES suites(id) ON DELETE CASCADE
                );

                CREATE TABLE IF NOT EXISTS model_responses (
                        id INTEGER PRIMARY KEY AUTOINCREMENT,
                        model_id INTEGER NOT NULL,
                        prompt_id INTEGER NOT NULL,
                        response_text TEXT DEFAULT '',
                        response_source TEXT DEFAULT '',
                        api_config TEXT DEFAULT '',
                        created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
                        updated_at DATETIME DEFAULT CURRENT_TIMESTAMP,
                        FOREIGN KEY (model_id) REFERENCES models(id) ON DELETE CASCADE,
                        FOREIGN KEY (prompt_id) REFERENCES prompts(id) ON DELETE CASCADE
                );

                CREATE TABLE IF NOT EXISTS evaluation_history (
                        id INTEGER PRIMARY KEY AUTOINCREMENT,
                        job_id INTEGER NOT NULL,
                        model_id INTEGER NOT NULL,
                        prompt_id INTEGER NOT NULL,
                        judge_name TEXT NOT NULL,
                        judge_score INTEGER DEFAULT 0,
                        judge_confidence REAL DEFAULT 0,
                        judge_reasoning TEXT DEFAULT '',
                        cost_usd REAL DEFAULT 0,
                        created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
                        FOREIGN KEY (job_id) REFERENCES evaluation_jobs(id) ON DELETE CASCADE,
                        FOREIGN KEY (model_id) REFERENCES models(id) ON DELETE CASCADE,
                        FOREIGN KEY (prompt_id) REFERENCES prompts(id) ON DELETE CASCADE
                );

                CREATE TABLE IF NOT EXISTS cost_tracking (
                        id INTEGER PRIMARY KEY AUTOINCREMENT,
                        suite_id INTEGER NOT NULL,
                        date DATE NOT NULL,
                        total_cost_usd REAL DEFAULT 0,
                        evaluation_count INTEGER DEFAULT 0,
                        FOREIGN KEY (suite_id) REFERENCES suites(id) ON DELETE CASCADE,
                        UNIQUE(suite_id, date)
                );

                -- Insert default suite
                INSERT INTO suites (name, is_current) VALUES ('default', 1);
        `

        _, err := db.Exec(schema)
        return err
}</span>

// CreateTestSuite creates a test suite and returns its ID
func CreateTestSuite(t *testing.T, db *sql.DB, name string) int <span class="cov8" title="1">{
        t.Helper()
        result, err := db.Exec("INSERT INTO suites (name, is_current) VALUES (?, 0)", name)
        if err != nil </span><span class="cov8" title="1">{
                fatalf(t, "failed to create test suite: %v", err)
                return 0
        }</span>
        <span class="cov8" title="1">id, err := lastInsertID(result)
        if err != nil </span><span class="cov8" title="1">{
                fatalf(t, "failed to get suite id: %v", err)
                return 0
        }</span>
        <span class="cov8" title="1">return int(id)</span>
}

// CreateTestProfile creates a test profile and returns its ID
func CreateTestProfile(t *testing.T, db *sql.DB, suiteID int, name, description string) int <span class="cov8" title="1">{
        t.Helper()
        result, err := db.Exec("INSERT INTO profiles (name, description, suite_id) VALUES (?, ?, ?)", name, description, suiteID)
        if err != nil </span><span class="cov8" title="1">{
                fatalf(t, "failed to create test profile: %v", err)
                return 0
        }</span>
        <span class="cov8" title="1">id, err := lastInsertID(result)
        if err != nil </span><span class="cov8" title="1">{
                fatalf(t, "failed to get profile id: %v", err)
                return 0
        }</span>
        <span class="cov8" title="1">return int(id)</span>
}

// CreateTestPrompt creates a test prompt and returns its ID
func CreateTestPrompt(t *testing.T, db *sql.DB, suiteID int, text, solution string, profileID *int, displayOrder int, promptType string) int <span class="cov8" title="1">{
        t.Helper()
        var result sql.Result
        var err error
        if profileID != nil </span><span class="cov8" title="1">{
                result, err = db.Exec("INSERT INTO prompts (text, solution, profile_id, suite_id, display_order, type) VALUES (?, ?, ?, ?, ?, ?)",
                        text, solution, *profileID, suiteID, displayOrder, promptType)
        }</span> else<span class="cov8" title="1"> {
                result, err = db.Exec("INSERT INTO prompts (text, solution, suite_id, display_order, type) VALUES (?, ?, ?, ?, ?)",
                        text, solution, suiteID, displayOrder, promptType)
        }</span>
        <span class="cov8" title="1">if err != nil </span><span class="cov8" title="1">{
                fatalf(t, "failed to create test prompt: %v", err)
                return 0
        }</span>
        <span class="cov8" title="1">id, err := lastInsertID(result)
        if err != nil </span><span class="cov8" title="1">{
                fatalf(t, "failed to get prompt id: %v", err)
                return 0
        }</span>
        <span class="cov8" title="1">return int(id)</span>
}

// CreateTestModel creates a test model and returns its ID
func CreateTestModel(t *testing.T, db *sql.DB, suiteID int, name string) int <span class="cov8" title="1">{
        t.Helper()
        result, err := db.Exec("INSERT INTO models (name, suite_id) VALUES (?, ?)", name, suiteID)
        if err != nil </span><span class="cov8" title="1">{
                fatalf(t, "failed to create test model: %v", err)
                return 0
        }</span>
        <span class="cov8" title="1">id, err := lastInsertID(result)
        if err != nil </span><span class="cov8" title="1">{
                fatalf(t, "failed to get model id: %v", err)
                return 0
        }</span>
        <span class="cov8" title="1">return int(id)</span>
}

// CreateTestScore creates a test score
func CreateTestScore(t *testing.T, db *sql.DB, modelID, promptID, score int) <span class="cov8" title="1">{
        t.Helper()
        _, err := db.Exec("INSERT INTO scores (model_id, prompt_id, score) VALUES (?, ?, ?)", modelID, promptID, score)
        if err != nil </span><span class="cov8" title="1">{
                fatalf(t, "failed to create test score: %v", err)
                return
        }</span>
}

// GetDefaultSuiteID returns the ID of the default suite
func GetDefaultSuiteID(t *testing.T, db *sql.DB) int <span class="cov8" title="1">{
        t.Helper()
        var id int
        err := db.QueryRow("SELECT id FROM suites WHERE name = 'default'").Scan(&amp;id)
        if err != nil </span><span class="cov8" title="1">{
                fatalf(t, "failed to get default suite id: %v", err)
                return 0
        }</span>
        <span class="cov8" title="1">return id</span>
}

// SetCurrentSuite sets the current suite
func SetCurrentSuite(t *testing.T, db *sql.DB, suiteID int) <span class="cov8" title="1">{
        t.Helper()
        _, err := db.Exec("UPDATE suites SET is_current = 0")
        if err != nil </span><span class="cov8" title="1">{
                fatalf(t, "failed to clear current suite: %v", err)
                return
        }</span>
        <span class="cov8" title="1">_, err = db.Exec("UPDATE suites SET is_current = 1 WHERE id = ?", suiteID)
        if err != nil </span><span class="cov8" title="1">{
                fatalf(t, "failed to set current suite: %v", err)
                return
        }</span>
}

// CreateTestSetting creates a test setting
func CreateTestSetting(t *testing.T, db *sql.DB, key, value string) <span class="cov8" title="1">{
        t.Helper()
        _, err := db.Exec("INSERT OR REPLACE INTO settings (key, value) VALUES (?, ?)", key, value)
        if err != nil </span><span class="cov8" title="1">{
                fatalf(t, "failed to create test setting: %v", err)
                return
        }</span>
}

// CreateTestEvaluationJob creates a test evaluation job and returns its ID
func CreateTestEvaluationJob(t *testing.T, db *sql.DB, suiteID int, jobType, status string) int <span class="cov8" title="1">{
        t.Helper()
        result, err := db.Exec("INSERT INTO evaluation_jobs (suite_id, job_type, status) VALUES (?, ?, ?)", suiteID, jobType, status)
        if err != nil </span><span class="cov8" title="1">{
                fatalf(t, "failed to create test evaluation job: %v", err)
                return 0
        }</span>
        <span class="cov8" title="1">id, err := lastInsertID(result)
        if err != nil </span><span class="cov8" title="1">{
                fatalf(t, "failed to get job id: %v", err)
                return 0
        }</span>
        <span class="cov8" title="1">return int(id)</span>
}

// CreateTestModelResponse creates a test model response
func CreateTestModelResponse(t *testing.T, db *sql.DB, modelID, promptID int, responseText string) <span class="cov8" title="1">{
        t.Helper()
        _, err := db.Exec("INSERT INTO model_responses (model_id, prompt_id, response_text) VALUES (?, ?, ?)",
                modelID, promptID, responseText)
        if err != nil </span><span class="cov8" title="1">{
                fatalf(t, "failed to create test model response: %v", err)
                return
        }</span>
}

// MockRenderer implements TemplateRenderer for testing with error injection
type MockRenderer struct {
        RenderError error
        RenderCalls []MockRenderCall
}

// MockRenderCall records a call to Render
type MockRenderCall struct {
        Name  string
        Data  interface{}
        Files []string
}

// Render records the call and returns any configured error
func (m *MockRenderer) Render(w http.ResponseWriter, name string, funcMap template.FuncMap, data interface{}, files ...string) error <span class="cov8" title="1">{
        m.RenderCalls = append(m.RenderCalls, MockRenderCall{
                Name:  name,
                Data:  data,
                Files: files,
        })
        if m.RenderError != nil </span><span class="cov8" title="1">{
                return m.RenderError
        }</span>
        // Write minimal content to satisfy tests expecting output
        <span class="cov8" title="1">w.Write([]byte("mock rendered"))
        return nil</span>
}

// RenderTemplateSimple records the call and returns any configured error
func (m *MockRenderer) RenderTemplateSimple(w http.ResponseWriter, tmpl string, data interface{}) error <span class="cov8" title="1">{
        return m.Render(w, tmpl, nil, data, "templates/"+tmpl)
}</span>

// MockDataStore implements DataStore interface for testing with error injection
// Note: This uses local types (Prompt, Profile, Result) that mirror middleware types
// The handlers tests must use type assertions or conversion when using this mock
type MockDataStore struct {
        // Function hooks for custom behavior
        GetCurrentSuiteIDFunc   func() (int, error)
        GetCurrentSuiteNameFunc func() string
        ListSuitesFunc          func() ([]string, error)
        SetCurrentSuiteFunc     func(name string) error
        SuiteExistsFunc         func(name string) bool
        ReadPromptsFunc         func() []Prompt
        WritePromptsFunc        func(prompts []Prompt) error
        ReadPromptSuiteFunc     func(suiteName string) ([]Prompt, error)
        WritePromptSuiteFunc    func(suiteName string, prompts []Prompt) error
        ListPromptSuitesFunc    func() ([]string, error)
        UpdatePromptsOrderFunc  func(order []int)
        ReadProfilesFunc        func() []Profile
        WriteProfilesFunc       func(profiles []Profile) error
        ReadResultsFunc         func() map[string]Result
        WriteResultsFunc        func(suiteName string, results map[string]Result) error
        GetSettingFunc          func(key string) (string, error)
        SetSettingFunc          func(key, value string) error
        GetAPIKeyFunc           func(provider string) (string, error)
        SetAPIKeyFunc           func(provider, key string) error
        GetMaskedAPIKeysFunc    func() (map[string]string, error)
        BroadcastResultsFunc    func()

        // Default error to return
        Err error

        // Mock data
        Prompts      []Prompt
        Profiles     []Profile
        Results      map[string]Result
        Settings     map[string]string
        CurrentSuite string
}

// GetCurrentSuiteID returns mock suite ID or error
func (m *MockDataStore) GetCurrentSuiteID() (int, error) <span class="cov8" title="1">{
        if m.GetCurrentSuiteIDFunc != nil </span><span class="cov8" title="1">{
                return m.GetCurrentSuiteIDFunc()
        }</span>
        <span class="cov8" title="1">if m.Err != nil </span><span class="cov8" title="1">{
                return 0, m.Err
        }</span>
        <span class="cov8" title="1">return 1, nil</span>
}

// GetCurrentSuiteName returns mock suite name
func (m *MockDataStore) GetCurrentSuiteName() string <span class="cov8" title="1">{
        if m.GetCurrentSuiteNameFunc != nil </span><span class="cov8" title="1">{
                return m.GetCurrentSuiteNameFunc()
        }</span>
        <span class="cov8" title="1">if m.CurrentSuite != "" </span><span class="cov8" title="1">{
                return m.CurrentSuite
        }</span>
        <span class="cov8" title="1">return "default"</span>
}

// ListSuites returns mock suites or error
func (m *MockDataStore) ListSuites() ([]string, error) <span class="cov8" title="1">{
        if m.ListSuitesFunc != nil </span><span class="cov8" title="1">{
                return m.ListSuitesFunc()
        }</span>
        <span class="cov8" title="1">if m.Err != nil </span><span class="cov8" title="1">{
                return nil, m.Err
        }</span>
        <span class="cov8" title="1">return []string{"default"}, nil</span>
}

// SetCurrentSuite returns mock error
func (m *MockDataStore) SetCurrentSuite(name string) error <span class="cov8" title="1">{
        if m.SetCurrentSuiteFunc != nil </span><span class="cov8" title="1">{
                return m.SetCurrentSuiteFunc(name)
        }</span>
        <span class="cov8" title="1">if m.Err != nil </span><span class="cov8" title="1">{
                return m.Err
        }</span>
        <span class="cov8" title="1">m.CurrentSuite = name
        return nil</span>
}

// SuiteExists returns mock result
func (m *MockDataStore) SuiteExists(name string) bool <span class="cov8" title="1">{
        if m.SuiteExistsFunc != nil </span><span class="cov8" title="1">{
                return m.SuiteExistsFunc(name)
        }</span>
        <span class="cov8" title="1">return true</span>
}

// ReadPrompts returns mock prompts
func (m *MockDataStore) ReadPrompts() []Prompt <span class="cov8" title="1">{
        if m.ReadPromptsFunc != nil </span><span class="cov8" title="1">{
                return m.ReadPromptsFunc()
        }</span>
        <span class="cov8" title="1">return m.Prompts</span>
}

// WritePrompts stores prompts or returns error
func (m *MockDataStore) WritePrompts(prompts []Prompt) error <span class="cov8" title="1">{
        if m.WritePromptsFunc != nil </span><span class="cov8" title="1">{
                return m.WritePromptsFunc(prompts)
        }</span>
        <span class="cov8" title="1">if m.Err != nil </span><span class="cov8" title="1">{
                return m.Err
        }</span>
        <span class="cov8" title="1">m.Prompts = prompts
        return nil</span>
}

// ReadPromptSuite returns mock prompts for a suite
func (m *MockDataStore) ReadPromptSuite(suiteName string) ([]Prompt, error) <span class="cov8" title="1">{
        if m.ReadPromptSuiteFunc != nil </span><span class="cov8" title="1">{
                return m.ReadPromptSuiteFunc(suiteName)
        }</span>
        <span class="cov8" title="1">if m.Err != nil </span><span class="cov8" title="1">{
                return nil, m.Err
        }</span>
        <span class="cov8" title="1">return m.Prompts, nil</span>
}

// WritePromptSuite stores prompts for a suite
func (m *MockDataStore) WritePromptSuite(suiteName string, prompts []Prompt) error <span class="cov8" title="1">{
        if m.WritePromptSuiteFunc != nil </span><span class="cov8" title="1">{
                return m.WritePromptSuiteFunc(suiteName, prompts)
        }</span>
        <span class="cov8" title="1">if m.Err != nil </span><span class="cov8" title="1">{
                return m.Err
        }</span>
        <span class="cov8" title="1">m.Prompts = prompts
        return nil</span>
}

// ListPromptSuites returns mock suite list
func (m *MockDataStore) ListPromptSuites() ([]string, error) <span class="cov8" title="1">{
        if m.ListPromptSuitesFunc != nil </span><span class="cov8" title="1">{
                return m.ListPromptSuitesFunc()
        }</span>
        <span class="cov8" title="1">if m.Err != nil </span><span class="cov8" title="1">{
                return nil, m.Err
        }</span>
        <span class="cov8" title="1">return []string{"default"}, nil</span>
}

// UpdatePromptsOrder updates prompts order
func (m *MockDataStore) UpdatePromptsOrder(order []int) <span class="cov8" title="1">{
        if m.UpdatePromptsOrderFunc != nil </span><span class="cov8" title="1">{
                m.UpdatePromptsOrderFunc(order)
        }</span>
}

// ReadProfiles returns mock profiles
func (m *MockDataStore) ReadProfiles() []Profile <span class="cov8" title="1">{
        if m.ReadProfilesFunc != nil </span><span class="cov8" title="1">{
                return m.ReadProfilesFunc()
        }</span>
        <span class="cov8" title="1">return m.Profiles</span>
}

// WriteProfiles stores profiles or returns error
func (m *MockDataStore) WriteProfiles(profiles []Profile) error <span class="cov8" title="1">{
        if m.WriteProfilesFunc != nil </span><span class="cov8" title="1">{
                return m.WriteProfilesFunc(profiles)
        }</span>
        <span class="cov8" title="1">if m.Err != nil </span><span class="cov8" title="1">{
                return m.Err
        }</span>
        <span class="cov8" title="1">m.Profiles = profiles
        return nil</span>
}

// ReadResults returns mock results
func (m *MockDataStore) ReadResults() map[string]Result <span class="cov8" title="1">{
        if m.ReadResultsFunc != nil </span><span class="cov8" title="1">{
                return m.ReadResultsFunc()
        }</span>
        <span class="cov8" title="1">if m.Results == nil </span><span class="cov8" title="1">{
                return make(map[string]Result)
        }</span>
        <span class="cov8" title="1">return m.Results</span>
}

// WriteResults stores results or returns error
func (m *MockDataStore) WriteResults(suiteName string, results map[string]Result) error <span class="cov8" title="1">{
        if m.WriteResultsFunc != nil </span><span class="cov8" title="1">{
                return m.WriteResultsFunc(suiteName, results)
        }</span>
        <span class="cov8" title="1">if m.Err != nil </span><span class="cov8" title="1">{
                return m.Err
        }</span>
        <span class="cov8" title="1">m.Results = results
        return nil</span>
}

// GetSetting returns mock setting or error
func (m *MockDataStore) GetSetting(key string) (string, error) <span class="cov8" title="1">{
        if m.GetSettingFunc != nil </span><span class="cov8" title="1">{
                return m.GetSettingFunc(key)
        }</span>
        <span class="cov8" title="1">if m.Err != nil </span><span class="cov8" title="1">{
                return "", m.Err
        }</span>
        <span class="cov8" title="1">if m.Settings != nil </span><span class="cov8" title="1">{
                return m.Settings[key], nil
        }</span>
        <span class="cov8" title="1">return "", nil</span>
}

// SetSetting stores setting or returns error
func (m *MockDataStore) SetSetting(key, value string) error <span class="cov8" title="1">{
        if m.SetSettingFunc != nil </span><span class="cov8" title="1">{
                return m.SetSettingFunc(key, value)
        }</span>
        <span class="cov8" title="1">if m.Err != nil </span><span class="cov8" title="1">{
                return m.Err
        }</span>
        <span class="cov8" title="1">if m.Settings == nil </span><span class="cov8" title="1">{
                m.Settings = make(map[string]string)
        }</span>
        <span class="cov8" title="1">m.Settings[key] = value
        return nil</span>
}

// GetAPIKey returns mock API key or error
func (m *MockDataStore) GetAPIKey(provider string) (string, error) <span class="cov8" title="1">{
        if m.GetAPIKeyFunc != nil </span><span class="cov8" title="1">{
                return m.GetAPIKeyFunc(provider)
        }</span>
        <span class="cov8" title="1">if m.Err != nil </span><span class="cov8" title="1">{
                return "", m.Err
        }</span>
        <span class="cov8" title="1">return "", nil</span>
}

// SetAPIKey stores API key or returns error
func (m *MockDataStore) SetAPIKey(provider, key string) error <span class="cov8" title="1">{
        if m.SetAPIKeyFunc != nil </span><span class="cov8" title="1">{
                return m.SetAPIKeyFunc(provider, key)
        }</span>
        <span class="cov8" title="1">return m.Err</span>
}

// GetMaskedAPIKeys returns mock masked API keys
func (m *MockDataStore) GetMaskedAPIKeys() (map[string]string, error) <span class="cov8" title="1">{
        if m.GetMaskedAPIKeysFunc != nil </span><span class="cov8" title="1">{
                return m.GetMaskedAPIKeysFunc()
        }</span>
        <span class="cov8" title="1">if m.Err != nil </span><span class="cov8" title="1">{
                return nil, m.Err
        }</span>
        <span class="cov8" title="1">return map[string]string{}, nil</span>
}

// BroadcastResults does nothing in mock
func (m *MockDataStore) BroadcastResults() <span class="cov8" title="1">{
        if m.BroadcastResultsFunc != nil </span><span class="cov8" title="1">{
                m.BroadcastResultsFunc()
        }</span>
}
</pre>
		
		<pre class="file" id="file28" style="display: none">package main

import (
        "log"
        "os"
)

var osExit = os.Exit

func main() <span class="cov8" title="1">{
        log.SetOutput(os.Stderr)
        osExit(run(os.Args[1:], defaultRunDeps()))
}</span>
</pre>
		
		<pre class="file" id="file29" style="display: none">package main

import (
        "llm-tournament/handlers"
        "llm-tournament/middleware"
        "log"
        "net/http"
)

var routes = map[string]http.HandlerFunc{
        "/import_error":            middleware.ImportErrorHandler,
        "/prompts":                 handlers.PromptListHandler,
        "/add_model":               handlers.AddModelHandler,
        "/edit_model":              handlers.EditModelHandler,
        "/delete_model":            handlers.DeleteModelHandler,
        "/add_prompt":              handlers.AddPromptHandler,
        "/edit_prompt":             handlers.EditPromptHandler,
        "/delete_prompt":           handlers.DeletePromptHandler,
        "/move_prompt":             handlers.MovePromptHandler,
        "/import_results":          handlers.ImportResultsHandler,
        "/export_prompts":          handlers.ExportPromptsHandler,
        "/import_prompts":          handlers.ImportPromptsHandler,
        "/update_prompts_order":    handlers.UpdatePromptsOrderHandler,
        "/reset_prompts":           handlers.ResetPromptsHandler,
        "/bulk_delete_prompts":     handlers.BulkDeletePromptsHandler,
        "/prompts/suites/new":      handlers.NewPromptSuiteHandler,
        "/prompts/suites/edit":     handlers.EditPromptSuiteHandler,
        "/prompts/suites/delete":   handlers.DeletePromptSuiteHandler,
        "/prompts/suites/select":   handlers.SelectPromptSuiteHandler,
        "/results":                 handlers.ResultsHandler,
        "/update_result":           handlers.UpdateResultHandler,
        "/reset_results":           handlers.ResetResultsHandler,
        "/confirm_refresh_results": handlers.ConfirmRefreshResultsHandler,
        "/refresh_results":         handlers.RefreshResultsHandler,
        "/export_results":          handlers.ExportResultsHandler,
        "/update_mock_results":     handlers.UpdateMockResultsHandler,
        "/evaluate":                handlers.EvaluateResult,
        "/profiles":                handlers.ProfilesHandler,
        "/add_profile":             handlers.AddProfileHandler,
        "/edit_profile":            handlers.EditProfileHandler,
        "/delete_profile":          handlers.DeleteProfileHandler,
        "/reset_profiles":          handlers.ResetProfilesHandler,
        "/stats":                   handlers.StatsHandler,
        "/settings":                handlers.SettingsHandler,
        "/settings/update":         handlers.UpdateSettingsHandler,
        "/settings/test_key":       handlers.TestAPIKeyHandler,
        "/evaluate/all":            handlers.EvaluateAllHandler,
        "/evaluate/model":          handlers.EvaluateModelHandler,
        "/evaluate/prompt":         handlers.EvaluatePromptHandler,
        "/evaluation/progress":     handlers.EvaluationProgressHandler,
        "/evaluation/cancel":       handlers.CancelEvaluationHandler,
}

func registerRoutes(mux *http.ServeMux) <span class="cov8" title="1">{
        mux.HandleFunc("/", router)
        mux.HandleFunc("/ws", middleware.HandleWebSocket)
        mux.Handle("/templates/", http.StripPrefix("/templates/", http.FileServer(http.Dir("templates"))))
        mux.Handle("/assets/", http.StripPrefix("/assets/", http.FileServer(http.Dir("assets"))))
}</span>

func router(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        if handler, exists := routes[r.URL.Path]; exists </span><span class="cov8" title="1">{
                handler(w, r)
                return
        }</span>

        <span class="cov8" title="1">log.Printf("redirecting to /prompts from %s", r.URL.Path)
        http.Redirect(w, r, "/prompts", http.StatusSeeOther)</span>
}
</pre>
		
		<pre class="file" id="file30" style="display: none">package main

import (
        "context"
        "database/sql"
        "flag"
        "fmt"
        "io"
        "llm-tournament/handlers"
        "llm-tournament/middleware"
        "log"
        "net"
        "net/http"
        "os"
        "os/signal"
        "syscall"
        "time"
)

type runDeps struct {
        stdout io.Writer

        initDB         func(string) error
        closeDB        func() error
        seedDemoData   func() error
        initEvaluator  func(*sql.DB)
        getDB          func() *sql.DB
        listen         func(network, address string) (net.Listener, error)
        serve          func(*http.Server, net.Listener) error
        signalCh       &lt;-chan os.Signal
        setLogOutput   func(io.Writer)
        ensureDemoKey  func()
        registerRoutes func(*http.ServeMux)
}

func defaultRunDeps() runDeps <span class="cov8" title="1">{
        return runDeps{
                stdout:         os.Stdout,
                initDB:         middleware.InitDB,
                closeDB:        middleware.CloseDB,
                seedDemoData:   seedDemoData,
                initEvaluator:  handlers.InitEvaluator,
                getDB:          middleware.GetDB,
                listen:         net.Listen,
                serve:          func(s *http.Server, ln net.Listener) error </span><span class="cov8" title="1">{ return s.Serve(ln) }</span>,
                setLogOutput:   log.SetOutput,
                ensureDemoKey:  ensureDemoEncryptionKey,
                registerRoutes: registerRoutes,
        }
}

func run(args []string, deps runDeps) int <span class="cov8" title="1">{
        if deps.stdout == nil </span><span class="cov8" title="1">{
                deps.stdout = io.Discard
        }</span>
        <span class="cov8" title="1">if deps.setLogOutput == nil </span><span class="cov8" title="1">{
                deps.setLogOutput = log.SetOutput
        }</span>
        <span class="cov8" title="1">if deps.ensureDemoKey == nil </span><span class="cov8" title="1">{
                deps.ensureDemoKey = ensureDemoEncryptionKey
        }</span>
        <span class="cov8" title="1">if deps.registerRoutes == nil </span><span class="cov8" title="1">{
                deps.registerRoutes = registerRoutes
        }</span>

        <span class="cov8" title="1">fs := flag.NewFlagSet("demo-server", flag.ContinueOnError)
        fs.SetOutput(io.Discard)

        addr := fs.String("addr", "127.0.0.1:0", "listen address (use :0 for random port)")
        db := fs.String("db", "", "path to sqlite db file (required)")
        seed := fs.Bool("seed", true, "seed demo data")

        if err := fs.Parse(args); err != nil </span><span class="cov8" title="1">{
                return 2
        }</span>

        <span class="cov8" title="1">if *db == "" </span><span class="cov8" title="1">{
                log.Print("missing required -db")
                return 1
        }</span>

        <span class="cov8" title="1">deps.ensureDemoKey()

        if err := deps.initDB(*db); err != nil </span><span class="cov8" title="1">{
                log.Printf("init db: %v", err)
                return 1
        }</span>
        <span class="cov8" title="1">defer func() </span><span class="cov8" title="1">{ _ = deps.closeDB() }</span>()

        <span class="cov8" title="1">if *seed </span><span class="cov8" title="1">{
                if err := deps.seedDemoData(); err != nil </span><span class="cov8" title="1">{
                        log.Printf("seed demo data: %v", err)
                        return 1
                }</span>
        }

        <span class="cov8" title="1">deps.initEvaluator(deps.getDB())

        mux := http.NewServeMux()
        deps.registerRoutes(mux)

        server := &amp;http.Server{
                Handler:           mux,
                ReadHeaderTimeout: 5 * time.Second,
        }

        ln, err := deps.listen("tcp", *addr)
        if err != nil </span><span class="cov8" title="1">{
                log.Printf("listen: %v", err)
                return 1
        }</span>

        // stdout is reserved for machine-readable output (used by Playwright harness).
        <span class="cov8" title="1">fmt.Fprintf(deps.stdout, "URL=http://%s\n", ln.Addr().String())

        shutdownCh := make(chan struct{}, 1)
        mux.HandleFunc("/__shutdown", func(w http.ResponseWriter, r *http.Request) </span><span class="cov8" title="1">{
                if r.Method != http.MethodPost </span><span class="cov8" title="1">{
                        http.Error(w, "method not allowed", http.StatusMethodNotAllowed)
                        return
                }</span>
                <span class="cov8" title="1">w.WriteHeader(http.StatusOK)
                select </span>{
                case shutdownCh &lt;- struct{}{}:<span class="cov8" title="1"></span>
                default:<span class="cov0" title="0"></span>
                }
        })

        <span class="cov8" title="1">errCh := make(chan error, 1)
        go func() </span><span class="cov8" title="1">{
                errCh &lt;- deps.serve(server, ln)
        }</span>()

        <span class="cov8" title="1">sigCh := deps.signalCh
        if sigCh == nil </span><span class="cov8" title="1">{
                c := make(chan os.Signal, 1)
                signal.Notify(c, os.Interrupt, syscall.SIGTERM)
                defer signal.Stop(c)
                sigCh = c
        }</span>

        <span class="cov8" title="1">select </span>{
        case &lt;-sigCh:<span class="cov0" title="0"></span>
        case &lt;-shutdownCh:<span class="cov8" title="1"></span>
        case err := &lt;-errCh:<span class="cov8" title="1">
                if err != nil &amp;&amp; err != http.ErrServerClosed </span><span class="cov8" title="1">{
                        log.Printf("server error: %v", err)
                        return 1
                }</span>
        }

        <span class="cov8" title="1">ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
        defer cancel()
        _ = server.Shutdown(ctx)

        return 0</span>
}
</pre>
		
		<pre class="file" id="file31" style="display: none">package main

import (
        "fmt"
        "llm-tournament/middleware"
        "math/rand"
        "os"
        "time"
)

func ensureDemoEncryptionKey() <span class="cov8" title="1">{
        if os.Getenv("ENCRYPTION_KEY") != "" </span><span class="cov8" title="1">{
                return
        }</span>

        // Deterministic key for screenshot generation only.
        <span class="cov8" title="1">_ = os.Setenv("ENCRYPTION_KEY", "0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef")</span>
}

func seedDemoData() error <span class="cov8" title="1">{
        suiteName := "default"
        if err := middleware.SetCurrentSuite(suiteName); err != nil </span><span class="cov8" title="1">{
                return fmt.Errorf("set current suite: %w", err)
        }</span>

        <span class="cov8" title="1">profiles := []middleware.Profile{
                {Name: "general", Description: "General reasoning and knowledge"},
                {Name: "programming", Description: "Coding, debugging, and systems design"},
                {Name: "writing", Description: "Clarity, tone, and composition"},
        }
        if err := middleware.WriteProfileSuite(suiteName, profiles); err != nil </span><span class="cov8" title="1">{
                return fmt.Errorf("write profiles: %w", err)
        }</span>

        <span class="cov8" title="1">prompts := []middleware.Prompt{
                {
                        Profile:  "general",
                        Text:     "Explain the difference between correlation and causation in 2-3 sentences.",
                        Solution: "Correlation is association; causation is when one factor directly produces an effect.",
                },
                {
                        Profile:  "general",
                        Text:     "Give a one-paragraph summary of the water cycle.",
                        Solution: "Evaporation → condensation → precipitation → collection, driven by solar energy and gravity.",
                },
                {
                        Profile:  "general",
                        Text:     "What is Bayes' theorem in one sentence?",
                        Solution: "It updates the probability of a hypothesis given evidence using conditional probabilities.",
                },
                {
                        Profile:  "general",
                        Text:     "List 3 practical uses of SQLite in apps.",
                        Solution: "Local caching, offline-first storage, and embedded configuration/state for desktop/mobile apps.",
                },
                {
                        Profile:  "general",
                        Text:     "Define 'idempotent' in the context of web APIs.",
                        Solution: "Calling the same operation multiple times produces the same end state as calling it once.",
                },
                {
                        Profile:  "general",
                        Text:     "In one sentence, what is a unit test?",
                        Solution: "A fast, isolated test that verifies a small piece of code behaves as expected.",
                },
                {
                        Profile:  "programming",
                        Text:     "Write a Go function that returns the max of two ints.",
                        Solution: "func Max(a, b int) int { if a &gt; b { return a }; return b }",
                },
                {
                        Profile:  "programming",
                        Text:     "What does SQL 'FOREIGN KEY ... ON DELETE CASCADE' do?",
                        Solution: "Deleting the parent row automatically deletes related child rows referencing it.",
                },
                {
                        Profile:  "programming",
                        Text:     "What is the difference between a goroutine and an OS thread?",
                        Solution: "Goroutines are lightweight user-space scheduled units; OS threads are heavier kernel-scheduled threads.",
                },
                {
                        Profile:  "programming",
                        Text:     "Explain what CGO is and why SQLite often needs it in Go.",
                        Solution: "CGO lets Go call C code; the common SQLite driver links C SQLite and requires CGO.",
                },
                {
                        Profile:  "programming",
                        Text:     "What does 'context.Context' enable in Go HTTP handlers?",
                        Solution: "Cancellation, deadlines, and request-scoped values across API boundaries.",
                },
                {
                        Profile:  "programming",
                        Text:     "Give a 1-2 sentence explanation of XSS and how to mitigate it.",
                        Solution: "XSS injects scripts into pages; mitigate with output escaping/sanitization and strict CSP.",
                },
                {
                        Profile:  "writing",
                        Text:     "Rewrite this sentence to be more concise: 'Due to the fact that it was raining, we decided to stay inside.'",
                        Solution: "Because it was raining, we stayed inside.",
                },
                {
                        Profile:  "writing",
                        Text:     "Draft a two-sentence product description for a futuristic desktop dashboard UI.",
                        Solution: "A sleek, high-density dashboard that turns model evaluation into a control-room experience. Neon-glass panels, fast navigation, and real-time insights—without sacrificing clarity.",
                },
                {
                        Profile:  "writing",
                        Text:     "Rewrite in active voice: 'The report was generated by the system automatically.'",
                        Solution: "The system generated the report automatically.",
                },
                {
                        Profile:  "writing",
                        Text:     "Write a clear error message for a missing API key.",
                        Solution: "API key not configured. Add it in Settings to enable automated evaluation.",
                },
                {
                        Profile:  "writing",
                        Text:     "Create a short tooltip explaining a 0–100 scoring scale.",
                        Solution: "Score quality from 0 (fail) to 100 (excellent), in 20-point steps.",
                },
                {
                        Profile:  "writing",
                        Text:     "Turn this into a bullet list: 'fast, reproducible, and readable.'",
                        Solution: "- fast\n- reproducible\n- readable",
                },
        }
        if err := middleware.WritePromptSuite(suiteName, prompts); err != nil </span><span class="cov8" title="1">{
                return fmt.Errorf("write prompts: %w", err)
        }</span>

        <span class="cov8" title="1">rng := rand.New(rand.NewSource(42))
        results := map[string]middleware.Result{
                "gpt-5.2":         {Scores: randomScores(rng, len(prompts))},
                "claude-opus-4.5": {Scores: randomScores(rng, len(prompts))},
                "gemini-3-pro":    {Scores: randomScores(rng, len(prompts))},
                "deepseek-r1":     {Scores: randomScores(rng, len(prompts))},
                "mixtral-8x22b":   {Scores: randomScores(rng, len(prompts))},
                "llama-3.1-405b":  {Scores: randomScores(rng, len(prompts))},
        }
        if err := middleware.WriteResults(suiteName, results); err != nil </span><span class="cov8" title="1">{
                return fmt.Errorf("write results: %w", err)
        }</span>

        // Populate masked API keys for a more representative Settings screenshot.
        <span class="cov8" title="1">_ = middleware.SetAPIKey("openai", "sk-demo-openai-1234")
        _ = middleware.SetAPIKey("anthropic", "sk-demo-anthropic-5678")
        _ = middleware.SetAPIKey("google", "sk-demo-google-9012")
        _ = middleware.SetSetting("auto_evaluate_new_models", "true")
        _ = middleware.SetSetting("cost_alert_threshold_usd", "25.0")
        _ = middleware.SetSetting("python_service_url", "http://localhost:8001")

        // Make timestamps slightly more realistic in UI components that show recent times.
        _ = middleware.SetSetting("demo_seeded_at", time.Now().UTC().Format(time.RFC3339))

        return nil</span>
}

func randomScores(rng *rand.Rand, n int) []int <span class="cov8" title="1">{
        choices := []int{0, 20, 40, 60, 80, 100}
        scores := make([]int, n)
        for i := 0; i &lt; n; i++ </span><span class="cov8" title="1">{
                // bias toward mid/high scores so the grid looks interesting
                roll := rng.Intn(100)
                switch </span>{
                case roll &lt; 5:<span class="cov8" title="1">
                        scores[i] = choices[0]</span>
                case roll &lt; 15:<span class="cov8" title="1">
                        scores[i] = choices[1]</span>
                case roll &lt; 35:<span class="cov8" title="1">
                        scores[i] = choices[2]</span>
                case roll &lt; 60:<span class="cov8" title="1">
                        scores[i] = choices[3]</span>
                case roll &lt; 85:<span class="cov8" title="1">
                        scores[i] = choices[4]</span>
                default:<span class="cov8" title="1">
                        scores[i] = choices[5]</span>
                }
        }
        <span class="cov8" title="1">return scores</span>
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
